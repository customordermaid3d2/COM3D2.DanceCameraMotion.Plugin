using RenderHeads.Media.AVProVideo;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Xml;
using System.Xml.Linq;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;
using UnityInjector;
using UnityInjector.Attributes;

namespace COM3D2.DanceCameraMotion.PluginTest
{
    #region PluginMain
    ///=========================================================================
    /// <summary>ダンスのカメラモーションを再生するプラグイン</summary>
    /// <remarks>
    ///	COM3D2.DanceCameraMotion.Plugin : COM3D2でダンスのカメラモーションを再生するプラグイン
    /// UnityInjector/Sybaris 用クラス
    /// GearMenuはShaderChange.PluginのGearMenu.csを使用しています。
    /// CM3D2.DanceCameraAdjust.Pluginのソースコードを改変して使用しています。
    /// </remarks>
    ///=========================================================================
    [PluginFilter(MyConst.TITLE_COM3D2),
     PluginName(MyConst.PLUGIN_NAME), PluginVersion(MyConst.PLUGIN_VERSION)]

    public class DanceCameraMotionTest : PluginBase
    {

        #region Variable
        private Rect windowRect = MyConst.MAIN_WINDOW_RECT;
        private Color32 mainLightColor;
        private Vector3 adjustmentPosition;
        private Vector2 scrollMenu;
        private Vector2 scrollCameraList;
        private Vector2 scrollFreeList;
        private Vector2 scrollBackground;
        private Vector2 scrollBackgroundParts;
        private Vector2 scrollForeground;
        private Vector2 scrollStageObject;
        private Vector2 scrollStageModel;
        private Vector2 scrollStageBubbleLame;
        private Vector2 scrollStageParticle;
        private Vector2 scrollStageParticleModule1;
        private Vector2 scrollStageParticleModule2;
        private Vector2 scrollStageParticleModule3;
        private Vector2 scrollStageParticleModule5;
        private Vector2 scrollDressList;
        private Vector2 scrollDressTemp;
        private Vector2 scrollHairMenuList;
        private Vector2 scrollPreset;
        private Vector2 scrollDressPororiList;
        private Vector2 scrollDressBindList;
        private Vector2 scrollMaidXmlList;
        private Vector2 scrollMaidHair;
        private Vector2 scrollMaidSkirt;
        private Vector2 scrollMaidFrameSelection;
        private Vector2 scrollMaidFrameAddition;
        private Vector2 scrollMaidFrameDeletion;
        private Vector2 scrollMaidFrameNewFrame;
        private Vector2 scrollMaidCaptureBone;
        private Vector2 scrollSwitcherXmlData;
        private Vector2 scrollBgInstanceList;
        private Vector2 scrollPoseBorn;
        private Vector2 scrollSlot;
        private Vector2 scrollCustomFace;
        private Vector2 scrollMoving;
        private Vector2 scrollMotionFicial;
        private Vector2 scrollBukkakeParts;
        private Vector2 scrollBukkakeList;
        private Vector2 scrollAutoCamera;

        private Dictionary<LightType, FreeLightSet> lightSetting;
        private Dictionary<LightType, List<string>> lightGroupDic;
        private Dictionary<int, Transform> maidTransformDic;

        private List<FreeDanceSet> freeDanceData;
        private List<DanceMovieSet> danceMovieData;
        private List<CharacterMgr.Preset> presetData;
        private List<MaidTransformSet> maidTransformData;
        private List<SwitcherTransformSet> switcherData;
        private List<string> cameraList;
        private List<string> danceList;
        private List<string> danceGroupList;
        private List<string> randomFaceList;
        private List<string> customFaceList;
        private List<string> movingList;

        private MaidLookAtSet maidLookAt;
        private FreeDanceGroupSet danceGroup;
        private DanceListExporter danceExport;
        private DanceCameraMotionSet freeMotion;
        private DanceCameraMotionSet cameraMotion;
        private MaidMotionSet maidMotion;
        private CameraMotionDeltaSet cameraDelta;
        private CameraTransformSet cameraTest;
        private CameraTransformSet cameraFree;
        private KeySet myKey;
        private GuiSet myGui;
        private MyGuiStyle guiStyle;
        private MoveSpeedSet moveSpeed;
        private RenderTextureSet renderTextureSet;
        private SpriteSet spriteSet;
        private LookAtSet lookAtSet;
        private DanceCameraAdjustSet cameraAdjust;
        private TimeLinePlaySet tlPlaySet;

        private LookAtCameraManager lookAtMgrDiv;
        private LookAtCameraManager lookAtMgrSub;
        private LookAtCameraManager lookAtMgrLock;

        private CameraManager cameraMgr;
        private MaidManager maidMgr;
        private MaidExtraManager extraMgr;
        private TimelineBoneManager boneMgr;
        private TimelineMorphManager morphMgr;
        private TimelineFaceManager faceMgr;
        private TimelineCameraManager mCameraMgr;
        private MaidMotionCaptureManager captureMgr;
        private DressManager dressMgr;
        private HairManager hairMgr;
        private SwingManager swingMgr;
        private SongManager songMgr;
        private StageLightManager lightMgr;
        private DanceObjectManager danceMgr;
        private SoundManager soundMgr;
        private SatgeObjectManager stageMgr;
        private BackgroundManager bgMgr;
        private StageModelManager modelMgr;
        private StageParticleManager particleMgr;
        private MovingMaidManager moveMgr;
        private GuiManager guiMgr;
        private WindowManager windowMgr;
        private GuiTimeLineWindowManager tlWindowMgr;

        private bool isDance = false;
        private bool isDanceStoped = false;
        private bool isDanceAutoEnd = false;
        private bool isCamera = false;
        private bool isCameraStoped = false;
        private bool isFreeDance = false;
        private bool isFreeStoped = false;
        private bool isCameraComboOn = false;
        private bool isFreeComboOn = false;
        private bool isDanceCameraOn = false;
        private bool isDanceCameraCustom = false;
        private bool isExportOn = false;
        private bool isKaraokeOn = false;
        private bool isFreeMotionOn = false;
        private bool isFreeGroupOn = false;
        private bool isSwitcherOn = false;
        private bool isWasdOn = false;
        private bool isRandomFace = false;
        private bool isMaidPresetSave = true;
        private bool isMaidShuffle = false;
        private bool isFixTransform = false;
        private bool isAnyTransform = false;
        private bool isAutoTransform = false;
        private bool isAoutChangingBg = false;
        private bool isMainLightOff = false;
        private bool isSubLightOn = false;
        private bool isGuiMenuDanceInfomation = false;
        private bool isGuiMenuBgTransform = false;
        private bool isGuiMenuModelTransform = false;

        private int guiMainMenuIndex = 0;
        private int cameraListIndex = 0;
        private int danceListIndex = 0;
        private int danceGroupIndex = 0;
        private int danceGroupPlayIndex = 0;
        private int danceBgIndex = 0;
        private int modModelIndex = 0;
        private int randomFaceIndex = 0;
        private int stageObjectIndex = 0;
        private int spotLightIndex = 0;
        private int pointLightIndex = 0;
        private int spotLightGroupIndex = 0;
        private int pointLightGroupIndex = 0;

        private int danceVolumeBackup = 0;
        private int danceVolumeLegacy = 0;

        private float freeSliderCurrent = 0f;
        private float freeSliderMax = 0f;
        private float presetWaitTime = 0f;
        private float additionalBgmTime = 0f;
        private float endBgmTime = 0f;

        private string inputModel = "";
        private string inputBone = "";

        #endregion

        #region baseMethod
        /// <summary>
        /// プラグインロード時処理
        /// </summary>
        public void Awake()
        {
            try
            {
                DontDestroyOnLoad(this);
                MyHelper.RootFolder = Path.Combine(DataPath, MyConst.FOLDER_ROOT);
                SetSceneManager();
                myGui = new GuiSet();
                cameraMgr = new CameraManager();
                maidMgr = new MaidManager(true);
                extraMgr = new MaidExtraManager();
                boneMgr = new TimelineBoneManager(false);
                morphMgr = new TimelineMorphManager(false);
                faceMgr = new TimelineFaceManager(false);
                mCameraMgr = new TimelineCameraManager(false);
                captureMgr = new MaidMotionCaptureManager();
                dressMgr = new DressManager();
                hairMgr = new HairManager();
                swingMgr = new SwingManager();
                songMgr = new SongManager();
                lightMgr = new StageLightManager();
                soundMgr = new SoundManager();
                stageMgr = new SatgeObjectManager();
                bgMgr = new BackgroundManager();
                modelMgr = new StageModelManager();
                particleMgr = new StageParticleManager();
                guiStyle = new MyGuiStyle();
                guiMgr = new GuiManager(guiStyle);
                tlWindowMgr = new GuiTimeLineWindowManager(guiMgr, guiStyle);
                lightGroupDic = new Dictionary<LightType, List<string>>();
                GetSetting();
                moveMgr = new MovingMaidManager(moveSpeed);
                SetLookAtCameraAwake();
                cameraMgr.ReadAutoCameraData("", true);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// GUI呼び出し
        /// </summary>
        public void OnGUI()
        {
            try
            {
                if (myGui.isGuiOn)
                {
                    guiStyle.SetWindowGuiStyle(guiMgr.GuiBackgroundTexture, myGui.isBackgroundEnabled);
                    var pluginName = string.Format("{0} {1}", MyConst.PLUGIN_NAME, MyConst.PLUGIN_VERSION);
                    windowRect = GUI.Window(MyConst.GUI_WINDOW_ID_MAIN, windowRect, MainWindowFunction, pluginName, guiStyle.gsWindow);
                }
                if (tlWindowMgr.IsGuiOn && !isFreeDance && !isDance)
                {
                    var title = string.Format(MyConst.WINDOW_TITLE_MOTION, tlPlaySet.isOfficialDance ? MyConst.TIMELINE_TYPE_LABEL[0] : MyConst.TIMELINE_TYPE_LABEL[1]);
                    tlWindowMgr.WindowRect = GUI.Window(MyConst.GUI_WINDOW_ID_MOTION, tlWindowMgr.WindowRect, TimeLineWindowFunction, title, guiStyle.gsWindow);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// シーンロード時処理関数設定
        /// </summary>
        private void SetSceneManager()
        {
            SceneManager.sceneLoaded += OnSceneLoaded;
            SceneManager.sceneUnloaded += OnSceneUnLoaded;
        }

        // <summary>
        /// シーンロード時処理
        /// </summary>
        private void OnSceneLoaded(Scene scene, LoadSceneMode sceneMode)
        {
            if (scene.name.Contains(MyConst.SHCENE_VR))
            {
                isWasdOn = false;
            }
            var isDance = scene.name.Contains(MyConst.SHCENE_DANCE);
            InitializeVariant(isDance);
            SetGearMenu();
        }

        // <summary>
        /// シーンアンロード時処理
        /// </summary>
        private void OnSceneUnLoaded(Scene scene)
        {
            if (isExportOn && danceExport != null)
            {
                danceExport.ExportDanceInformation(MyHelper.RootFolder, isKaraokeOn);
            }
            if (isDance)
            {
                cameraMotion.camera = null;
                cameraMotion = new DanceCameraMotionSet();
            }
            isDance = false;
        }

        #endregion

        /// <summary>
        /// フレーム毎の更新処理
        /// </summary>
        public void Update()
        {
            try
            {
                if ((Input.GetKey(KeyCode.RightShift) || Input.GetKey(KeyCode.LeftShift)) &&
                    (Input.GetKey(KeyCode.RightControl) || Input.GetKey(KeyCode.LeftControl)) &&
                     Input.GetKeyDown(myKey.gui))
                {
                    windowRect = MyConst.MAIN_WINDOW_RECT;
                    tlWindowMgr.WindowRect = MyConst.MOTION_WINDOW_RECT;
                }
                else if ((Input.GetKey(KeyCode.RightShift) || Input.GetKey(KeyCode.LeftShift)) &&
                         Input.GetKeyDown(myKey.gui))
                {
                    myGui.isGuiOn = !myGui.isGuiOn;
                    if (myGui.isGuiOn)
                    {
                        windowRect.height = MyConst.MAIN_WINDOW_RECT.height;
                    }
                }
                else if (Input.GetKeyDown(KeyCode.Return) && isDance)
                {
                    isDanceStoped = !isDanceStoped;
                }

                if (presetWaitTime > 0f)
                {
                    presetWaitTime -= Time.deltaTime;
                }
                else if (presetWaitTime < 0f)
                {
                    myGui.isGuiOn = true;
                    presetWaitTime = 0f;
                }

                var maids = maidMgr.GetActiveMaids();
                var isMaids = !MyHelper.CheckNull(maids);
                if (isFreeDance)
                {
                    var bgmTime = GetBgmTime();
                    var data = freeDanceData[MyConst.DANCE_FIRST_INDEX];

                    if (!guiMgr.IsFreeEffectOff)
                    {
                        if (!MyHelper.CheckNull(data.changePng) && !MyHelper.CheckNull(danceMgr.PngSpriteRenderer))
                        {
                            danceMgr.ChangeFreeDancePng(data.changePng, bgmTime);
                        }
                        if (!MyHelper.CheckNull(danceMgr.ItemData))
                        {
                            danceMgr.ItemData = maidMgr.ChangeDanceMaidItem(danceMgr.ItemData, bgmTime);
                        }
                        if (!MyHelper.CheckNull(danceMgr.PrefabData) && !MyHelper.CheckNull(danceMgr.DancePrefab))
                        {
                            danceMgr.ChangeFreeDancePrefab(bgmTime, maids, maidMgr);
                        }
                        if (!MyHelper.CheckNull(danceMgr.MaidPrefabData))
                        {
                            danceMgr.MaidPrefabData = maidMgr.ChangeFreeDanceMaidPrefab(bgmTime, danceMgr.MaidPrefabData);
                        }
                        if (!MyHelper.CheckNull(danceMgr.PrimitiveData) && !MyHelper.CheckNull(danceMgr.DancePrimitive))
                        {
                            danceMgr.ChangeFreeDancePrimitive(bgmTime, maids);
                        }
                        if (!MyHelper.CheckNull(danceMgr.ParticleData) && !MyHelper.CheckNull(danceMgr.DanceParticle))
                        {
                            danceMgr.ChangeFreeDanceParticle(bgmTime);
                        }
                        if (!MyHelper.CheckNull(dressMgr.DanceDressData) && !guiMgr.IsChangeDressOff && !isFreeStoped)
                        {
                            dressMgr.ChangeFreeDanceDress(bgmTime, maids, maidMgr);
                        }
                    }
                    if (!guiMgr.IsChangingLightOff && !MyHelper.CheckNull(danceMgr.LightData) && !MyHelper.CheckNull(danceMgr.DanceLight))
                    {
                        danceMgr.ChangeFreeDanceLight(bgmTime, lightMgr, maids, maidMgr);
                    }
                    if (!guiMgr.IsChangingBgOff && !MyHelper.CheckNull(data.changeBg))
                    {
                        danceBgIndex = danceMgr.ChangeFreeDanceBg(data.changeBg, bgmTime, danceBgIndex, isFreeStoped, ref bgMgr);
                    }

                    if (bgmTime != 0 && endBgmTime != 0)
                    {
                        if (bgmTime > endBgmTime)
                        {
                            if (isFreeGroupOn || guiMgr.IsFreeRepeatOn)
                            {
                                EndFreeDance(false);
                                isFreeDance = StartFreeDance(false);
                            }
                            else if (isDanceAutoEnd)
                            {
                                isFreeDance = false;
                                EndFreeDance(true);
                            }
                        }
                        else if (bgmTime > endBgmTime - myGui.fadeOutTime)
                        {
                            if (myGui.isFadeOn && !cameraMgr.IsFadeOut())
                            {
                                cameraMgr.FadeOut(myGui.fadeOutTime);
                            }
                        }
                    }
                    if (isFixTransform)
                    {
                        maidMgr.FixDancePosition();
                    }
                }

                if (dressMgr.IsFreeDance)
                {
                    if (dressMgr.IsStarting)
                    {
                        dressMgr.IsStarting = maidMgr.IsBusyMaid();
                        if (!dressMgr.IsStarting)
                        {
                            swingMgr.SetAutoDance(maids, myGui.isMaidsSwingMuneOn, myGui.isMaidsSwingHairOn, myGui.isMaidsSwingDressOn, maidMgr.IsMultipleMaids);
                            StopFreeDance(false);
                            if (myGui.isFadeOn)
                            {
                                cameraMgr.FadeIn(myGui.fadeInTime);
                            }
                        }
                    }
                    else if (dressMgr.IsEnding)
                    {
                        dressMgr.IsEnding = maidMgr.IsBusyMaid();
                        if (!dressMgr.IsEnding && myGui.isFadeOn)
                        {
                            cameraMgr.FadeIn(myGui.fadeInTime);
                        }
                    }
                }

                if (!isDance && !MyHelper.CheckNull(lightMgr.LightData))
                {
                    foreach (var key in MyConst.LIGHT_TYPE)
                    {
                        if (lightMgr.LightData.ContainsKey(key) && !MyHelper.CheckNull(lightMgr.LightData[key]))
                        {
                            lightMgr.SetLightFollowingPosition(key, maids);
                        }
                    }
                }

                if (!isDance && !MyHelper.CheckNull(modelMgr.ModelData))
                {
                    modelMgr.SetModelFollowingPosition();
                }

                if (!isDance && moveMgr.IsEnabled && isMaids)
                {
                    if (moveMgr.IsAutoForward || Input.GetKey(myKey.movingForward))
                    {
                        moveMgr.IsMove = true;
                        moveMgr.SetMaidMovingPositionZ(maids, maidMgr.GuiMaidIndex, moveMgr.SpeedForward);
                    }
                    var type = moveMgr.IsMove ? (int)MaidMovingType.Move : (int)MaidMovingType.Wait;
                    moveMgr.ChangeMyPose(maids, maidMgr.GuiMaidIndex, type);

                    if (moveMgr.IsAutoRound || Input.GetKey(myKey.movingRightRotation))
                    {
                        moveMgr.SetMaidMovingRotationY(maids, maidMgr.GuiMaidIndex, moveMgr.SpeedRotation);
                    }
                    if (!moveMgr.IsAutoRound && Input.GetKey(myKey.movingLeftRotation))
                    {
                        moveMgr.SetMaidMovingRotationY(maids, maidMgr.GuiMaidIndex, -moveMgr.SpeedRotation);
                    }
                    if (Input.GetKey(myKey.movingUp) && !moveMgr.IsAutoRound)
                    {
                        moveMgr.SetMaidMovingPositionY(maids, maidMgr.GuiMaidIndex, moveMgr.SpeedUpDown);
                    }
                    if (Input.GetKey(myKey.movingDown) && !moveMgr.IsAutoRound)
                    {
                        moveMgr.SetMaidMovingPositionY(maids, maidMgr.GuiMaidIndex, -moveMgr.SpeedUpDown);
                    }
                }

                var kupa = maidMgr.AutoKupaData;
                if (kupa.isKupa || kupa.isAnalKupa && isMaids)
                {
                    var slotNo = maidMgr.GetActiveSlotNo(maids[maidMgr.GuiMaidIndex]);
                    var lerp = Mathf.Clamp01(1 / kupa.interval * Time.deltaTime);
                    kupa.lerpTime += kupa.isReverse ? -lerp : lerp;
                    var val = Mathf.Lerp(kupa.minSize, kupa.maxSize, kupa.lerpTime);

                    if (kupa.isKupa)
                    {
                        maidMgr.SetBodyKupa(maids, slotNo, MyConst.BODY_TAG_KUPA, val, guiMgr.IsMaidAppearanceAll);
                    }
                    if (kupa.isAnalKupa)
                    {
                        maidMgr.SetBodyKupa(maids, slotNo, MyConst.BODY_TAG_ANALKUPA, val, guiMgr.IsMaidAppearanceAll);
                    }

                    if (val <= kupa.minSize)
                    {
                        kupa.lerpTime = 0;
                        kupa.isReverse = false;
                    }
                    else if (kupa.maxSize <= val)
                    {
                        kupa.lerpTime = 1;
                        kupa.isReverse = true;
                    }
                    maidMgr.AutoKupaData = kupa;
                }

                if (extraMgr.IsEnema() && isMaids)
                {
                    if (guiMgr.IsMaidAppearanceAll)
                    {
                        foreach (var maid in maids)
                        {
                            extraMgr.SetTransform(maid, maidMgr.GetActiveSlotNo(maid));
                        }
                    }
                    else
                    {
                        var maid = maids[maidMgr.GuiMaidIndex];
                        extraMgr.SetTransform(maid, maidMgr.GetActiveSlotNo(maid));
                    }
                }

                if (tlPlaySet.isPlay && isMaids && !tlPlaySet.isOfficialDance)
                {
                    if (!tlPlaySet.isPause)
                    {
                        foreach (var maid in maids)
                        {
                            var slotNo = maidMgr.GetActiveSlotNo(maid);
                            boneMgr.UpdatePlayBone(maid, slotNo, tlPlaySet);
                        }
                    }
                }
                else if (captureMgr.IsAnimationCapture && isMaids)
                {
                    var maid = maids[maidMgr.GuiMaidIndex];
                    captureMgr.CaptureAnimation(maid, maidMotion);
                    tlWindowMgr.IsGuiOn = false;
                }
                else if (captureMgr.IsMotionCapture && isMaids)
                {
                    var maid = maids[maidMgr.GuiMaidIndex];
                    captureMgr.CaptureMotion(maid, maidMotion);
                    tlWindowMgr.IsGuiOn = false;
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// update呼び出し後に実行される
        /// </summary>
        public void LateUpdate()
        {
            try
            {
                if (Camera.main == null)
                {
                    return;
                }
                var maids = maidMgr.GetActiveMaids();
                var isMaids = !MyHelper.CheckNull(maids);
                if (isFreeDance)
                {
                    var bgmTime = GetBgmTime();
                    if (cameraFree.edTime != 0 && cameraFree.stTime < cameraFree.edTime && cameraFree.edTime <= bgmTime)
                    {
                        bgmTime = cameraFree.stTime;
                        bgmTime = (bgmTime > freeSliderMax) ? 0f : bgmTime;
                        if (isMaids)
                        {
                            maidMgr.ResetIndex(maids);
                            songMgr.ResetIndex(maids, maidMgr, true);
                        }
                        danceBgIndex = 0;
                    }
                    var fromFrame = tlPlaySet.fromFrame;
                    var syncSet = guiMgr.DanceSyncSet;
                    maidMgr.UpdateFreeDanceMaid(freeDanceData, bgmTime, isFreeStoped, isRandomFace, songMgr, syncSet.isSyncDanceGap,
                                                guiMgr.IsKuchipakuDisabled, guiMgr.IsMaidVisibledOff, tlPlaySet);
                    if (songMgr.IsSong)
                    {
                        songMgr.CrossFadeManSongePose(bgmTime);
                    }

                    if(0 < fromFrame)
                    {
                        tlPlaySet.fromFrame = 0;
                    }

                    var firstData = freeDanceData[MyConst.DANCE_FIRST_INDEX];
                    if (!syncSet.isSyncDanceGap && syncSet.isFirstSync && !songMgr.IsSong)
                    {
                        var startTime = (cameraFree.stTime > 0f) ? cameraFree.stTime : firstData.startTime;
                        if (syncSet.firstSyncTime >= 0f && startTime + syncSet.firstSyncTime <= bgmTime)
                        {
                            var bTime = GetBgmTime();
                            foreach (var maid in maids)
                            {
                                maidMgr.SyncAnimationTime(maid, bTime);
                            }
                            danceMgr.SeekVideo(bTime);
                            syncSet.isFirstSync = false;
                            guiMgr.DanceSyncSet = syncSet;
                        }
                    }
                    else if (songMgr.IsSong && danceMgr.IsVideoPlayed())
                    {
                        var startTime = (cameraFree.stTime > 0) ? cameraFree.stTime : firstData.startTime;
                        if (0 < startTime && danceMgr.GetVideoCurrentTime() < startTime)
                        {
                            danceMgr.SeekVideo(startTime);
                        }
                    }

                    if (freeSliderMax != endBgmTime && (freeSliderMax < bgmTime || freeSliderMax != additionalBgmTime))
                    {
                        additionalBgmTime += Time.deltaTime;
                    }
                }

                if (isMaids)
                {
                    if (!isDance && guiMgr.IsFacialEnabled)
                    {
                        if (guiMgr.IsMaidAppearanceAll && !MyHelper.CheckNull(maidMgr.FaicalDic))
                        {
                            foreach (var maid in maids)
                            {
                                var slotNo = maidMgr.GetActiveSlotNo(maid);
                                if (maidMgr.FaicalDic.ContainsKey(slotNo))
                                {
                                    maidMgr.SetMorphValue(maid, maidMgr.FaicalDic[slotNo].facialMorphDic);
                                }
                            }
                        }
                        else
                        {
                            var maid = maids[maidMgr.GuiMaidIndex];
                            var slotNo = maidMgr.GetActiveSlotNo(maid);
                            if (maidMgr.FaicalDic.ContainsKey(slotNo))
                            {
                                maidMgr.SetMorphValue(maid, maidMgr.FaicalDic[slotNo].facialMorphDic);
                            }
                        }
                    }
                    else if ((isFreeDance || isDance) && !MyHelper.CheckNull(maidMgr.DanceFaicalDic))
                    {
                        var dic = maidMgr.DanceFaicalDic.Where(d => d.Value == MyConst.FACE_BLEND_VALUE).ToDictionary(x => x.Key, x => x.Value);
                        if (!MyHelper.CheckNull(dic))
                        {
                            if (!guiMgr.IsMaidAll)
                            {
                                maidMgr.SetMorphValue(maids[maidMgr.GuiMaidIndex], dic);
                            }
                            else
                            {
                                foreach (var maid in maids)
                                {
                                    maidMgr.SetMorphValue(maid, dic);
                                }
                            }
                        }
                    }

                    if (!guiMgr.IsChangeDressOff && (isDance || isFreeDance))
                    {
                        if (dressMgr.IsUndressRandomOn || !MyHelper.CheckNull(dressMgr.DanceUndressData))
                        {
                            var bgmTime = GetBgmTime();
                            if (dressMgr.IsUndressRandomOn)
                            {
                                dressMgr.UnderessDanceMaidRandom(bgmTime, maidMgr);
                            }
                            else
                            {
                                dressMgr.UnderessDanceMaidAuto(bgmTime, maidMgr);
                            }
                        }
                        if (dressMgr.IsUndressRandomBlushOn)
                        {
                            dressMgr.SetUndressFaicialOption(maidMgr);
                        }
                    }
                }

                if (isCamera && !isCameraStoped && freeMotion.isMotionOn)
                {
                    freeMotion.cameraMgr.ZoomSlider = cameraMgr.ZoomSlider;
                    freeMotion.cameraMgr.TransformMotionCamera(freeMotion, cameraTest.deltaTime, adjustmentPosition, false);
                    cameraTest.deltaTime += Time.deltaTime;
                    if (cameraTest.edTime != 0 && cameraTest.edTime > cameraTest.stTime && cameraTest.deltaTime >= cameraTest.edTime)
                    {
                        cameraTest.deltaTime = cameraTest.stTime;
                        freeMotion.cameraMgr.Initialize();
                        freeMotion.cameraMgr.IncrementIndex(freeMotion.motionData, cameraTest.stTime);
                    }
                }
                else if (isDance && isDanceCameraOn)
                {
                    if (MyHelper.IsVR() != cameraMotion.isVROn)
                    {
                        cameraMotion.camera = MyHelper.GetCameraMain();
                        cameraMotion.isVROn = true;
                    }
                    cameraMotion.cameraMgr.ZoomSlider = cameraMgr.ZoomSlider;
                    cameraMotion.cameraMgr.TransformMotionCamera(cameraMotion, GetBgmTime(), adjustmentPosition, false);
                }
                else if (isFreeDance && !isFreeStoped && isMaids)
                {
                    if (!MyHelper.CheckNull(danceMgr.DanceScreenData) && !guiMgr.IsFreeMotionOff &&
                       (maidLookAt.isMotionOn ||
                        maidLookAt.lookAtIndex != (int)LookAtCameraType.Horizon &&
                        maidLookAt.lookAtIndex != (int)LookAtCameraType.Vertical &&
                        maidLookAt.lookAtIndex != (int)LookAtCameraType.LockOn))
                    {
                        var screenData = danceMgr.DanceScreenData[MyConst.CAMERA_MAIN];
                        if (cameraMgr.IsAutoCamera)
                        {
                            cameraMgr.TransformAutoCamera(maids);
                        }
                        else if (songMgr.IsSong && screenData.isCustomMotion)
                        {
                            songMgr.ChangeSonCameraData(GetBgmTime());
                            songMgr.SetTimelineCameraTransform(cameraMgr, true, adjustmentPosition);
                            if (myGui.isDanceCameraAdjustOn)
                            {
                                screenData.adjustPlugin.AdjustCamera(maids, MyHelper.GetCameraMainTransform());
                            }
                        }
                        else
                        {
                            SetScreenCameraMotion(maids);
                        }
                    }
                    else if (cameraFree.edTime != 0 && cameraFree.edTime > cameraFree.stTime && GetBgmTime() >= cameraFree.edTime)
                    {
                        SetAnimationAndBgmTime(cameraFree.stTime, isFreeStoped);
                    }
                }
                if (!(isDance && !isDanceStoped || isDance && !isCamera || isCamera && !isCameraStoped || 
                      isFreeDance && (isFreeMotionOn || cameraMgr.IsAutoCamera) && !isFreeStoped) ||
                      isFreeDance && guiMgr.IsFreeMotionOff)
                {
                    if (isFreeStoped && (isFreeMotionOn || cameraMgr.IsAutoCamera) || isSwitcherOn || tlWindowMgr.IsEnabled && tlPlaySet.isEnabledCamera)
                    {
                        cameraMgr.SetMainCameraTransform(cameraMgr.CurrentPosition, cameraMgr.CurrentRotation);
                    }
                    if (isWasdOn || tlWindowMgr.IsEnabled && tlPlaySet.isEnabledCamera)
                    {
                        var m = new MoveManager(moveSpeed, myKey);
                        var pos = cameraMgr.CurrentPosition;
                        var rot = cameraMgr.CurrentRotation;
                        m.MoveMouse(ref pos, ref rot);
                        m.MoveKey(ref pos);
                        cameraMgr.SetMainCameraTransform(pos, rot);
                    }
                }
                if (!isSwitcherOn)
                {
                    cameraMgr.SetMainCameraCurrentTransform();
                }
                if (lookAtMgrDiv != null)
                {
                    SetLookAtCamera(lookAtMgrDiv);
                }
                else if (lookAtMgrSub != null)
                {
                    SetLookAtCamera(lookAtMgrSub);
                }
                else if (lookAtMgrLock != null)
                {
                    SetLookAtCamera(lookAtMgrLock);
                }
                if (stageMgr != null && !MyHelper.CheckNull(stageMgr.StageObjectData))
                {
                    stageMgr.SetLookAtScreen(lookAtSet, maidMgr);
                }

                if (bgMgr.IsMaidMask())
                {
                    if (isMaids)
                    {
                        bgMgr.MoveMaidMask(maids, maidMgr, windowMgr.GetScreenSize());
                    }
                }
                if (isMaids && tlWindowMgr.IsEnabled && !captureMgr.IsAnimationCapture && !captureMgr.IsMotionCapture)
                {
                    if (tlPlaySet.isPlay)
                    {
                        if (!tlPlaySet.isPause)
                        {
                            tlWindowMgr.SetPlayTime(ref tlPlaySet);
                            foreach (var maid in maids)
                            {
                                var slotNo = maidMgr.GetActiveSlotNo(maid);
                                if (tlPlaySet.isMorphPlay)
                                {
                                    morphMgr.SetPlayingMorph(maid, slotNo, false);
                                    tlPlaySet.isMorphPlay = false;
                                }
                                else if (tlPlaySet.isPlay)
                                {
                                    if (tlPlaySet.isOfficialDance)
                                    {
                                        var frame = MyHelper.ConvertFrame(tlPlaySet.allPlayTime);
                                        faceMgr.UpdateFrameFace(slotNo, maid, frame, true);
                                    }
                                    else
                                    {
                                        morphMgr.UpdatePlayMorph(maid, slotNo, tlPlaySet);
                                    }
                                }
                                else
                                {
                                    EndTimeLinePlay1st(maid, slotNo);
                                }
                            }
                            if (tlPlaySet.isEnabledCamera)
                            {
                                if (tlPlaySet.isPlay)
                                {
                                    mCameraMgr.UpdatePlayCamera(tlPlaySet, false);
                                    tlPlaySet.isUpdateCamera = true;
                                }
                                else
                                {
                                    EndTimeLinePlay2nd();
                                }
                            }
                        }
                    }
                    else
                    {
                        if (tlPlaySet.isOfficialDance)
                        {
                            var frame = tlWindowMgr.TimeLineTypeIndex == (int)MotionTimeLineType.Camera ? mCameraMgr.SelectedFrame : faceMgr.SelectedFrame;
                            UpdateSelectedFaceFrame(frame, true);
                        }
                        else
                        {
                            foreach (var maid in maids)
                            {
                                var slotNo = maidMgr.GetActiveSlotNo(maid);
                                if (maid.boFaceAnime)
                                {
                                    morphMgr.UpdateOfficialFaceData(maid, slotNo, morphMgr.SelectedFrame);
                                }
                                else
                                {
                                    morphMgr.UpdateFrameMorph(maid, slotNo, false);
                                }
                            }
                        }
                    }

                    if (tlPlaySet.isEnabledCamera && tlPlaySet.isUpdateCamera)
                    {
                        var position = Vector3.zero;
                        var rotation = Vector3.zero;
                        var viewAngle = 0f;
                        mCameraMgr.GetSelectedFrameTransform(ref position, ref rotation, ref viewAngle);
                        cameraMgr.SetTimelineCameraTransform(position, rotation, tlPlaySet.isViewAngle, viewAngle);
                        tlPlaySet.isUpdateCamera = false;
                    }

                }

                if (isDance && isExportOn)
                {
                    var bgmTime = GetBgmTime();
                    if (0 < bgmTime)
                    {
                        danceExport.GetDanceMaidInformation(bgmTime, maids, maidMgr);
                        danceExport.GetDanceCameraInformation(bgmTime, cameraMgr.CurrentPosition, cameraMgr.CurrentRotation, cameraMgr.GetFieldOfView());
                    }
                }

                if (dressMgr.IsBind && isMaids)
                {
                    foreach(var maid in maids)
                    {
                        var slotNo = maidMgr.GetActiveSlotNo(maid);
                        dressMgr.SetBindData(maid, slotNo, true);
                    }
                }
                stageMgr.ChangeCyalumeColor();
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// 初期化処理
        /// </summary>
        private void InitializeVariant(bool isDance)
        {
            try
            {
                danceExport = null;
                bgMgr.BgColor = MyHelper.SetColorBlack();
                adjustmentPosition = Vector3.zero;
                bgMgr.BgPosition = Vector3.zero;
                bgMgr.BgRotation = Vector3.zero;
                mainLightColor = MyHelper.SetColorWhite();
                maidTransformDic = new Dictionary<int, Transform>();

                this.isDance = false;
                isDanceStoped = false;
                isCamera = false;
                isCameraStoped = false;
                isFreeDance = false;
                isFreeStoped = false;
                isFreeMotionOn = false;
                isFreeComboOn = false;
                isCameraComboOn = false;
                isSwitcherOn = false;
                dressMgr.IsFreeDance = false;
                dressMgr.IsBind = false;
                dressMgr.ClearBindSlotData();
                guiMgr.AppearanceIndex = 0;
                maidMgr.FaicalDic = new Dictionary<int, MaidFacialSet>();
                maidMgr.SlotDic = new Dictionary<int, MaidSlotSet>();
                captureMgr.IsAnimationCapture = false;
                captureMgr.IsMotionCapture = false;
                cameraMgr.IsCustome = false;
                tlWindowMgr.IsEnabled = false;
                InitializeTimeLine(false);

                var syncSet = guiMgr.DanceSyncSet;
                syncSet.isFirstSync = false;
                guiMgr.DanceSyncSet = syncSet;

                dressMgr.UndressDic = new Dictionary<TBody.SlotID, bool>();
                foreach (var key in MyConst.UNDRESS_SLOT.Keys)
                {
                    dressMgr.UndressDic[key] = key >= 0;
                }

                additionalBgmTime = 0f;
                endBgmTime = 0f;

                freeSliderCurrent = 0f;
                freeSliderMax = 0f;
                presetWaitTime = 0f;

                lightMgr.DestroyAllLight();
                lightMgr.ResetPixelLightCount();
                spotLightIndex = 0;
                pointLightIndex = 0;
                mainLightColor = MyHelper.SetColorWhite();
                isMainLightOff = false;
                isSubLightOn = false;

                extraMgr.RemoveEnemaAll();
                bgMgr.DestoryMaidMask(true);
                stageMgr.DestroyAllSatgeObjedt();
                stageMgr.DeleteCyalumeData();
                stageObjectIndex = 0;
                boneMgr.Initialize(false);
                morphMgr.Initialize(true);
                faceMgr.Initialize(false);
                if (maidLookAt.lookAtIndex != (int)LookAtCameraType.Off)
                {
                    maidLookAt.lookAtIndex = (int)LookAtCameraType.Off;
                    ReleaseLookAt();
                }

                if (isDance)
                {
                    songMgr.IsSong = false;
                    maidMgr.IsMultipleMaids = false;
                    this.isDance = true;
                    if (isDanceCameraOn)
                    {
                        cameraMotion = new DanceCameraMotionSet();
                        cameraMotion.camera = MyHelper.GetCameraMain();
                        cameraMotion.motionName = cameraList[cameraListIndex];
                        cameraMotion.subFolder = MyConst.FOLDER_CAMERA;
                        cameraMotion.isCustomMotion = isDanceCameraCustom;
                        cameraMotion = ReadMotionData(cameraMotion);
                        if (!MyHelper.CheckNull(cameraMotion.motionData))
                        {
                            cameraMotion.isMotionOn = true;
                            cameraMotion.cameraMgr = new CameraManager();
                        }
                        else
                        {
                            isDanceCameraOn = false;
                        }
                    }
                    if (isExportOn)
                    {
                        danceExport = new DanceListExporter(cameraDelta);
                        var maids = maidMgr.GetActiveMaids();
                        if (MyHelper.CheckNull(maids))
                        {
                            foreach (var maid in maids)
                            {
                                maidMgr.RemoveAnimationClip(maid);
                            }
                        }
                    }
                    if (myGui.isGuiAutoOff)
                    {
                        myGui.isGuiOn = false;
                        tlWindowMgr.IsGuiOn = false;
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        #region  TimeLineWindowFunction

        /// <summary>
        /// GUIタイムラインウィンドウ処理コントロラー
        /// GUI 타임 라인 창 처리 컨트롤러
        /// </summary>
        public void TimeLineWindowFunction(int winId)
        {
            try
            {
                var maids = maidMgr.GetActiveMaids();
                if (MyHelper.CheckNull(maids)) return;
                var maid = maids[maidMgr.GuiMaidIndex];
                var slotNo = maidMgr.GetActiveSlotNo(maid);
                var isEnabledCamera = tlPlaySet.isEnabledCamera;
                var isViewAngle = tlPlaySet.isViewAngle;

                GUI.DragWindow(MyConst.MOTION_WINDOW_DRAG_RECT);
                tlWindowMgr.SetTitleArea();
                var index = tlWindowMgr.TimeLineTypeIndex;
                tlWindowMgr.SetTopeArea(tlPlaySet.isPlay, tlPlaySet.isOfficialDance, maidMgr.GetMaidFullName(maid), ref tlPlaySet.isWrite);

                if (tlWindowMgr.IsEnabled)
                {
                    foreach (var m in maids)
                    {
                        if (!tlPlaySet.isOfficialDance)
                        {
                            maidMgr.StopAnimation(m);
                            maidMgr.SetEyeToCamera(m, Maid.EyeMoveType.無視する);
                        }
                        if (m.body0.Face.morph.EyeMabataki != 0f)
                        {
                            maidMgr.SetMabatakiOff(m);
                        }
                    }

                    guiMgr.IsFacialEnabled = false;
                    if (!boneMgr.ContainsSlotNo(slotNo))
                    {
                        boneMgr.SetDefaultBone(maid, slotNo);
                    }
                    if (!morphMgr.ContainsSlotNo(slotNo))
                    {
                        morphMgr.SetDefaultMorph(slotNo);
                    }
                    if (!faceMgr.ContainsSlotNo(slotNo))
                    {
                        faceMgr.SetDefaultFace(slotNo);
                    }
                    if (!mCameraMgr.ExistsKeyFrame(MyConst.CAMERA_MAIN))
                    {
                        mCameraMgr.SetDefaultCamera();
                        tlPlaySet.isUpdateCamera = true;
                    }
                    
                    switch (tlWindowMgr.TimeLineTypeIndex)
                    {
                        case (int)MotionTimeLineType.ReadAndPlay:
                            if (tlPlaySet.isOfficialDance)
                            {
                                if (songMgr.IsSong || MyHelper.CheckNull(danceList))
                                {
                                    songMgr.IsSong = false;
                                    GetDanceList((int)DanceListType.Title);
                                }
                                TimeLineWindowFunctionReadAndPlayOfficial(maid, slotNo, maids);
                            }
                            else
                            {
                                TimeLineWindowFunctionReadAndPlayCustom(maid, slotNo, maids);
                            }
                            break;
                        case (int)MotionTimeLineType.BoneBody:
                        case (int)MotionTimeLineType.BoneFinger:
                            if (!tlPlaySet.isOfficialDance)
                            {
                                TimeLineWindowFunctionBone(slotNo);
                            }
                            break;
                        case (int)MotionTimeLineType.Morph:
                            if (tlPlaySet.isOfficialDance)
                            {
                                TimeLineWindowFunctionFace(maid, slotNo);
                            }
                            else
                            {
                                TimeLineWindowFunctionMorph(slotNo);
                            }
                            break;
                        case (int)MotionTimeLineType.Camera:
                            TimeLineWindowFunctionCamera();
                            break;
                    }
                }
                else
                {
                    foreach(var m in maids)
                    {
                        m.boMabataki = true;
                    }
                }
                if((!tlPlaySet.isEnabledCamera || !tlPlaySet.isViewAngle) && 
                   (tlPlaySet.isEnabledCamera != isEnabledCamera || tlPlaySet.isViewAngle != isViewAngle) &&
                    !cameraMgr.IsZoom)
                {
                    cameraMgr.ZoomCamera(MyConst.ZOOM_DEFAULT);
                }

            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        private void TimeLineWindowFunctionBone(int slotNo)
        {
            var frame = boneMgr.SelectedFrame;
            var copiedFrame = boneMgr.CopiedFrame;
            var isExsits = boneMgr.ExistsKeyFrame(slotNo);
            var procType = TimeLineFrameProcType.Non;
            var selectType = TimeLineFrameSelectType.Non;
            var startFrame = boneMgr.StartKeyFrame;
            var maxFrame = boneMgr.MaxKeyFrame;
            tlWindowMgr.SetFrameAreaSelecter(startFrame, ref frame, ref procType, ref selectType);
            tlWindowMgr.SetFrameAreaRange(ref startFrame, ref maxFrame);
            tlWindowMgr.SetFrameAreaOperation(isExsits, frame, ref copiedFrame, ref procType);
            boneMgr.StartKeyFrame = startFrame;
            boneMgr.MaxKeyFrame = maxFrame;

            switch (procType)
            {
                case TimeLineFrameProcType.Move:
                    frame = boneMgr.SetTimelineSelectedKeyFrame(slotNo, selectType);
                    break;
                case TimeLineFrameProcType.Copy:
                    boneMgr.CopySelectedFrame(slotNo, copiedFrame);
                    break;

                case TimeLineFrameProcType.Delete:
                    boneMgr.UpdateIndex = (int)MotionUpdateType.BoneAddition;
                    boneMgr.DeleteSelectedFrame(slotNo);
                    break;
            }
            
            var keyFrame = boneMgr.GetKeyFrame(slotNo);
            var motionKeyValue = boneMgr.GetMotionKeyValue(slotNo, keyFrame);
            var selectedName = boneMgr.SelectedName;

            tlWindowMgr.SetTimeLineAreaPartsBone();
            tlWindowMgr.SetTimeLineAreaFrame(keyFrame);
            if (tlWindowMgr.SetTimeLineAreaMain(keyFrame, motionKeyValue, tlWindowMgr.GetBoneGroup(), ref frame, ref selectedName))
            {
                boneMgr.UpdateIndex = (int)MotionUpdateType.ValueUpdating;
                guiMgr.MotionProcTypeIndex = (int)MotionProcType.Motion;
            }
            if(boneMgr.SelectedName != selectedName)
            {
                boneMgr.SelectedName = selectedName;
                boneMgr.SetResetValue(slotNo);
            }
            boneMgr.CopiedFrame = copiedFrame;
            boneMgr.SelectedName = selectedName;
            UpdateSelectedFrame(frame);
        }

        private void TimeLineWindowFunctionMorph(int slotNo)
        {
            var frame = morphMgr.SelectedFrame;
            var copiedFrame = morphMgr.CopiedFrame;
            var isExsits = morphMgr.ExistsKeyFrame(slotNo);
            var procType = TimeLineFrameProcType.Non;
            var selectType = TimeLineFrameSelectType.Non;
            var startFrame = morphMgr.StartKeyFrame;
            var maxFrame = morphMgr.MaxKeyFrame;
            tlWindowMgr.SetFrameAreaSelecter(startFrame, ref frame, ref procType, ref selectType);
            tlWindowMgr.SetFrameAreaRange(ref startFrame, ref maxFrame);
            tlWindowMgr.SetFrameAreaOperation(isExsits, frame, ref copiedFrame, ref procType);
            morphMgr.StartKeyFrame = startFrame;
            morphMgr.MaxKeyFrame = maxFrame;

            switch (procType)
            {
                case TimeLineFrameProcType.Move:
                    frame = morphMgr.SetTimelineSelectedKeyFrame(slotNo, selectType);
                    break;
                case TimeLineFrameProcType.Copy:
                    morphMgr.CopySelectedFrame(slotNo, copiedFrame);
                    break;

                case TimeLineFrameProcType.Delete:
                    morphMgr.DeleteSelectedFrame(slotNo);
                    break;
            }
            
            var keyFrame = morphMgr.GetKeyFrame(slotNo);
            var motionKeyValue = morphMgr.GetMotionKeyValue(slotNo, keyFrame);
            var selectedName = morphMgr.SelectedName;

            tlWindowMgr.SetTimeLineAreaPartsMorph();
            tlWindowMgr.SetTimeLineAreaFrame(keyFrame);
            if (tlWindowMgr.SetTimeLineAreaMain(keyFrame, motionKeyValue, MyConst.ALL_FACIAL_MORPH, ref frame, ref selectedName))
            {
                morphMgr.UpdateIndex = (int)MotionUpdateType.ValueUpdating;
                guiMgr.MotionProcTypeIndex = (int)MotionProcType.Motion;
            }
            morphMgr.CopiedFrame = copiedFrame;
            morphMgr.SelectedName = selectedName;
            UpdateSelectedFrame(frame);
        }

        private void TimeLineWindowFunctionFace(Maid maid, int slotNo)
        {
            var frame = faceMgr.SelectedFrame;
            var copiedFrame = faceMgr.CopiedFrame;
            var isExsits = faceMgr.ExistsKeyFrame(slotNo);
            var procType = TimeLineFrameProcType.Non;
            var selectType = TimeLineFrameSelectType.Non;
            var startFrame = faceMgr.StartKeyFrame;
            var maxFrame = faceMgr.MaxKeyFrame;
            tlWindowMgr.SetFrameAreaSelecter(startFrame, ref frame, ref procType, ref selectType);
            tlWindowMgr.SetFrameAreaRange(ref startFrame, ref maxFrame);
            tlWindowMgr.SetFrameAreaOperation(isExsits, frame, ref copiedFrame, ref procType);
            faceMgr.StartKeyFrame = startFrame;
            faceMgr.MaxKeyFrame = maxFrame;

            switch (procType)
            {
                case TimeLineFrameProcType.Move:
                    frame = faceMgr.SetTimelineSelectedKeyFrame(slotNo, selectType);
                    break;
                case TimeLineFrameProcType.Copy:
                    faceMgr.CopySelectedFrame(copiedFrame, slotNo);
                    break;

                case TimeLineFrameProcType.Delete:
                    faceMgr.DeleteSelectedFrame(slotNo);
                    break;
            }

            var keyFrame = faceMgr.GetFaceKeyFrame(slotNo);
            tlWindowMgr.SetTimeLineAreaPartsOne("表情");
            tlWindowMgr.SetTimeLineAreaFrame(keyFrame);
            tlWindowMgr.SetTimeLineAreaMainOneLine(keyFrame, ref frame);

            faceMgr.SelectedFrame = frame;
            isExsits = faceMgr.ExistsKeyFrame(slotNo);
            if (tlWindowMgr.SetFaceOperationTop(isExsits, ref tlPlaySet))
            {
                faceMgr.CreateNewFrame(slotNo, frame);
            }
            if (isExsits)
            {
                var face = faceMgr.GetFaceName(slotNo);
                var blend = faceMgr.GetFaceOption(slotNo);
                var eyeMoveType = faceMgr.GetEyeMoveType(slotNo);
                switch (tlPlaySet.faceTypeIndex)
                {
                    case (int)TimeLineFaceType.Official:
                        var index = faceMgr.SelectedFacialIndex;
                        tlWindowMgr.SetFaceOperationOfficial(ref face, ref index);
                        faceMgr.SelectedFacialIndex = index;
                        break;
                    case (int)TimeLineFaceType.Option:
                        tlWindowMgr.SetFaceOperationOption(ref blend, ref eyeMoveType, maid);
                        break;
                }
                if (face != faceMgr.GetFaceName(slotNo) || 
                    blend != faceMgr.GetFaceOption(slotNo) ||
                    eyeMoveType != faceMgr.GetEyeMoveType(slotNo))
                {
                    faceMgr.UpdateFaceData(slotNo, face, blend, frame, eyeMoveType);
                }
            }
            faceMgr.CopiedFrame = copiedFrame;
            UpdateSelectedFrame(frame);
        }

        private void TimeLineWindowFunctionCamera()
        {
            var frame = mCameraMgr.SelectedFrame;
            var copiedFrame = mCameraMgr.CopiedFrame;
            var isExsits = mCameraMgr.ExistsKeyFrame(frame);
            var procType = TimeLineFrameProcType.Non;
            var selectType = TimeLineFrameSelectType.Non;
            var startFrame = mCameraMgr.StartKeyFrame;
            var maxFrame = mCameraMgr.MaxKeyFrame;
            tlWindowMgr.SetFrameAreaSelecter(startFrame, ref frame, ref procType, ref selectType);
            tlWindowMgr.SetFrameAreaRange(ref startFrame, ref maxFrame);
            tlWindowMgr.SetFrameAreaOperation(isExsits, frame, ref copiedFrame, ref procType);
            mCameraMgr.StartKeyFrame = startFrame;
            mCameraMgr.MaxKeyFrame = maxFrame;

            switch (procType)
            {
                case TimeLineFrameProcType.Move:
                    frame = mCameraMgr.SetTimelineSelectedKeyFrame(selectType);
                    break;
                case TimeLineFrameProcType.Copy:
                    mCameraMgr.CopySelectedFrame(copiedFrame);
                    break;
                case TimeLineFrameProcType.Delete:
                    mCameraMgr.DeleteSelectedFrame();
                    isExsits = false;
                    break;
            }

            var keyFrame = mCameraMgr.GetCameraKeyFrame();
            tlWindowMgr.SetTimeLineAreaPartsOne("カメラ");
            tlWindowMgr.SetTimeLineAreaFrame(keyFrame);
            tlWindowMgr.SetTimeLineAreaMainOneLine(keyFrame, ref frame);

            if (tlWindowMgr.SetCameraOperationTop(isExsits, ref tlPlaySet))
            {
                cameraMgr.SetMainCameraCurrentTransform();
                mCameraMgr.CreateNewFrame(cameraMgr.CurrentPosition, cameraMgr.CurrentRotation);
            }

            if (tlPlaySet.isEnabledCamera)
            {
                if (isExsits)
                {
                    var camera = mCameraMgr.GetCameraTimeLineData();
                    var resetPos = cameraMgr.GetPositionResetValue();
                    var resetRot = cameraMgr.GetRotationResetValue();
                    tlWindowMgr.SetCameraOperationTop(ref camera);
                    tlWindowMgr.SetCameraOperationTransform(resetPos, resetRot, ref camera);
                    if (0 < camera.frame)
                    {
                        SetMaidAreaMotionEasing(ref camera.easing);
                    }
                    if (mCameraMgr.UpdateCameraData(camera))
                    {
                        var pos = mCameraMgr.AdjustedCameraosition(camera.position, camera.rotation, camera.distance);
                        cameraMgr.SetTimelineCameraTransform(pos, camera.rotation, tlPlaySet.isViewAngle, camera.viewAngle);
                    }
                }
                mCameraMgr.CopiedFrame = copiedFrame;
                UpdateSelectedFrame(frame);
            }

        }

        private void TimeLineWindowFunctionReadAndPlayCustom(Maid maid, int slotNo, List<Maid> maids)
        {
            var motionnFile = MyHelper.EndsWith(tlPlaySet.boneFile, MyConst.EXTENSION_CSV);
            var morphFile = MyHelper.EndsWith(tlPlaySet.morphFile, MyConst.EXTENSION_CSV);
            var cameraFile = MyHelper.EndsWith(tlPlaySet.cameraFile, MyConst.EXTENSION_CSV);
            if (!tlPlaySet.isPlay && tlWindowMgr.SetMotionArea(ref tlPlaySet))
            {
                if (tlPlaySet.isWrite)
                {
                    if (tlPlaySet.isAllMaids)
                    {
                        foreach (var m in maids)
                        {
                            var s = maidMgr.GetActiveSlotNo(m);
                            boneMgr.WriteBoneData(s, motionnFile, tlPlaySet.isAllMaids);
                            morphMgr.WriteMorphData(s, morphFile, tlPlaySet.isAllMaids);
                        }
                    }
                    else
                    {
                        boneMgr.WriteBoneData(slotNo, motionnFile, tlPlaySet.isAllMaids);
                        morphMgr.WriteMorphData(slotNo, morphFile, tlPlaySet.isAllMaids);
                    }
                    mCameraMgr.WriteCameraData(cameraFile);
                }
                else
                {
                    if (tlPlaySet.isAllMaids)
                    {
                        foreach (var m in maids)
                        {
                            var s = maidMgr.GetActiveSlotNo(m);
                            boneMgr.ReadBoneData(m, s, motionnFile);
                            morphMgr.ReadMorphData(s, morphFile);
                        }
                    }
                    else
                    {
                        boneMgr.ReadBoneData(maid, slotNo, motionnFile);
                        morphMgr.ReadMorphData(slotNo, morphFile);
                    }
                    mCameraMgr.ReadCameraData(cameraFile, MyConst.FOLDER_TIMELINE);
                    tlPlaySet.isUpdateCamera = true;
                }
            }
            var isPause = tlPlaySet.isPause;
            if (tlWindowMgr.SetPlayArea(ref tlPlaySet))
            {
                tlWindowMgr.ResetPlayTime(ref tlPlaySet);
                foreach (var m in maids)
                {
                    var s = maidMgr.GetActiveSlotNo(m);
                    boneMgr.SetPlayingBone(m, s, false);
                    morphMgr.SetPlayingMorph(m, s, false);
                }
                mCameraMgr.SetPlayingCamera(false);
                if (tlPlaySet.isPlay)
                {
                    if (boneMgr.AudioMgr.LoadAndPlayAudioClip(MyConst.FOLDER_TIMELINE, tlPlaySet.audioFile))
                    {
                        soundMgr.StopBgm(0f);
                        danceVolumeBackup = soundMgr.GetVolumeDance();
                        boneMgr.AudioMgr.PlayAudioClip();
                        boneMgr.AudioMgr.SetAudioClipTime(tlPlaySet.fromFrame * MyConst.FRAME_CONVERSION_RATIO);
                        boneMgr.AudioMgr.SetVolumeDance(danceVolumeLegacy);
                    }
                }
                else
                {
                    foreach (var m in maids)
                    {
                        var s = maidMgr.GetActiveSlotNo(m);
                        EndTimeLinePlay1st(m, s);
                    }
                    EndTimeLinePlay2nd();
                }

            }
            if (isPause != tlPlaySet.isPause)
            {
                if (tlPlaySet.isPause)
                {
                    boneMgr.AudioMgr.PauseAudioClip();
                }
                else
                {
                    boneMgr.AudioMgr.UnPauseAudioClip();
                }
            }

            if (tlPlaySet.isPlay) return;
            tlWindowMgr.SetPlayAreaConvertOption(ref tlPlaySet);

            switch (tlPlaySet.optionIndex)
            {
                case (int)TimeLineOptionType.ConvertData:
                    ConvertData(maid, slotNo);
                    break;
                case (int)TimeLineOptionType.SelectBone:
                    SelectedBone();
                    break;
            }
        }

        private void ConvertData(Maid maid, int slotNo)
        {
            if (tlWindowMgr.SetPlayAreaConvertVMDData(ref tlPlaySet))
            {
                var vmdFile = tlPlaySet.vmdFile;
                if (!string.IsNullOrEmpty(vmdFile))
                {
                    if (!vmdFile.EndsWith(MyConst.EXTENSION_VMD))
                    {
                        vmdFile += MyConst.EXTENSION_VMD;
                    }
                    switch (tlPlaySet.vmdTypeIndex)
                    {
                        case (int)TimeLineVMDFileType.Camera:
                            new VMDManager().ConvertCameraData(vmdFile);
                            break;
                        case (int)TimeLineVMDFileType.Morph:
                            new VMDManager().ConvertMorphData(vmdFile, false);
                            break;
                        case (int)TimeLineVMDFileType.MorphNoMouth:
                            new VMDManager().ConvertMorphData(vmdFile, true);
                            break;
                        case (int)TimeLineVMDFileType.Finger:
                            new VMDManager().ConvertVMDFingerBoneData(vmdFile);
                            break;
                    }
                }
            }
            if (tlWindowMgr.SetPlayAreaAjustFileFrame(ref tlPlaySet) &&
                !string.IsNullOrEmpty(tlPlaySet.adjustedFile))
            {
                var fileName = tlPlaySet.adjustedFile;
                if (!fileName.EndsWith(MyConst.EXTENSION_CSV))
                {
                    fileName += MyConst.EXTENSION_CSV;
                }
                var writer = new FileWriter();
                switch (tlPlaySet.frameAdjustmentIndex)
                {
                    case (int)FrameAjustmentType.FrameAjustment:
                        if (tlPlaySet.adjustedFrame != 0)
                        {
                            writer.ReWriteTimelineMotionFile(fileName, tlPlaySet.adjustedFrame);
                        }
                        break;
                    case (int)FrameAjustmentType.BoneReduction:
                        writer.ReWriteTimelineBoneFile(fileName);
                        break;
                    case (int)FrameAjustmentType.DeleteFinger:
                        writer.ReWriteTimelineFingerFile(fileName);
                        break;
                    case (int)FrameAjustmentType.DefaultToe:
                        writer.ReWriteTimelineToeFile(fileName);
                        break;
                }
            }
            if (tlWindowMgr.SetPlayAreaCreateAnimation(ref tlPlaySet))
            {
                if (!string.IsNullOrEmpty(tlPlaySet.animeFile))
                {
                    boneMgr.CreateAnimationFile(tlPlaySet.isMaidBone ? maid : null, slotNo, tlPlaySet.animeFile);
                }
            }
            if (tlWindowMgr.SetPlayAreaInitializeMotion())
            {
                InitializeMotion(maid, slotNo, tlPlaySet.isOfficialDance);
            }
        }

        private void TimeLineWindowFunctionReadAndPlayOfficial(Maid maid, int slotNo, List<Maid> maids)
        {
            var maidMgr = new MaidManager();
            var bgmName = "";
            if (!MyHelper.CheckNull(tlPlaySet.danceData))
            {
                var data = tlPlaySet.danceData[MyConst.DANCE_FIRST_INDEX];
                maidMgr.IsCM3D2Dance = data.type == MyConst.DANCE_TYPE_CM3D2;
                bgmName = data.bgmName;
            }
            var morphFile = MyHelper.EndsWith(tlPlaySet.morphFile, MyConst.EXTENSION_CSV);
            var cameraFile = MyHelper.EndsWith(tlPlaySet.cameraFile, MyConst.EXTENSION_CSV);
            if (!tlPlaySet.isPlay && tlWindowMgr.SetMotionArea(ref tlPlaySet))
            {
                if (tlPlaySet.isWrite)
                {
                    faceMgr.WriteCameraData(slotNo, morphFile);
                    mCameraMgr.WriteCameraData(cameraFile);
                }
                else
                {
                    foreach (var m in maids)
                    {
                        var s = maidMgr.GetActiveSlotNo(m);
                        var data = tlPlaySet.danceData.FirstOrDefault(d => d.activeSlotNo == s);
                        if (!string.IsNullOrEmpty(data.animation))
                        {
                            maidMgr.CrossFadeAnimation(m, data.animation, false, maidMgr.IsCM3D2Dance, MyConst.ANIMATION_NO_FADE_TIME);
                            maidMgr.SetAnimationTime(m, tlPlaySet.allPlayTime, true);
                        }
                        m.StartKuchipakuPattern(0f, data.mouth, true);
                    }
                    faceMgr.ReadFaceData(slotNo, morphFile, maid);
                    mCameraMgr.ReadCameraData(cameraFile, MyConst.FOLDER_TIMELINE);
                    tlPlaySet.isUpdateCamera = true;
                }
            }
            var isPause = tlPlaySet.isPause;
            if (tlWindowMgr.SetPlayArea(ref tlPlaySet))
            {
                tlWindowMgr.ResetPlayTime(ref tlPlaySet);
                foreach (var m in maids)
                {
                    maidMgr.SetAnimationTime(m, tlPlaySet.allPlayTime, false);
                }
                mCameraMgr.SetPlayingCamera(false);
                if (tlPlaySet.isPlay)
                {
                    var isExist = false;
                    if (maidMgr.IsCM3D2Dance)
                    {
                        isExist = MyHelper.IsExistingOfficialFileOld(bgmName);
                    }
                    else
                    {
                        isExist = MyHelper.IsExistingOfficialFile(bgmName);
                    }
                    if (isExist)
                    {
                        danceVolumeBackup = soundMgr.GetVolumeDance();
                        soundMgr.StopBgm(0f);
                        var bgmTime = tlPlaySet.fromFrame * MyConst.FRAME_CONVERSION_RATIO;
                        if (maidMgr.IsCM3D2Dance)
                        {
                            soundMgr.PlayBGMCM3D2Dance(bgmName);
                            soundMgr.SetBgmTime(bgmTime);
                            soundMgr.SetVolumeDance(danceVolumeLegacy, true);
                        }
                        else
                        {
                            soundMgr.PlayDanceBGM(bgmName);
                            soundMgr.SetBgmTime(bgmTime);
                        }
                    }
                }
                else
                {
                    foreach (var m in maids)
                    {
                        var s = maidMgr.GetActiveSlotNo(m);
                        EndTimeLinePlay1st(m, s);
                    }
                    EndTimeLinePlay2nd();
                }

            }
            if (isPause != tlPlaySet.isPause)
            {
                if (tlPlaySet.isPause)
                {
                    soundMgr.PauseBgm();
                }
                else
                {
                    soundMgr.UnPauseBgm();
                }
                foreach (var m in maids)
                {
                    maidMgr.SetAnimationTime(m, tlPlaySet.allPlayTime, tlPlaySet.isPause);
                }
            }

            if (!tlPlaySet.isPlay)
            {
                if(tlWindowMgr.SetPlayAreaSelectedOfficialDance(ref tlPlaySet, danceList))
                {
                    faceMgr.SelectedFrame = 0;
                    mCameraMgr.SelectedFrame = 0;
                    foreach (var m in maids)
                    {
                        var s = maidMgr.GetActiveSlotNo(m);
                        var data = tlPlaySet.danceData.FirstOrDefault(d => d.activeSlotNo == s);
                        if (!string.IsNullOrEmpty(data.animation))
                        {
                            maidMgr.CrossFadeAnimation(m, data.animation, false, maidMgr.IsCM3D2Dance, MyConst.ANIMATION_NO_FADE_TIME);
                            maidMgr.SetAnimationTime(m, tlPlaySet.allPlayTime, true);
                        }
                        faceMgr.SetFaceData(data.face, s, m);
                        m.StartKuchipakuPattern(0f, data.mouth, true);
                        m.SetPos(data.transform.stPos);
                        m.SetRot(data.transform.stRot);
                    }
                    var c = tlPlaySet.danceCameraData[MyConst.CAMERA_MAIN];
                    if (c.isCustomMotion)
                    {
                        mCameraMgr.ReadCameraData(c.motionName, MyConst.FOLDER_MOTION);
                    }
                    else
                    {
                        mCameraMgr.ReadOfficialDanceCameraData(c.motionName);
                    }
                    tlPlaySet.isUpdateCamera = true;
                }
                if (tlWindowMgr.SetPlayAreaInitializeMotion())
                {
                    InitializeMotion(maid, slotNo, tlPlaySet.isOfficialDance);
                }
            }
        }

        private void SelectedBone()
        {
            if (tlWindowMgr.SetSelectedBone(ref tlPlaySet))
            {
                var name = tlPlaySet.boneExportFile;
                if (!name.EndsWith(MyConst.EXTENSION_CSV))
                {
                    name += MyConst.EXTENSION_CSV;
                }
                new FileWriter().ReWriteTimelineSelectedBoneFile(name, captureMgr.SelectedBoneDic);
            }
            SetMaidAreaCaptureBoneGroup(false);
            SetMaidAreaCaptureBoneSelect();
        }

        private void InitializeMotion(Maid maid, int slotNo, bool isOfficialDance)
        {
            if (isOfficialDance)
            {
                maidMgr.ResetAnimation(maid, MyConst.ANIMATION_FADE_TIME);
            }
            else
            {
                boneMgr.SetDefaultBone(maid, slotNo);
            }
            morphMgr.SetDefaultMorph(slotNo);
            mCameraMgr.SetDefaultCamera();
            cameraMgr.ResetMainCamera();
            if (!cameraMgr.IsZoom)
            {
                cameraMgr.ZoomCamera(MyConst.ZOOM_DEFAULT);
            }
            tlPlaySet.isUpdateCamera = true;
        }

        private void UpdateSelectedFrame(int frame)
        {
            if (!tlPlaySet.isOfficialDance)
            {
                if (boneMgr.SelectedFrame != frame)
                {
                    boneMgr.SelectedFrame = frame;
                    foreach (var maid in maidMgr.GetActiveMaids())
                    {
                        var slotNo = maidMgr.GetActiveSlotNo(maid);
                        boneMgr.UpdateFrameBone(maid, slotNo);
                        boneMgr.SetSelectedItemName(slotNo, frame);
                    }
                }
                if (morphMgr.SelectedFrame != frame)
                {
                    morphMgr.SelectedFrame = frame;
                    foreach (var maid in maidMgr.GetActiveMaids())
                    {
                        var slotNo = maidMgr.GetActiveSlotNo(maid);
                        morphMgr.UpdateFrameMorph(maid, slotNo, true);
                        morphMgr.SetSelectedItemName(slotNo, frame);
                    }
                }
            }
            else
            {
                UpdateSelectedFaceFrame(frame, false);
            }
            if (mCameraMgr.SelectedFrame != frame)
            {
                mCameraMgr.SelectedFrame = frame;
                mCameraMgr.UpdateFrameCamera();
                tlPlaySet.isUpdateCamera = true;
            }
        }

        private void UpdateSelectedFaceFrame(int frame, bool isLastUpdate)
        {
            foreach (var maid in maidMgr.GetActiveMaids())
            {
                var slotNo = maidMgr.GetActiveSlotNo(maid);
                maidMgr.SetAnimationTime(maid, frame * MyConst.FRAME_CONVERSION_RATIO, true);
                faceMgr.UpdateFrameFace(slotNo, maid, frame, isLastUpdate);
            }
        }

        private void EndTimeLinePlay1st(Maid maid, int slotNo)
        {
            if (!tlPlaySet.isOfficialDance)
            {
                boneMgr.SetPlayingBone(maid, slotNo, false);
                morphMgr.SetPlayingMorph(maid, slotNo, false);
            }
            else
            {
                maidMgr.SetAnimationTime(maid, 0f, false);
                maidMgr.UpdateFaceAnime(maid, MyConst.DEFAULT_FACE);
            }
        }

        private void EndTimeLinePlay2nd()
        {
            if (tlPlaySet.isEnabledCamera)
            {
                mCameraMgr.SetPlayingCamera(false);
                var camera = mCameraMgr.GetCameraTimeLineData();
                cameraMgr.SetMainCameraTransform(camera.position, camera.rotation);
            }
            if (!tlPlaySet.isOfficialDance)
            {
                boneMgr.AudioMgr.StopAudioClip();
            }
            else
            {
                soundMgr.StopBgm(1f);
            }
            soundMgr.PlayBGM(soundMgr.GetRandomBgmName());
            soundMgr.SetVolumeDance(danceVolumeBackup, false);
        }

        #endregion

        #region MainWindowFunction
        /// <summary>
        /// GUIウィンドウ処理コントロラー
        /// </summary>
        private void MainWindowFunction(int winId)
        {
            try
            {
                var maids = maidMgr.GetActiveMaids();
                WindowFunctionReset(maids);
                GUI.DragWindow(MyConst.MAIN_WINDOW_DRAG_RECT);
                guiStyle.SetPartsGuiStyle();
                SetTitleArea();
                SetMenuAreat();
                switch (guiMainMenuIndex)
                {
                    case (int)GuiMenu.DanceFree:
                        WindowFunctionDance(maids);
                        break;
                    case (int)GuiMenu.ShortCut:
                        WindowFunctionShortCut();
                        break;
                    case (int)GuiMenu.MaidLayout:
                    case (int)GuiMenu.MaidCollective:
                    case (int)GuiMenu.MaidSlot:
                    case (int)GuiMenu.MaidSwing:
                    case (int)GuiMenu.MaidDress:
                    case (int)GuiMenu.MaidMotion:
                    case (int)GuiMenu.MaidAppearance:
                    case (int)GuiMenu.MaidMove:
                        WindowFunctionMaid(maids);
                        break;
                    case (int)GuiMenu.BgSelect:
                    case (int)GuiMenu.BgParts:
                    case (int)GuiMenu.ForegroundSelect:
                        WindowFunctionBg(maids);
                        break;
                    case (int)GuiMenu.StageObjectSelect:
                        WindowFunctionStageDirectin(maids);
                        break;
                    case (int)GuiMenu.ModelSelect:
                        WindowFunctionModel(maids);
                        break;
                    case (int)GuiMenu.ParticleSelect:
                        WindowFunctionParticle();
                        break;
                    case (int)GuiMenu.StageObjectEach:
                        WindowFunctionEach();
                        break;
                    case (int)GuiMenu.LightSelect:
                        WindowFunctionLight(maids);
                        break;
                    case (int)GuiMenu.CameraLookAt:
                    case (int)GuiMenu.CameraAuto:
                    case (int)GuiMenu.CameraPlay:
                    case (int)GuiMenu.CameraTransform:
                        WindowFunctionCamera(maids);
                        break;
                    case (int)GuiMenu.Bukkake:
                    case (int)GuiMenu.Emission:
                        WindowFunctionExtra(maids);
                        break;
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        private void WindowFunctionReset(List<Maid> maids)
        {
            if (MyHelper.CheckNull(maids))
            {
                if (lookAtMgrDiv != null)
                {
                    for (int i = 0; i < maidLookAt.divisionSet.GetLength(0); i++)
                    {
                        maidLookAt.divisionSet[i].isLookAt = false;
                    }
                    lookAtMgrDiv.DestroyCamera(0, maidLookAt.divisionSet.GetLength(0));
                    lookAtMgrDiv = null;
                }
                if (lookAtMgrSub != null)
                {
                    for (int i = 0; i < maidLookAt.subSet.GetLength(0); i++)
                    {
                        maidLookAt.subSet[i].isLookAt = false;
                    }
                    lookAtMgrSub.DestroyCamera(0, maidLookAt.subSet.GetLength(0));
                    lookAtMgrSub = null;
                }
                if (lookAtMgrLock != null)
                {
                    for (int i = 0; i < maidLookAt.lockSet.GetLength(0); i++)
                    {
                        maidLookAt.lockSet[i].isLookAt = false;
                    }
                    lookAtMgrLock.DestroyCamera(0, maidLookAt.lockSet.GetLength(0));
                    lookAtMgrLock = null;
                }
            }
            if (guiMainMenuIndex != (int)GuiMenu.DanceFree && isFreeComboOn)
            {
                isFreeComboOn = false;
            }
            if (guiMainMenuIndex != (int)GuiMenu.CameraTransform && isSwitcherOn)
            {
                isSwitcherOn = false;
            }
            if (guiMainMenuIndex != (int)GuiMenu.CameraPlay && isCameraComboOn)
            {
                isCameraComboOn = false;
            }
            if (guiMainMenuIndex != (int)GuiMenu.BgParts && !bgMgr.IsBgIntance && bgMgr.IsBgInstanceComboOn)
            {
                bgMgr.IsBgInstanceComboOn = false;
            }
        }

        private void WindowFunctionDance(List<Maid> maids)
        {
            if (isDance)
            {
                SetFreeDanceAreaMessage();
                SetFreeDanceAreaOptionMaidSwing(maids);
                return;
            }

            SetFreeDanceAreaCommboList();
            if (!isFreeComboOn)
            {
                SetFreeDanceAreaDancePlay();
                SetFreeDanceAreaDanceTime();

                if (isGuiMenuDanceInfomation)
                {
                    SetFreeDanceAreaInformation();
                    SetFreeDanceAreaOptionExportList();
                }
                else
                {
                    SetFreeDanceAreaOptionTop();
                    switch (guiMgr.FreeDanceOptionIndex)
                    {
                        case (int)FreeDanceOptionType.Dance:
                            SetFreeDanceAreaOptionDanceMain();
                            SetFreeDanceAreaOptionDanceGroup();
                            SetFreeDanceAreaOptionDanceDirection();
                            SetFreeDanceAreaOptionSubUi();
                            break;
                        case (int)FreeDanceOptionType.Maid:
                            SetFreeDanceAreaOptionMaidMain();
                            SetFreeDanceAreaOptionMaidRandomFace();
                            SetFreeDanceAreaOptionMaidDressGroup();
                            SetFreeDanceAreaOptionMaidSwing(maids);
                            break;
                        case (int)FreeDanceOptionType.Sub:
                            SetFreeDanceAreaOptionSubMain();
                            SetFreeDanceAreaOptionSubUi();
                            break;
                    }
                }
            }
        }

        private void WindowFunctionShortCut()
        {
            SetShortCutArea();
        }

        private void WindowFunctionMaid(List<Maid> maids)
        {
            if (MyHelper.CheckNull(maids))
            {
                SetMenuAreaNoMaid(2);
                //SetMaidAreaChangingBody();
                tlWindowMgr.IsGuiOn = false;
                boneMgr.Initialize(false);
                morphMgr.Initialize(true);
                return;
            }

            var maidIndex = maidMgr.GuiMaidIndex;
            switch (guiMainMenuIndex)
            {
                case (int)GuiMenu.MaidLayout:
                    if (!isDance)
                    {
                        SetMaidAreaLayoutSelect();
                        SetMaidAreaXmlData(maids);
                        SetMaidAreaTransform(maids);
                    }
                    break;

                case (int)GuiMenu.MaidCollective:
                    SetMaidAreaCollectiveTop(maids);
                    SetMaidAreaEyeToCam(maids);
                    SetMaidAreaManualUndress(maids);
                    SetMaidAreaPorori(maids);
                    SetMaidAreaFacialOption(maids[maidIndex], 15, true);
                    SetMaidAreaBreath(maids);
                    break;

                case (int)GuiMenu.MaidSlot:
                    if (!isDance && !isFreeDance)
                    {
                        SetMaidAreaSlotNo(maids);
                    }
                    break;

                case (int)GuiMenu.MaidSwing:
                    SetMaidAreaSwingTop(maids, maidIndex);
                    switch (swingMgr.SwingIndex)
                    {
                        case (int)MaidSwingType.Mune:
                            SetMaidAreaSwingMune(maids, maidIndex);
                            break;

                        case (int)MaidSwingType.Hair:
                            SetMaidAreaSwingHair(maids, maidIndex);
                            break;

                        case (int)MaidSwingType.Skirt:
                            if (maidMgr.IsMultipleMaids)
                            {
                                SetMaidAreaSwingSkirtMultipleMaids();
                            }
                            else
                            {
                                SetMaidAreaSwingSkirt(maids, maidIndex);
                            }
                            break;
                    }
                    break;

                case (int)GuiMenu.MaidDress:
                    if (presetWaitTime == 0f)
                    {
                        SetMaidAreaDressTop(maids, maidIndex);
                        switch (dressMgr.DressTypeIndex)
                        {
                            case (int)MaidDressType.TempDressSelect:
                                SetMaidAreaDressGroup(maids);
                                SetMaidAreaDressList(maids, maidIndex);
                                break;

                            case (int)MaidDressType.TempDress:
                                SetMaidAreaDressTemp(maids, maidIndex);
                                break;

                            case (int)MaidDressType.Preset:
                                SetMaidAreaPresetList(maids, maidIndex);
                                break;
                            case (int)MaidDressType.Porori:
                                SetMaidAreaDressPorori(maids, maidIndex);
                                SetMaidAreaDressPororiList(maids, maidIndex);
                                break;
                            case (int)MaidDressType.Bind:
                                SetMaidAreaDressBind(maids, maidIndex);
                                if (dressMgr.IsBind)
                                {
                                    SetMaidAreaDressBindList(maids, maidIndex);
                                }
                                break;
                        }
                    }
                    break;

                case (int)GuiMenu.MaidMotion:
                    if (!isDance && !isFreeDance)
                    {
                        SetMaidAreaMotionTop(maids);
                        var maid = maids[maidIndex];
                        var slotNo = maidMgr.GetActiveSlotNo(maid);

                        switch (guiMgr.MotionProcTypeIndex)
                        {
                            case (int)MotionProcType.Motion:
                                if (tlWindowMgr.IsEnabled && !captureMgr.IsMotionCapture && !captureMgr.IsMotionCapture &&
                                    (!tlPlaySet.isPlay || tlPlaySet.isPlay && tlPlaySet.isPause))
                                {
                                    switch (tlWindowMgr.TimeLineTypeIndex)
                                    {
                                        case (int)MotionTimeLineType.BoneBody:
                                        case (int)MotionTimeLineType.BoneFinger:
                                            if (boneMgr.ContainsSlotNo(slotNo))
                                            {
                                                SetMaidAreaMotionFrame(maids, false);
                                                boneMgr.ChangeMaidSlotNo(maid, slotNo);
                                                switch (boneMgr.UpdateIndex)
                                                {
                                                    case (int)MotionUpdateType.ValueUpdating:
                                                        if (!MyHelper.CheckNull(boneMgr.ItemDeletionDic) && boneMgr.ExistsKeyFrame(slotNo))
                                                        {
                                                            SetMaidAreaBoneUpdate(maid, slotNo);
                                                        }
                                                        break;
                                                    case (int)MotionUpdateType.BoneAddition:
                                                        if (boneMgr.ExistsKeyFrame(slotNo))
                                                        {
                                                            SetMaidAreaItemSelecter(false);
                                                            SetMaidAreaMotionFrameUpdate(maid, slotNo, false);
                                                        }
                                                        break;
                                                    case (int)MotionUpdateType.NewFrame:
                                                        SetMaidAreaItemSelecter(false);
                                                        SetMaidAreaMotionNewFrame(maid, slotNo, false);
                                                        break;
                                                }
                                            }
                                            break;
                                        case (int)MotionTimeLineType.Morph:
                                            if (!tlPlaySet.isOfficialDance && morphMgr.ContainsSlotNo(slotNo))
                                            {
                                                SetMaidAreaMotionFrame(maids, true);
                                                morphMgr.ChangeMaidSlotNo(maid, slotNo);
                                                switch (morphMgr.UpdateIndex)
                                                {
                                                    case (int)MotionUpdateType.ValueUpdating:
                                                        if (!MyHelper.CheckNull(morphMgr.ItemDeletionDic) && morphMgr.ExistsKeyFrame(slotNo))
                                                        {
                                                            SetMaidAreaMorphUpdate(maid, slotNo);
                                                            SetMaidAreaMorphUpdateAll(maid, slotNo);
                                                        }
                                                        break;
                                                    case (int)MotionUpdateType.BoneAddition:
                                                        if (morphMgr.ExistsKeyFrame(slotNo))
                                                        {
                                                            SetMaidAreaItemSelecter(true);
                                                            SetMaidAreaMotionFrameUpdate(maid, slotNo, true);
                                                        }
                                                        break;
                                                    case (int)MotionUpdateType.NewFrame:
                                                        SetMaidAreaItemSelecter(true);
                                                        SetMaidAreaMotionNewFrame(maid, slotNo, true);
                                                        break;
                                                }
                                            }
                                            break;
                                        case (int)MotionTimeLineType.Camera:
                                            SetMaidAreaCameraFrame();
                                            break;
                                    }
                                }
                                else if (captureMgr.IsMotionCapture || captureMgr.IsMotionCapture)
                                {
                                    SetMaidAreaMotionComment();
                                }
                                break;
                            case (int)MotionProcType.KeepPose:
                                SetMaidAreaPoseBone(maid);
                                SetMaidAreaPoseBoneGroup(maid);
                                SetMaidAreaPoseBoneList(maid);
                                break;
                            case (int)MotionProcType.Capture:
                                if (!tlWindowMgr.IsEnabled)
                                {
                                    SetMaidAreaCapture(maid);
                                    if (captureMgr.IsMyPose)
                                    {
                                        SetMaidAreaCaptureBoneGroup(true);
                                        SetMaidAreaCaptureBoneSelect();
                                    }
                                }
                                else
                                {
                                    SetMaidAreaMotionComment();
                                }
                                break;
                        }
                    }
                    break;

                case (int)GuiMenu.MaidAppearance:
                    SetMaidAreaAppearanceTop(maids);
                    switch (guiMgr.AppearanceIndex)
                    {
                        case (int)MaidAppearanceType.Hair:
                            SetMaidAreaHairTemp(maids, maidIndex);
                            SetMaidAreaHairList(maids, maidIndex);
                            break;

                        case (int)MaidAppearanceType.Body:
                            SetMaidAreaBody(maids, maidIndex);
                            break;

                        case (int)MaidAppearanceType.Facial:
                            SetMaidAreaFacialTop(maids);

                            if (!isDance && !tlWindowMgr.IsEnabled)
                            {
                                if (!isFreeDance)
                                {
                                    foreach (var maid in maids)
                                    {
                                        maid.boMabataki = !guiMgr.IsFacialEnabled;
                                        if (guiMgr.IsFacialEnabled)
                                        {
                                            maidMgr.SetMabatakiOff(maid);
                                        }
                                    }
                                }
                                if (guiMgr.IsFacialEnabled)
                                {
                                    if (MyHelper.CheckNull(maidMgr.FaicalDic))
                                    {
                                        maidMgr.FaicalDic = new Dictionary<int, MaidFacialSet>();
                                    }
                                    var maid = maids[maidIndex];

                                    switch (guiMgr.FacialIndex)
                                    {
                                        case (int)MaidFacialType.Read:
                                            SetMaidAreaFacialList(maid);
                                            break;

                                        case (int)MaidFacialType.Option:
                                            SetMaidAreaFacialOption(maid, 5, false); ;
                                            break;

                                        case (int)MaidFacialType.Eye:
                                            SetMaidAreaFacialEye(maid);
                                            break;

                                        case (int)MaidFacialType.Mouth:
                                            SetMaidAreaFacialMouth(maid);
                                            break;
                                    }
                                }
                                if (guiMgr.IsMaidAppearanceAll)
                                {
                                    maidMgr.CopyFacialSet(maidIndex);
                                }
                            }
                            break;
                    }
                    break;

                case (int)GuiMenu.MaidMove:
                    if (!isDance)
                    {
                        if (moveMgr.IsEnabled)
                        {
                            SetMaidAreaMoveTop(maids);
                            var maid = maids[maidIndex];
                            SetMaidAreaMoveControl(maids);
                            SetMaidAreaMoveList(maids);
                            SetMaidAreaMoveTransform(maid);
                        }
                        else
                        {
                            SetMaidAreaMoveList(maids);
                        }

                    }
                    break;
            }
        }

        private void WindowFunctionBg(List<Maid> maids)
        {
            switch (guiMainMenuIndex)
            {
                case (int)GuiMenu.BgSelect:
                    if (isGuiMenuBgTransform)
                    {
                        SetBgAreaTransform();
                        SetBgAreaColor();
                        SetBgAreaSkybox();
                    }
                    else
                    {
                        SetBgAreaTop();
                        SetBgAreaList();
                    }
                    break;

                case (int)GuiMenu.BgParts:
                    if (bgMgr.IsBgIntance)
                    {
                        SetBgAreaInstanceComboList();
                        if (!bgMgr.IsBgInstanceComboOn)
                        {
                            SetBgAreaInstanceTop();
                            SetBgAreaInstanceList();
                        }
                    }
                    else
                    {
                        SetBgAreaPartsTop();
                        SetBgAreaPartsList();
                    }
                    break;

                case (int)GuiMenu.ForegroundSelect:
                    SetBgAreaForeground();
                    if (!MyHelper.CheckNull(maids))
                    {
                        SetBgAreaMaidMask(maids);
                    }
                    break;
            }
        }

        private void WindowFunctionStageDirectin(List<Maid> maids)
        {
            SetStageObjectAreaTop();
            if (stageMgr.IsStageObjectSetting)
            {
                if (stageMgr.IsStageObjectTransform)
                {
                    SetStageObjectAreaTransform();
                }
                else
                {
                    SetStageObjectAreaOption(maids);
                }
            }
            else
            {
                SetStageObjectAreaList();
                if (stageMgr.IsStageObjectSetting)
                {
                    SetStageObjectAreaOption(maids);
                }
            }
        }

        private void WindowFunctionModel(List<Maid> maids)
        {
            if (!MyHelper.CheckNull(maids))
            {
                SetModelAreaMenu();

                if (isGuiMenuModelTransform)
                {
                    SetModelAreaTransform(maids);
                }
                else
                {
                    SetModelAreaList();
                }
            }
            else
            {
                SetMenuAreaNoMaid(2);
            }
        }

        private void WindowFunctionParticle()
        {
            if (particleMgr.IsBubbleLame)
            {
                SetBubbleLameAreaMenu();
                switch (particleMgr.BubbleLameMenuIndex)
                {
                    case (int)StageParticleType.Load:
                        SetBubbleLameList();
                        break;
                    case (int)StageParticleType.Module:
                        SetBubbleLameAreaModule();
                        break;
                    case (int)StageParticleType.Position:
                        SetBubbleLameAreaPosition();
                        break;
                }
            }
            else
            {
                SetParticleAreaMenu();
                if (particleMgr.ParticleMenuIndex == (int)ParticleModuleType.Read)
                {
                    SetParticleAreaList();
                }
                else if (!MyHelper.CheckNull(particleMgr.ParticleData))
                {
                    SetParticleAreaModule();
                }
            }

        }

        private void WindowFunctionEach()
        {
            SetStageObjectEachAreaTop();
            switch (stageMgr.EachIndex)
            {
                case (int)StageObjectEachType.Crowd:
                    WindowFunctionCrowd();
                    break;
                case (int)StageObjectEachType.Cyalume:
                    SetStageObjectEachAreaCyalumeTop();
                    SetStageObjectEachAreaCyalumeMain();
                    break;
            }
        }

        private void WindowFunctionLight(List<Maid> maids)
        {
            SetLightAreaTop();
            switch (lightMgr.LightTypeIndex)
            {
                case (int)StageLightType.MainSub:
                    SetLightAreaMain();
                    SetLightAreaSub();
                    break;

                case (int)StageLightType.Spot:
                    SetLightAreaSpot(maids);
                    break;

                case (int)StageLightType.Point:
                    SetLightAreaPoint(maids);
                    break;
            }
        }

        private void WindowFunctionCamera(List<Maid> maids)
        {
            switch (guiMainMenuIndex)
            {
                case (int)GuiMenu.CameraLookAt:
                    if (!MyHelper.CheckNull(maids))
                    {
                        SetLookAtAreaTop();
                        if (maidLookAt.lookAtIndex != (int)LookAtCameraType.Off)
                        {
                            switch (maidLookAt.lookAtIndex)
                            {
                                case (int)LookAtCameraType.Horizon:
                                case (int)LookAtCameraType.Vertical:
                                    SetLookAtAreaTopOfDivision();
                                    SetLookAtAreaCameraSelectOfDivision();
                                    SetLookAtAreaCameraSetting1(maids);
                                    SetLookAtAreaCameraSetting2(maids);
                                    SetLookAtAreaCameraSetting3();
                                    break;

                                case (int)LookAtCameraType.SubCamera:
                                    SetLookAtAreaTopOfSubCamera();
                                    SetLookAtAreaCameraSelectOfSubCamera();
                                    SetLookAtAreaCameraSetting1(maids);
                                    SetLookAtAreaCameraSetting2(maids);
                                    SetLookAtAreaCameraSetting3();
                                    break;

                                case (int)LookAtCameraType.LockOn:
                                    SetLookAtAreaTopOfLockCamera();
                                    SetLookAtAreaCameraSetting2(maids);
                                    break;

                            }
                        }
                    }
                    else
                    {
                        SetMenuAreaNoMaid(2);
                    }
                    break;

                case (int)GuiMenu.CameraAuto:
                    if (!MyHelper.CheckNull(maids))
                    {
                        SetAutoCameraArea(maids);
                        SetAutoCameraAreaList();
                    }
                    else
                    {
                        SetMenuAreaNoMaid(2);
                    }
                    break;

                case (int)GuiMenu.CameraPlay:
                    if (!isFreeDance)
                    {
                        SetCameraAreaComboList();
                        if (!isCameraComboOn)
                        {
                            SetCameraAreaPlay();
                            SetCameraAreaTime();
                            SetFreeDanceAreaInformation();
                            SetCameraAreaFunction();
                            SetFreeDanceAreaOptionSubUi();
                        }
                    }
                    break;

                case (int)GuiMenu.CameraTransform:
                    SetSwitcherAreaTransform();
                    SetSwitcherAreaXml();
                    SetSwitcherAreaXmlData();
                    break;
            }
        }

        private void WindowFunctionExtra(List<Maid> maids)
        {
            if (MyHelper.CheckNull(maids))
            {
                SetMenuAreaNoMaid(2);
                return;
            }

            var maidIndex = maidMgr.GuiMaidIndex;
            SetExtraAreaTop(maids, maidIndex, guiMgr.IsBukkakeList);
            switch (guiMainMenuIndex)
            {
                case (int)GuiMenu.Bukkake:
                    if (guiMgr.IsBukkakeList)
                    {
                        SetExtraAreaBukkakeList(maids, maidIndex);
                    }
                    else
                    {
                        SetExtraAreaBukkakeTop();
                        SetExtraAreaBukkakeParts();
                        SetExtraAreaBukkake();
                    }
                    break;

                case (int)GuiMenu.Emission:
                    SetExtraAreaEnema(maids, maidIndex);
                    SetExtraAreaPee(maids, maidIndex);
                    break;
            }
        }

        #endregion

        #region GuiMenu
        private void SetTitleArea()
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.x += MyConst.GUI_WIDTH * 4 - MyConst.GUI_HEIGHT;
            rect.y = 0;
            rect.width = MyConst.GUI_HEIGHT;
            if (GUI.Button(rect, "x", guiStyle.gsButton))
            {
                myGui.isGuiOn = false;
            }
            var isMin = false;
            var height = (float)MyConst.GUI_HEIGHT;
            if (windowRect.height == MyConst.GUI_HEIGHT)
            {
                isMin = true;
                height = MyConst.MAIN_WINDOW_RECT.height;
            }
            rect.x -= MyConst.GUI_HEIGHT;
            if (GUI.Button(rect, isMin ? "o" : "-", guiStyle.gsButton))
            {
                windowRect.height = height;
            }
            rect.x -= MyConst.GUI_HEIGHT;
            for (int i = MyConst.GUI_CHANGE_WINDOW_BUTTON; 0 < i; i--)
            {
                rect.x -= MyConst.GUI_HEIGHT;
                if (GUI.Button(rect, i.ToString(), guiStyle.gsButton))
                {
                    windowMgr.ChangeWindow(i - 1);
                }
            }
        }

        private void SetMenuAreat()
        {
            var menu = MyConst.MAIN_MENU_LABEL;
            var rect = MyConst.MENU_RECT;
            GUI.Label(rect, "◆メニュー", guiStyle.gsLabel);
            rect.y += rect.height;
            if (GUI.Button(rect, "フリーダンス", guiStyle.gsButton))
            {
                this.guiMainMenuIndex = (int)GuiMenu.DanceFree;
            }
            rect.y += rect.height;
            if (GUI.Button(rect, "ショ-トカット", guiStyle.gsButton))
            {
                this.guiMainMenuIndex = (int)GuiMenu.ShortCut;
            }
            rect.y += rect.height;
            rect.height = (menu.Count() - MyConst.MENU_START_INDEX) * rect.height;
            var viewRect = rect;
            viewRect.height = MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - 4);
            viewRect.width += MyConst.GUI_MARGIN;
            rect.y = MyConst.GUI_HEIGHT;
            scrollMenu = GUI.BeginScrollView(viewRect, scrollMenu, rect, false, true);

            rect = MyConst.MENU_RECT;
            var isSet = false;
            var label = "";
            var guiMainMenuIndex = this.guiMainMenuIndex;
            for (int i = MyConst.MENU_START_INDEX; i < menu.GetLength(0); i++)
            {
                if (menu[i].StartsWith(MyConst.MENU_LABEL_CHAR))
                {
                    GUI.Label(rect, menu[i], guiStyle.gsLabel);
                    if (!isSet)
                    {
                        label = menu[i];
                    }
                }
                else
                {
                    var isSelected = GUI.Toggle(rect, i == guiMainMenuIndex, menu[i], guiStyle.gsToggle);
                    if (isSelected)
                    {
                        guiMainMenuIndex = i;
                        label += "：" + menu[i];
                        isSet = true;

                        if (guiMainMenuIndex != this.guiMainMenuIndex &&
                            guiMainMenuIndex == (int)GuiMenu.CameraTransform)
                        {
                            isSwitcherOn = true;
                            cameraMgr.ResetMainCamera();
                        }
                    }
                }
                rect.y += rect.height;
            }
            if (guiMainMenuIndex < MyConst.MENU_START_INDEX)
            {
                label = menu[guiMainMenuIndex];
            }
            this.guiMainMenuIndex = guiMainMenuIndex;
            GUI.EndScrollView();

            ViewMenuName(label);
        }

        private void ViewMenuName(string label)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.width *= 2;
            GUI.Label(rect, label, guiStyle.gsLabel);
            rect.x += rect.width;
            switch (guiMainMenuIndex)
            {
                case (int)GuiMenu.DanceFree:
                    isGuiMenuDanceInfomation = GUI.Toggle(rect, isGuiMenuDanceInfomation, ">情報表示ON", guiStyle.gsToggle);
                    break;
                case (int)GuiMenu.MaidSwing:
                    swingMgr.IsEachSetting = GUI.Toggle(rect, swingMgr.IsEachSetting, ">個別設定ON", guiStyle.gsToggle);
                    break;
                case (int)GuiMenu.MaidMotion:
                    tlWindowMgr.IsGuiOn = GUI.Toggle(rect, tlWindowMgr.IsGuiOn, ">タイムラインON", guiStyle.gsToggle);
                    break;
                case (int)GuiMenu.BgSelect:
                    isGuiMenuBgTransform = GUI.Toggle(rect, isGuiMenuBgTransform, ">座標・空間色設定ON", guiStyle.gsToggle);
                    break;
                case (int)GuiMenu.BgParts:
                    bgMgr.IsBgIntance = GUI.Toggle(rect, bgMgr.IsBgIntance, ">背景パーツ一覧ON", guiStyle.gsToggle);
                    break;
                case (int)GuiMenu.ModelSelect:
                    isGuiMenuModelTransform = GUI.Toggle(rect, isGuiMenuModelTransform, ">座標設定ON", guiStyle.gsToggle);
                    break;
                case (int)GuiMenu.ParticleSelect:
                    particleMgr.IsBubbleLame = GUI.Toggle(rect, particleMgr.IsBubbleLame, ">泡・ラメON", guiStyle.gsToggle);
                    break;
                case (int)GuiMenu.StageObjectSelect:
                    stageMgr.IsStageObjectSetting = GUI.Toggle(rect, stageMgr.IsStageObjectSetting, ">道具設定ON", guiStyle.gsToggle);
                    break;
                case (int)GuiMenu.Bukkake:
                    guiMgr.IsBukkakeList = GUI.Toggle(rect, guiMgr.IsBukkakeList, ">リスト読込ON", guiStyle.gsToggle);
                    break;
                default:
                    break;
            }
        }

        private void SetMenuAreaNoMaid(int baseRow)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 3;
            GUI.Label(rect, "メイドが配置されていません", guiStyle.gsLabel);
        }

        #endregion

        #region GuiDance
        private void SetFreeDanceAreaMessage()
        {
            int baseRow = 3;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 4;
            if (isExportOn)
            {
                var label = "公式ダンス情報出力ON" + (isKaraokeOn ? " + カラオケ" : "");
                GUI.Label(rect, label, guiStyle.gsLabel);
            }

            rect.y += rect.height;
            if (dressMgr.IsUndressRandomOn)
            {
                GUI.Label(rect, "ランダム脱衣ON", guiStyle.gsLabel);
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            rect.x += rect.width * 3;
            if (GUI.Button(rect, "情報出力", guiStyle.gsButton))
            {
                maidMgr.WriteMaidInfomationToConsole(bgMgr.GetBackgroundName());
            }
        }

        private void SetFreeDanceAreaCommboList()
        {
            int baseRow = 2;
            if (MyHelper.CheckNull(danceList))
            {
                GetDanceList((int)DanceListType.Title);
            }
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "ダンス", guiStyle.gsLabel);

            if (!MyHelper.CheckNull(danceList) && !isDance)
            {
                rect.x += rect.width;
                rect.width *= 3;
                if (GUI.Button(rect, danceList[this.danceListIndex], guiStyle.gsCombo) && danceList.Count() > 1)
                {
                    isFreeComboOn = !isFreeComboOn;
                }

                if (isFreeComboOn && !isFreeDance && danceList.Count() > 1)
                {
                    var index = guiMgr.SetCommboList(baseRow, danceList,
                                                     ref scrollFreeList, ref isFreeComboOn);
                    if (!isFreeComboOn)
                    {
                        danceListIndex = index;
                    }
                    isFreeGroupOn = false;
                }
            }
        }

        private void SetFreeDanceAreaDancePlay()
        {
            int baseRow = 3;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            if (isFreeDance)
            {
                if (songMgr.IsSong)
                {
                    GUI.Label(rect, "歌モードON", guiStyle.gsLabel);
                }
            }
            else
            {
                var isSong = songMgr.IsSong;
                isSong = GUI.Toggle(rect, isSong, "歌モード", guiStyle.gsToggle);
                if (isSong != songMgr.IsSong)
                {
                    songMgr.IsSong = isSong;
                    GetDanceList((int)DanceListType.Title);
                    GetDanceListGroup((int)DanceListType.Title);
                    danceListIndex = 0;
                    danceGroupIndex = 0;
                }
            }
            rect.x += rect.width;
            if (GUI.Button(rect, (isFreeDance) ? "停止" : "再生", guiStyle.gsButton))
            {
                isFreeStoped = false;
                if (!isFreeDance)
                {
                    if (isFreeGroupOn)
                    {
                        danceGroupPlayIndex = -1;
                        GetDanceListGroup((int)DanceListType.Data);
                    }
                    isFreeDance = StartFreeDance(true);
                }
                else
                {
                    isFreeDance = false;
                    cameraMgr.FadeIn(0f);
                    EndFreeDance(true);
                }
            }
            rect.x += rect.width;
            if (isFreeDance)
            {
                if (GUI.Button(rect, isFreeStoped ? "再開" : "一時停止", guiStyle.gsButton))
                {
                    StopFreeDance(!isFreeStoped);
                    isFreeStoped = !isFreeStoped;
                }
            }
            else
            {
                if (GUI.Button(rect, "座標リセット", guiStyle.gsButton))
                {
                    cameraMgr.ResetMainCamera();
                }
            }

            rect.x += rect.width;
            if (GUI.Button(rect, (isFreeDance) ? "データ読込" : "リスト取得", guiStyle.gsButton))
            {
                if (isFreeDance)
                {
                    GetDanceList((int)DanceListType.Motion);
                }
                else
                {
                    GetDanceList((int)DanceListType.Title);
                    GetDanceListGroup((int)DanceListType.Title);
                }
            }
        }

        private void SetFreeDanceAreaDanceTime()
        {
            int baseRow = 4;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            if (isFreeDance)
            {
                guiMgr.IsDanceSliderOn = GUI.Toggle(rect, guiMgr.IsDanceSliderOn, "タイム変更", guiStyle.gsToggle);
                if (guiMgr.IsDanceSliderOn || isFreeStoped)
                {
                    rect.x += rect.width;
                    rect.width *= 2;
                    rect.y += rect.height / 3;
                    rect.height /= 2;
                    var bgmTime = GetBgmTime();
                    freeSliderCurrent = GUI.HorizontalSlider(rect, bgmTime, 0f, freeSliderMax);

                    if (isFreeStoped)
                    {
                        rect = MyConst.DEFAULT_RECT;
                        rect.y *= baseRow;
                        rect.x += rect.width * 3;
                        guiMgr.SetNumberField(rect, freeSliderCurrent, ref freeSliderCurrent);
                    }

                    if (freeSliderCurrent != bgmTime)
                    {
                        SetAnimationAndBgmTime(freeSliderCurrent, isFreeStoped);
                        if (!isFreeStoped)
                        {
                            StopFreeDance(isFreeStoped);
                        }
                        if (songMgr.IsSong)
                        {
                            tlPlaySet.fromFrame = MyHelper.ConvertFrame(freeSliderCurrent);
                        }
                    }
                }
            }
            else
            {
                guiMgr.IsDanceListSort = GUI.Toggle(rect, guiMgr.IsDanceListSort, "リストソート", guiStyle.gsToggle);
                if (guiMgr.IsDanceListSort)
                {
                    rect.x += rect.width;
                    if (GUI.Button(rect, "リスト順", guiStyle.gsButton))
                    {
                        GetDanceList((int)DanceListType.Title);
                    }
                    rect.x += rect.width;
                    if (GUI.Button(rect, "昇順", guiStyle.gsButton))
                    {
                        danceList.Sort();
                    }
                    rect.x += rect.width;
                    if (GUI.Button(rect, "降順", guiStyle.gsButton))
                    {
                        danceList.Reverse();
                    }
                }
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "ダンスタイム", guiStyle.gsLabel);
            rect.x += rect.width;
            GUI.Label(rect, "　開始", guiStyle.gsLabel);
            rect.x += rect.width;
            GUI.Label(rect, "　終了", guiStyle.gsLabel);
            rect.x += rect.width;
            GUI.Label(rect, "　現在", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            GUI.Label(rect, "(リピート)", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref cameraFree.stTime);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref cameraFree.edTime);

            if (isFreeDance &&
               (guiMgr.IsDanceSliderOn || isFreeStoped))
            {
                rect.x += rect.width;
                GUI.Label(rect, freeSliderCurrent.ToString(MyConst.DECIMAL_FORMAT), guiStyle.gsLabel);
            }
        }
        #endregion

        #region GuiDance Option
        private void SetFreeDanceAreaOptionTop()
        {
            int baseRow = 8;
            try
            {
                var rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow;
                GUI.Label(rect, "オプション", guiStyle.gsLabel);
                for (int i = 0; i < MyConst.FREE_DANCE_OPTION_LABEL.Count(); i++)
                {
                    rect.x += rect.width;
                    var isSelected = GUI.Toggle(rect, i == guiMgr.FreeDanceOptionIndex, MyConst.FREE_DANCE_OPTION_LABEL[i], guiStyle.gsToggle);
                    if (isSelected && i != guiMgr.FreeDanceOptionIndex)
                    {
                        guiMgr.FreeDanceOptionIndex = i;
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        private void SetFreeDanceAreaOptionDanceMain()
        {
            int baseRow = 9;
            try
            {
                var rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow;
                rect.width *= 2;
                if (!isFreeDance)
                {
                    var isMultipleMaids = maidMgr.IsMultipleMaids;
                    maidMgr.IsMultipleMaids = GUI.Toggle(rect, maidMgr.IsMultipleMaids, "複数メイドプラグイン", guiStyle.gsToggle);
                    if (isMultipleMaids != maidMgr.IsMultipleMaids && maidMgr.IsMultipleMaids)
                    {
                        guiMgr.IsChangingLightOff = true;
                    }
                    rect.x += rect.width;
                    var isMaidsDanceOn = myGui.isMaidsDanceOn;
                    myGui.isMaidsDanceOn = GUI.Toggle(rect, isMaidsDanceOn, "自動複数人ダンス設定", guiStyle.gsToggle);
                    if (isMaidsDanceOn != myGui.isMaidsDanceOn)
                    {
                        isAutoTransform = myGui.isMaidsDanceOn;
                    }
                }
                else
                {
                    if (maidMgr.IsMultipleMaids)
                    {
                        GUI.Label(rect, "複数メイドプラグインON", guiStyle.gsLabel);
                    }
                    rect.x += rect.width;
                    if (myGui.isMaidsDanceOn)
                    {
                        GUI.Label(rect, "自動複数人ダンス設定ON", guiStyle.gsLabel);
                    }
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 1;
                rect.width *= 2;
                if (!isFreeDance)
                {
                    myGui.isDanceCameraAdjustOn = GUI.Toggle(rect, myGui.isDanceCameraAdjustOn, "カメラ見切れ調整", guiStyle.gsToggle);
                    rect.x += rect.width;
                    isAutoTransform = GUI.Toggle(rect, isAutoTransform, "メイド一括配置自動選択", guiStyle.gsToggle);
                }
                else
                {
                    if (myGui.isDanceCameraAdjustOn)
                    {
                        GUI.Label(rect, "カメラ見切れ調整ON", guiStyle.gsLabel);
                    }
                    rect.x += rect.width;
                    if (isAutoTransform)
                    {
                        GUI.Label(rect, "メイド一括配置自動選択ON", guiStyle.gsLabel);
                    }
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 2;
                rect.width *= 2;
                var syncSet = guiMgr.DanceSyncSet;
                syncSet.isSyncDanceGap = GUI.Toggle(rect, syncSet.isSyncDanceGap, "ダンスずれ調整", guiStyle.gsToggle);
                guiMgr.DanceSyncSet = syncSet;
                rect.x += rect.width;
                if (!isFreeDance)
                {
                    isAnyTransform = GUI.Toggle(rect, isAnyTransform, "メイド任意配置", guiStyle.gsToggle);
                }
                else if(isAnyTransform)
                {
                    GUI.Label(rect, "メイド任意配置ON", guiStyle.gsLabel);
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 3;
                rect.width *= 2;
                guiMgr.IsFreeRepeatOn = GUI.Toggle(rect, guiMgr.IsFreeRepeatOn, "1曲リピート再生", guiStyle.gsToggle);
                rect.x += rect.width;
                cameraMgr.IsAutoCamera = GUI.Toggle(rect, cameraMgr.IsAutoCamera, "オートカメラ", guiStyle.gsToggle);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }
        private void SetFreeDanceAreaOptionDanceGroup()
        {
            int baseRow = 13;
            try
            {
                if (MyHelper.CheckNull(danceGroupList))
                {
                    GetDanceListGroup((int)DanceListType.Title);
                }
                if (!MyHelper.CheckNull(danceList))
                {
                    var rect = MyConst.DEFAULT_RECT;
                    rect.y *= baseRow;
                    if (!isFreeDance)
                    {
                        isFreeGroupOn = GUI.Toggle(rect, isFreeGroupOn, "連続再生", guiStyle.gsToggle);
                        if (isFreeGroupOn)
                        {
                            guiMgr.SetIndexChangedButton(ref rect, danceGroupList.Count(), ref danceGroupIndex);
                            guiMgr.SetIndexChangedLabel(rect, danceGroupList[danceGroupIndex]);
                        }
                    }
                    else if (isFreeGroupOn)
                    {
                        rect.width = MyConst.GUI_WIDTH * 2;
                        GUI.Label(rect, "ダンス連続再生ON", guiStyle.gsLabel);
                        rect.x += rect.width;
                        GUI.Label(rect, danceGroupList[danceGroupIndex], guiStyle.gsLabel);
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        private void SetFreeDanceAreaOptionDanceDirection()
        {
            int baseRow = 15;
            try
            {
                var label = "";
                var rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow;
                rect.width *= 2;
                guiMgr.IsFreeMotionOff = GUI.Toggle(rect, guiMgr.IsFreeMotionOff, "カメラモーションOFF", guiStyle.gsToggle);
                rect.x += rect.width;
                if (!isFreeDance)
                {                    
                    for (int i = 0; i < MyConst.DANCE_MOVIE_LABEL.Count(); i++)
                    {
                        var isSelected = GUI.Toggle(rect, guiMgr.DanceMovieTypeIndex == i, MyConst.DANCE_MOVIE_LABEL[i], guiStyle.gsToggle);
                        if (isSelected)
                        {
                            guiMgr.DanceMovieTypeIndex = i;
                        }
                        if (i == 0)
                        {
                            rect.y += MyConst.GUI_HEIGHT;
                            rect.width /= 3;
                        }
                        else
                        {
                            rect.x += rect.width;
                        }
                    }
                    guiMgr.IsMovieTransparent = GUI.Toggle(rect, guiMgr.IsMovieTransparent, "透過", guiStyle.gsToggle);
                }
                else if(guiMgr.DanceMovieTypeIndex != (int)DanceMovieType.Non)
                {
                    GUI.Label(rect, "背景映像ON", guiStyle.gsLabel);
                }    

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 1;
                rect.width *= 2;
                label = "照明切替OFF";
                if (!isFreeDance)
                {
                    guiMgr.IsChangingLightOff = GUI.Toggle(rect, guiMgr.IsChangingLightOff, label, guiStyle.gsToggle);
                }
                else if (isFreeDance && guiMgr.IsChangingLightOff)
                {
                    GUI.Label(rect, label, guiStyle.gsLabel);
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 2;
                rect.width *= 2;
                label = "背景切替OFF";
                if (!isFreeDance)
                {
                    guiMgr.IsChangingBgOff = GUI.Toggle(rect, guiMgr.IsChangingBgOff, label, guiStyle.gsToggle);
                    if (guiMgr.IsChangingBgOff)
                    {
                        isAoutChangingBg = false;
                    }
                }
                else if (isFreeDance && guiMgr.IsChangingBgOff)
                {
                    GUI.Label(rect, label, guiStyle.gsLabel);
                }
                rect.x += rect.width;
                label = "衣装切替・脱衣OFF";
                if (!isFreeDance)
                {
                    guiMgr.IsChangeDressOff = GUI.Toggle(rect, guiMgr.IsChangeDressOff, label, guiStyle.gsToggle);
                    if (guiMgr.IsChangeDressOff)
                    {
                        guiMgr.IsRandomDress = false;
                    }
                }
                else if (isFreeDance && guiMgr.IsChangeDressOff)
                {
                    GUI.Label(rect, label, guiStyle.gsLabel);
                }                

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 3;
                rect.width *= 2;
                label = "演出OFF";
                if (!isFreeDance)
                {
                    guiMgr.IsFreeEffectOff = GUI.Toggle(rect, guiMgr.IsFreeEffectOff, label, guiStyle.gsToggle);
                }
                else if (isFreeDance && guiMgr.IsFreeEffectOff)
                {
                    GUI.Label(rect, label, guiStyle.gsLabel);
                }

            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        private void SetFreeDanceAreaOptionMaidMain()
        {
            int baseRow = 9;
            try
            {
                var rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow;
                rect.width *= 2;
                isMaidShuffle = GUI.Toggle(rect, isMaidShuffle, "メイドシャッフル", guiStyle.gsToggle);
                rect.x += rect.width;
                var label = "目だけカメラ向ける";
                if (!isFreeDance)
                {
                    myGui.isMaidsEyesOn = GUI.Toggle(rect, myGui.isMaidsEyesOn, label, guiStyle.gsToggle);
                }
                else if (isFreeDance && myGui.isMaidsEyesOn)
                {
                    GUI.Label(rect, label + "ON", guiStyle.gsLabel);
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 1;
                rect.width *= 2;
                extraMgr.IsBreath = GUI.Toggle(rect, extraMgr.IsBreath, "ダンス吐息ON", guiStyle.gsToggle);
                rect.x += rect.width;
                label = "口パク無効";
                if (!isFreeDance)
                {
                    guiMgr.IsKuchipakuDisabled = GUI.Toggle(rect, guiMgr.IsKuchipakuDisabled, "口パク無効", guiStyle.gsToggle);
                }
                else if (isFreeDance && guiMgr.IsKuchipakuDisabled)
                {
                    GUI.Label(rect, label + "ON", guiStyle.gsLabel);
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 2;
                label = "ランダム脱衣";
                rect.width = MyConst.GUI_WIDTH * 1.25f;
                if (!isFreeDance && !isDance)
                {
                    dressMgr.IsUndressRandomOn = GUI.Toggle(rect, dressMgr.IsUndressRandomOn, label, guiStyle.gsToggle);
                }
                else if (isFreeDance && dressMgr.IsUndressRandomOn)
                {
                    GUI.Label(rect, label + "ON", guiStyle.gsLabel);
                }
                rect.x += rect.width;
                rect.width = MyConst.GUI_WIDTH * 0.75f;
                dressMgr.IsUndressRandomBlushOn = GUI.Toggle(rect, dressMgr.IsUndressRandomBlushOn, "羞恥", guiStyle.gsToggle);

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 2;
                rect.x += rect.width * 2;
                GUI.Label(rect, "揺れ自動設定", guiStyle.gsLabel);
                rect.x += rect.width;
                rect.width /= 3;
                myGui.isMaidsSwingMuneOn = GUI.Toggle(rect, myGui.isMaidsSwingMuneOn, "胸", guiStyle.gsToggle);
                rect.x += rect.width;
                myGui.isMaidsSwingHairOn = GUI.Toggle(rect, myGui.isMaidsSwingHairOn, "髪", guiStyle.gsToggle);
                rect.x += rect.width;
                myGui.isMaidsSwingDressOn = GUI.Toggle(rect, myGui.isMaidsSwingDressOn, "服", guiStyle.gsToggle);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        private void SetFreeDanceAreaOptionMaidRandomFace()
        {
            int baseRow = 13;
            try
            {
                var rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow;
                var label = "ランダム表情";
                if (MyHelper.CheckNull(randomFaceList))
                {
                    GetRandomFaceList();
                }
                if (!MyHelper.CheckNull(randomFaceList))
                {
                    if (!isFreeDance && !isDance)
                    {
                        isRandomFace = GUI.Toggle(rect, isRandomFace, label, guiStyle.gsToggle);
                        if (isRandomFace)
                        {
                            guiMgr.SetIndexChangedButton(ref rect, randomFaceList.Count(), ref randomFaceIndex);
                            guiMgr.SetIndexChangedLabel(rect, randomFaceList[randomFaceIndex]);
                        }
                    }
                    else if (isRandomFace)
                    {
                        rect.width = MyConst.GUI_WIDTH * 2;
                        GUI.Label(rect, label + "ON", guiStyle.gsLabel);
                        rect.x += rect.width;
                        GUI.Label(rect, randomFaceList[randomFaceIndex], guiStyle.gsLabel);
                    }
                }

            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }


        private void SetFreeDanceAreaOptionMaidDressGroup()
        {
            int baseRow = 14;
            try
            {
                var rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow;
                var label = "ランダム衣装";
                if (MyHelper.CheckNull(dressMgr.DressGroupList))
                {
                    dressMgr.GetDressGroupList();
                }
                if (!MyHelper.CheckNull(dressMgr.DressGroupList))
                {
                    if (!isFreeDance && !isDance)
                    {
                        guiMgr.IsRandomDress = GUI.Toggle(rect, guiMgr.IsRandomDress, label, guiStyle.gsToggle);
                        if (guiMgr.IsRandomDress)
                        {
                            guiMgr.IsChangeDressOff = false;
                            var dressGroupIndex = dressMgr.DressGroupIndex;
                            guiMgr.SetIndexChangedButton(ref rect, dressMgr.DressGroupList.Count(), ref dressGroupIndex);
                            guiMgr.SetIndexChangedLabel(rect, dressMgr.DressGroupList[dressGroupIndex]);
                            dressMgr.DressGroupIndex = dressGroupIndex;
                        }
                    }
                    else if (guiMgr.IsRandomDress)
                    {
                        rect.width = MyConst.GUI_WIDTH * 2;
                        GUI.Label(rect, label + "ON", guiStyle.gsLabel);
                        rect.x += rect.width;
                        GUI.Label(rect, dressMgr.DressGroupList[dressMgr.DressGroupIndex], guiStyle.gsLabel);
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        private void SetFreeDanceAreaOptionMaidSwing(List<Maid> maids)
        {
            int baseRow = 19;
            try
            {
                var rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow;
                GUI.Label(rect, "胸髪衣装揺れ", guiStyle.gsLabel);
                rect.x += rect.width;
                if (GUI.Button(rect, "リセット", guiStyle.gsButton))
                {
                    swingMgr.ResetMuneParameter(maids);
                    swingMgr.ResetHairParameter(maids);
                    if (!maidMgr.IsMultipleMaids)
                    {
                        swingMgr.ResetSkirtParameter(maids);
                    }
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "共通適用", guiStyle.gsButton))
                {
                    swingMgr.ReadCommonMuneParameter(maids);
                    swingMgr.ReadCommonHairParameter(maids);
                    if (!maidMgr.IsMultipleMaids)
                    {
                        swingMgr.ReadCommonSkirtParameter(maids);
                    }
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "個別適用", guiStyle.gsButton))
                {
                    swingMgr.ReadEachMuneParameter(maids);
                    swingMgr.ReadEachHairParameter(maids, MyConst.PRE_INDEX);
                    if (!maidMgr.IsMultipleMaids)
                    {
                        swingMgr.ReadEachSkirtParameter(maids, MyConst.PRE_INDEX);
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        private void SetFreeDanceAreaOptionSubMain()
        {
            int baseRow = 9;
            try
            {
                var rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow;
                rect.width *= 2;
                myGui.isGuiAutoOff = GUI.Toggle(rect, myGui.isGuiAutoOff, "GUI自動非表示", guiStyle.gsToggle);
                rect.x += rect.width;
                isWasdOn = GUI.Toggle(rect, isWasdOn, "WASD移動＋マウス操作", guiStyle.gsToggle);

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 1;
                rect.width *= 2;
                myGui.isUiAutoOff = GUI.Toggle(rect, myGui.isUiAutoOff, "公式UI自動非表示", guiStyle.gsToggle);
                rect.x += rect.width;
                var isMute = GUI.Toggle(rect, soundMgr.IsMuteBgm(), "BGMミュート", guiStyle.gsToggle);
                if (isMute != soundMgr.IsMuteBgm())
                {
                    soundMgr.MuteBgm(isMute);
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 2;
                rect.width *= 2;
                var label = "開始終了暗転ON";
                if (!isFreeDance)
                {
                    myGui.isFadeOn = GUI.Toggle(rect, myGui.isFadeOn, label, guiStyle.gsToggle);
                }
                else if (isFreeDance && myGui.isFadeOn)
                {
                    GUI.Label(rect, label + "ON", guiStyle.gsLabel);
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 4;
                rect.width = MyConst.GUI_WIDTH * 1.15f;
                isExportOn = GUI.Toggle(rect, isExportOn, "ダンス情報出力", guiStyle.gsToggle);
                rect.x += rect.width;
                rect.width = MyConst.GUI_WIDTH * 0.85f;
                isKaraokeOn = GUI.Toggle(rect, isKaraokeOn, "カラオケ", guiStyle.gsToggle);
                rect.x += rect.width;
                rect.width *= MyConst.GUI_WIDTH * 2;
                guiMgr.IsMaidVisibledOff = GUI.Toggle(rect, guiMgr.IsMaidVisibledOff, "自動メイド非表示OFF", guiStyle.gsToggle);

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 5;
                rect.width *= 2;
                isFixTransform = GUI.Toggle(rect, isFixTransform, "ダンス位置固定", guiStyle.gsToggle);
                if (isFixTransform)
                {
                    isAutoTransform = !isFixTransform;
                    isAnyTransform = isFixTransform;
                }
                rect.x += rect.width;
                songMgr.IsKuchipakuInfo = GUI.Toggle(rect, songMgr.IsKuchipakuInfo, "歌モード口パク文字表示", guiStyle.gsToggle);

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 6;
                rect.width *= 2;
                isAoutChangingBg = GUI.Toggle(rect, isAoutChangingBg, "背景自動切替", guiStyle.gsToggle);
                rect.x += rect.width;
                rect.width = MyConst.GUI_WIDTH * 1.3f;
                guiMgr.IsLimitY = GUI.Toggle(rect, guiMgr.IsLimitY, "カメラY位置下限", guiStyle.gsToggle);
                if (guiMgr.IsLimitY)
                {
                    rect.x += rect.width;
                    rect.width = MyConst.GUI_WIDTH * 0.7f;
                    var limit = guiMgr.LimitY;
                    guiMgr.SetNumberField(rect, 0f, ref limit);
                    guiMgr.LimitY = limit;
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 8;
                rect.x += rect.width;
                if (GUI.Button(rect, "フェードイン", guiStyle.gsButton))
                {
                    cameraMgr.FadeIn(0f);
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "設定取得", guiStyle.gsButton))
                {
                    GetSetting();
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "情報出力", guiStyle.gsButton))
                {
                    maidMgr.WriteMaidInfomationToConsole(bgMgr.GetBackgroundName());
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        private void SetFreeDanceAreaOptionSubUi()
        {
            int baseRow = 19;
            try
            {
                var rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow;
                rect.width *= 2;
                var isUiOff = guiMgr.IsOfficialUiOff;
                isUiOff = GUI.Toggle(rect, isUiOff, "公式UI OFF", guiStyle.gsToggle);
                if (isUiOff != guiMgr.IsOfficialUiOff)
                {
                    guiMgr.HideOfficialUi(isUiOff);
                }
                rect.x += rect.width;
                rect.width /= 2;
                isUiOff = guiMgr.IsOfficialGearOff;
                isUiOff = GUI.Toggle(rect, isUiOff, "ギア OFF", guiStyle.gsToggle);
                if (isUiOff != guiMgr.IsOfficialGearOff)
                {
                    guiMgr.HideOfficialGear(isUiOff);
                }
                rect.x += rect.width;
                isUiOff = guiMgr.IsOfficialFpsOff;
                isUiOff = GUI.Toggle(rect, isUiOff, "FPS OFF", guiStyle.gsToggle);
                if (isUiOff != guiMgr.IsOfficialFpsOff)
                {
                    guiMgr.HideOfficialFps(isUiOff);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        #endregion

        #region GuiDance Information
        private void SetFreeDanceAreaInformation()
        {
            int baseRow = 8;
            var pos = cameraMgr.CurrentPosition;
            var rot = cameraMgr.CurrentRotation;

            var currentTime = (isDance || isFreeDance) ? GetBgmTime() : 0f;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "BGMタイム", guiStyle.gsLabel);
            rect.x += rect.width;
            GUI.Label(rect, currentTime.ToString("F5"), guiStyle.gsLabel);
            var labelFormat = "x={0:0.00} y={1:0.00} z={2:0.00}";

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "位置座標", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 3;
            GUI.Label(rect, string.Format(labelFormat, pos.x, pos.y, pos.z), guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            GUI.Label(rect, "回転座標", guiStyle.gsLabel);
            rect.x += MyConst.GUI_WIDTH;
            rect.width = MyConst.GUI_WIDTH * 3;
            GUI.Label(rect, string.Format(labelFormat, rot.x, rot.y, rot.z), guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 3;
            GUI.Label(rect, "貼付用座標", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 3;
            labelFormat = "{0:0.00},{1:0.00},{2:0.00},{3:0.00},{4:0.00},{5:0.00}";
            var sample = string.Format(labelFormat,
                                        pos.x, pos.y, pos.z,
                                        rot.x, rot.y, rot.z);
            guiMgr.SetTextField(rect, sample);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 5;
            GUI.Label(rect, "位置調整", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 2;
            labelFormat = "x={0:0.00} y={1:0.00} z={2:0.00}";
            GUI.Label(rect, string.Format(labelFormat, adjustmentPosition.x, adjustmentPosition.y, adjustmentPosition.z), guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width = MyConst.GUI_WIDTH;
            if (GUI.Button(rect, "リセット", guiStyle.gsButton))
            {
                adjustmentPosition = Vector3.zero;
            }

            var index = 0;
            var label = new string[] { "x", "y", "z", };
            for(int i = 0; i < 3; i++)
            {
                for (int j = 0; j < 2; j++)
                {
                    var isClick = false;
                    rect = MyConst.DEFAULT_RECT;
                    rect.y *= baseRow + 6;
                    rect.x += rect.width;
                    rect.width /= 2;
                    rect.x += rect.width * index;
                    if (GUI.Button(rect, label[i] + (j == 0 ? "-" : "+"), guiStyle.gsButton))
                    {
                        isClick = true;
                    }
                    rect.y += rect.height;
                    if (GUI.RepeatButton(rect, (j == 0 ? "<<" : ">>"), guiStyle.gsButton))
                    {
                        isClick = true;
                    }
                    if (isClick)
                    {
                        var value = MyConst.ADJUST_POSITION * (j == 0 ? -1 : 1);
                        switch (i)
                        {
                            case 0:
                                adjustmentPosition.x += value;
                                break;
                            case 1:
                                adjustmentPosition.y += value;
                                break;
                            case 2:
                                adjustmentPosition.z += value;
                                break;
                        }
                    }
                    index++;
                }
            }
        }

        private void SetFreeDanceAreaOptionExportList()
        {
            int baseRow = 17;
            var file = "";
            var filter = "";
            var extention = "";
            
            guiMgr.SetZoomSlider(baseRow, ref cameraMgr);

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "リスト出力", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            if (GUI.Button(rect, "プレハブ", guiStyle.gsButton))
            {
                new FileWriter().WritePrefabList();
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "アニメ", guiStyle.gsButton))
            {
                file = MyConst.FILE_EXPORT_ANM;
                filter = "motion";
                extention = MyConst.EXTENSION_ANM;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "音声", guiStyle.gsButton))
            {
                file = MyConst.FILE_EXPORT_OGG;
                extention = MyConst.EXTENSION_OGG;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "全て", guiStyle.gsButton))
            {
                file = MyConst.FILE_EXPORT_ALL;
            }

            if (file != "")
            {
                var path = @Path.Combine(MyHelper.RootFolder, file);
                new FileWriter().WriteFileList(path, filter, extention);
            }
        }

        #endregion

        #region GuiShortCut
        private void SetShortCutArea()
        {
            int baseRow = 2;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "▼カメラ", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            if (GUI.Button(rect, "分割", guiStyle.gsButton))
            {
                guiMainMenuIndex = (int)GuiMenu.CameraLookAt;
                maidLookAt.lookAtIndex = (int)LookAtCameraType.Vertical;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "追い掛け", guiStyle.gsButton))
            {
                guiMainMenuIndex = (int)GuiMenu.CameraLookAt;
                maidLookAt.lookAtIndex = (int)LookAtCameraType.LockOn;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "座標切替", guiStyle.gsButton))
            {
                guiMainMenuIndex = (int)GuiMenu.CameraTransform;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            rect.width *= 3;
            if (GUI.Button(rect, "公式ダンスカメラモーション作成", guiStyle.gsButton))
            {
                guiMainMenuIndex = (int)GuiMenu.MaidMotion;
                guiMgr.MotionProcTypeIndex = (int)MotionProcType.Motion;
                tlPlaySet.isOfficialDance = true;
                tlWindowMgr.IsGuiOn = true;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 3;
            GUI.Label(rect, "▼メイド", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 4;
            if (GUI.Button(rect, "プリセット", guiStyle.gsButton))
            {
                guiMainMenuIndex = (int)GuiMenu.MaidDress;
                dressMgr.DressTypeIndex = (int)MaidDressType.Preset;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "脱衣", guiStyle.gsButton))
            {
                guiMainMenuIndex = (int)GuiMenu.MaidCollective;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "ぽろり", guiStyle.gsButton))
            {
                guiMainMenuIndex = (int)GuiMenu.MaidCollective;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "半脱ぎ切替", guiStyle.gsButton))
            {
                guiMainMenuIndex = (int)GuiMenu.MaidDress;
                dressMgr.DressTypeIndex = (int)MaidDressType.Porori;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 5;
            if (GUI.Button(rect, "拘束", guiStyle.gsButton))
            {
                guiMainMenuIndex = (int)GuiMenu.MaidDress;
                dressMgr.DressTypeIndex = (int)MaidDressType.Bind;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "髪", guiStyle.gsButton))
            {
                guiMainMenuIndex = (int)GuiMenu.MaidAppearance;
                guiMgr.AppearanceIndex = (int)MaidAppearanceType.Hair;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "表情", guiStyle.gsButton))
            {
                guiMainMenuIndex = (int)GuiMenu.MaidAppearance;
                guiMgr.AppearanceIndex = (int)MaidAppearanceType.Facial;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "体（くぱ）", guiStyle.gsButton))
            {
                guiMainMenuIndex = (int)GuiMenu.MaidAppearance;
                guiMgr.AppearanceIndex = (int)MaidAppearanceType.Body;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 7;
            GUI.Label(rect, "▼メニュー", guiStyle.gsLabel);
            rect.x = MyConst.DEFAULT_RECT.x;
            var index = 0;
            var menu = MyConst.MAIN_MENU_LABEL;
            for (int i = MyConst.MENU_START_INDEX; i < menu.GetLength(0); i++)
            {
                if (index > 0 && index % MyConst.MAX_COLUMN == 0 ||
                    menu[i].StartsWith(MyConst.MENU_LABEL_CHAR))
                {
                    rect.y += rect.height;
                    rect.x = MyConst.DEFAULT_RECT.x;
                    index = 0;
                }
                if (!menu[i].StartsWith(MyConst.MENU_LABEL_CHAR))
                {
                    if (GUI.Button(rect, menu[i], guiStyle.gsButton))
                    {
                        guiMainMenuIndex = i;
                    }
                    rect.x += rect.width;
                    index++;
                }
            }
        }

        #endregion

        #region GuiMaidLayout
        private void SetMaidAreaLayoutSelect()
        {
            int baseRow = 2;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "一括配置", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 2;
            isAutoTransform = GUI.Toggle(rect, isAutoTransform, "メイド一括配置自動選択", guiStyle.gsToggle);
            rect.x += rect.width;
            rect.width /= 2;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton) || MyHelper.CheckNull(maidTransformData))
            {
                ReadMaidTransformData();
            }
        }

        private void SetMaidAreaXmlData(List<Maid> maids)
        {
            int baseRow = 3;
            var labelList = new List<string>();
            foreach (var data in maidTransformData)
            {
                labelList.Add(data.label + (data.auto == 0 ? "" : "[A" + data.auto + "]"));
            }

            var index = guiMgr.SetSelectionGrid(baseRow, labelList,
                                         MyConst.GUI_HEIGHT * MyConst.GUI_MAID_TRANSFORM_ROW,
                                         ref scrollMaidXmlList);

            if (index != labelList.Count() - 1)
            {
                maidMgr.SetMaidPosition(maids, maidTransformData[index]);
            }
        }

        private void SetMaidAreaTransform(List<Maid> maids)
        {
            int baseRow = 12;
            maidMgr.GuiMaidIndex =
                    guiMgr.SetSelectedMaidButton(baseRow, maids, maidMgr.GuiMaidIndex, maidMgr);

            var maid = maids[maidMgr.GuiMaidIndex];
            if (!maidTransformDic.ContainsKey(maidMgr.GuiMaidIndex))
            {
                maidTransformDic[maidMgr.GuiMaidIndex] = maid.transform;
            }

            var tm = maidTransformDic[maidMgr.GuiMaidIndex];
            var vec = tm.position;
            guiMgr.SetPositionSlider(baseRow + 1, ref vec, Vector3.zero);
            if (vec != tm.position)
            {
                maid.transform.position = vec;
                tm.position = vec;
            }

            vec = tm.eulerAngles;
            guiMgr.SetBoneSlider(baseRow + 4, ref vec, Vector3.zero);
            if (vec != tm.eulerAngles)
            {
                maid.transform.rotation = Quaternion.Euler(vec);
                tm.rotation = Quaternion.Euler(vec);
            }

            var value = tm.localScale.z;
            value = guiMgr.SetOneLineSlider("サイズ", baseRow + 7, value,
                                            guiMgr.TransformSlider.scaleMin.z, guiMgr.TransformSlider.scaleMax.z,
                                            MyConst.SCALE_DEFAULT, MyConst.GUI_ONE_SLIDER_SMALL);
            if (value != tm.localScale.z)
            {
                tm.localScale = new Vector3(value, value, value);
                maid.transform.localScale = tm.localScale;
            }
        }

        #endregion

        #region GuiMaidCollective

        private void SetMaidAreaCollectiveTop(List<Maid> maids)
        {
            int baseRow = 2;
            maidMgr.GuiMaidIndex =
                    guiMgr.SetSelectedMaidButton(baseRow, maids, maidMgr.GuiMaidIndex, maidMgr);

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            rect.x += rect.width * 3;
            guiMgr.IsMaidAll = GUI.Toggle(rect, guiMgr.IsMaidAll, "メイド一括", guiStyle.gsToggle);
        }

        private void SetMaidAreaEyeToCam(List<Maid> maids)
        {
            int baseRow = 4;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            GUI.Label(rect, "メイド目線", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            int index = 0;
            foreach (Maid.EyeMoveType value in Enum.GetValues(typeof(Maid.EyeMoveType)))
            {
                if (index > 0 && index % MyConst.MAX_COLUMN == 0)
                {
                    rect.y += rect.height;
                    rect.x = MyConst.DEFAULT_RECT.x;
                }
                var lable = Enum.GetName(typeof(Maid.EyeMoveType), value);
                var isSelected = GUI.Toggle(rect, value == maidMgr.EyeMoveIndex, lable, guiStyle.gsToggle);
                if (isSelected && value != maidMgr.EyeMoveIndex)
                {
                    maidMgr.EyeMoveIndex = value;
                    if (!guiMgr.IsMaidAll)
                    {
                        maidMgr.SetEyeToCamera(maids[maidMgr.GuiMaidIndex], maidMgr.EyeMoveIndex);
                    }
                    else
                    {
                        foreach (var maid in maids)
                        {
                            maidMgr.SetEyeToCamera(maid, maidMgr.EyeMoveIndex);
                        }
                    }
                }
                rect.x += rect.width;
                index++;
            }
        }

        private void SetMaidAreaManualUndress(List<Maid> maids)
        {
            int baseRow = 7;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            GUI.Label(rect, "手動脱衣", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            int index = 0;
            foreach (var key in MyConst.UNDRESS_SLOT.Keys)
            {
                if (index > 0 && index % MyConst.MAX_COLUMN == 0)
                {
                    rect.y += rect.height;
                    rect.x = MyConst.DEFAULT_RECT.x;
                }
                var isUndress = GUI.Toggle(rect, dressMgr.UndressDic[key], MyConst.UNDRESS_SLOT[key], guiStyle.gsToggle);
                if (dressMgr.UndressDic[key] != isUndress)
                {
                    dressMgr.UndressDic[key] = isUndress;
                    if (!guiMgr.IsMaidAll)
                    {
                        ManualUndress(maids[maidMgr.GuiMaidIndex], key);
                    }
                    else
                    {
                        foreach (var maid in maids)
                        {
                            ManualUndress(maid, key);
                        }
                    }
                }
                rect.x += rect.width;
                index++;
            }
        }

        private void ManualUndress(Maid maid, TBody.SlotID slotId)
        {
            if (0 <= slotId)
            {
                dressMgr.UnderessAllMaid(maid, slotId, dressMgr.UndressDic[slotId]);
            }
            else
            {
                dressMgr.ShiftDeress(maid, (int)slotId, dressMgr.UndressDic[slotId]);
                switch ((int)slotId)
                {
                    case MyConst.UNDRESS_FRONT:
                        dressMgr.UndressDic[(TBody.SlotID)MyConst.UNDRESS_BACK] = false;
                        break;
                    case MyConst.UNDRESS_BACK:
                        dressMgr.UndressDic[(TBody.SlotID)MyConst.UNDRESS_FRONT] = false;
                        break;
                }
            }
        }

        private void SetMaidAreaPorori(List<Maid> maids)
        {
            int baseRow = 12;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 3;
            GUI.Label(rect, "ぽろり", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width /= 3;
            if (GUI.Button(rect, "リセット", guiStyle.gsButton))
            {
                foreach (var key in MyConst.PORORI_TAG.Keys)
                {
                    if (!guiMgr.IsMaidAll)
                    {
                        dressMgr.PororiAllMaid(maids[maidMgr.GuiMaidIndex], key, true);
                    }
                    else
                    {
                        foreach (var maid in maids)
                        {
                            dressMgr.PororiAllMaid(maid, key, true);
                        }
                    }
                }
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            int index = 0;
            foreach (var key in MyConst.PORORI_TAG.Keys)
            {
                if (index > 0 && index % MyConst.MAX_COLUMN == 0)
                {
                    rect.y += rect.height;
                    rect.x = MyConst.DEFAULT_RECT.x;
                }
                if (GUI.Button(rect, MyConst.PORORI_TAG[key], guiStyle.gsButton))
                {
                    if (!guiMgr.IsMaidAll)
                    {
                        dressMgr.PororiAllMaid(maids[maidMgr.GuiMaidIndex], key, false);
                    }
                    else
                    {
                        foreach (var maid in maids)
                        {
                            dressMgr.PororiAllMaid(maid, key, false);
                        }
                    }
                }
                rect.x += rect.width;
                index++;
            }
        }

        private void SetMaidAreaBreath(List<Maid> maids)
        {
            int baseRow = 19;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.x += rect.width * 2;
            if (GUI.Button(rect, "吐息追加", guiStyle.gsButton))
            {
                if (!guiMgr.IsMaidAll)
                {
                    extraMgr.SetBreath(maids[maidMgr.GuiMaidIndex], true);
                }
                else
                {
                    foreach (var maid in maids)
                    {
                        extraMgr.SetBreath(maid, true);
                    }
                }
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "吐息解除", guiStyle.gsButton))
            {
                if (!guiMgr.IsMaidAll)
                {
                    extraMgr.SetBreath(maids[maidMgr.GuiMaidIndex], false);
                }
                else
                {
                    foreach (var maid in maids)
                    {
                        extraMgr.SetBreath(maid, false);
                    }
                }
            }
        }
        
        #endregion

        #region GuiMaidSlot
        private void SetMaidAreaSlotNo(List<Maid> maids)
        {
            int baseRow = 3;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            rect.width *= 2;
            GUI.Label(rect, "手動変更(元番号->任意番号)", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width /= 2;
            if (GUI.Button(rect, "シャッフル", guiStyle.gsButton))
            {
                maidMgr.ShuffleMaidSlot(maids);
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "リセット", guiStyle.gsButton) || MyHelper.CheckNull(maidMgr.SlotDic))
            {
                maidMgr.ResetMaidSlot(maids);
            }

            var isUpdate = false;
            var isChanged = false;
            var dic = maidMgr.SlotDic;
            if (!MyHelper.CheckNull(dic))
            {
                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow;
                rect.width *= 4;
                rect.height = (float)Math.Ceiling(((double)maids.Count() / (double)MyConst.MAX_COLUMN)) * rect.height * 6;
                var viewRect = rect;
                viewRect.height = MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow);
                guiStyle.gsButton.margin = new RectOffset(0, 0, 0, 0);
                scrollSlot = GUI.BeginScrollView(viewRect, scrollSlot, rect, false, true);

                for (int i = 0; i < maids.Count(); i++)
                {
                    var slotNo = maidMgr.GetActiveSlotNo(maids[i]);
                    var coustomeSlotNo = slotNo;
                    if (dic.ContainsKey(slotNo))
                    {
                        coustomeSlotNo = dic[slotNo].coustomeSlotNo;
                    }
                    else
                    {
                        dic[slotNo] = maidMgr.SetMaidSlot(slotNo, slotNo);
                        isUpdate = true;
                    }
                    var ajust = baseRow + (int)Math.Floor((double)(i / MyConst.MAX_COLUMN) * 6);
                    rect = new Rect(MyConst.DEFAULT_RECT.x + MyConst.GUI_WIDTH * (i % MyConst.MAX_COLUMN),
                                    MyConst.GUI_HEIGHT * ajust,
                                    MyConst.GUI_WIDTH, MyConst.GUI_HEIGHT);
                    var card = maids[i].GetThumIcon();
                    var cardRect = rect;
                    cardRect.width = (int)(card.width * 0.75);
                    cardRect.height = (int)(card.height * 0.75);
                    GUI.DrawTexture(cardRect, card);
                    rect.y += cardRect.height;
                    rect.width /= 4;
                    if (GUI.Button(rect, "<", guiStyle.gsButton))
                    {
                        coustomeSlotNo--;
                        if (coustomeSlotNo < 0)
                        {
                            coustomeSlotNo = dic.Count() - 1;
                        }
                        isChanged = true;
                        isUpdate = true;
                    }
                    rect.x += rect.width;
                    if (GUI.Button(rect, ">", guiStyle.gsButton))
                    {
                        coustomeSlotNo++;
                        if (dic.Count() <= coustomeSlotNo)
                        {
                            coustomeSlotNo = 0;
                        }
                        isChanged = true;
                        isUpdate = true;
                    }

                    if (isChanged)
                    {
                        foreach (var key in dic.Keys)
                        {
                            var cSlotNo = dic[key].coustomeSlotNo;
                            if (cSlotNo == coustomeSlotNo)
                            {
                                dic[key] = maidMgr.SetMaidSlot(key, dic[slotNo].coustomeSlotNo);
                                break;
                            }
                        }
                        dic[slotNo] = maidMgr.SetMaidSlot(slotNo, coustomeSlotNo);
                    }

                    rect.y += MyConst.GUI_HEIGHT;
                    rect.x -= rect.width / 2;
                    rect.width = MyConst.GUI_WIDTH;
                    var label = string.Format("{0} -> {1}", slotNo, coustomeSlotNo);
                    GUI.Label(rect, label, guiStyle.gsLabel);
                }
                GUI.EndScrollView();

                if (isUpdate)
                {
                    maidMgr.SlotDic = dic;
                    maidMgr.AdjustMaidSlot();
                }
            }
        }
        #endregion

        #region GuiMaidSwing

        private void SetMaidAreaSwingTop(List<Maid> maids, int maidIndex)
        {
            var label = swingMgr.IsEachSetting ? "個別" : "共通";
            int baseRow = 2;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;

            var labels = MyConst.MAID_SWING_LABEL;
            for (int i = 0; i < labels.Count(); i++)
            {
                var isSelected = GUI.Toggle(rect, i == swingMgr.SwingIndex, labels[i], guiStyle.gsToggle);
                if (isSelected && i != swingMgr.SwingIndex)
                {
                    swingMgr.SwingIndex = i;
                }
                rect.x += rect.width;
            }
            if (GUI.Button(rect, label + "全揺適用", guiStyle.gsButton))
            {
                if (swingMgr.IsEachSetting)
                {
                    swingMgr.ReadEachMuneParameter(maids);
                    swingMgr.ReadEachHairParameter(maids, MyConst.PRE_INDEX);
                    swingMgr.ReadEachSkirtParameter(maids, MyConst.PRE_INDEX);
                }
                else
                {
                    swingMgr.ReadCommonMuneParameter(maids);
                    swingMgr.ReadCommonHairParameter(maids);
                    swingMgr.ReadCommonSkirtParameter(maids);
                }
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            if (!swingMgr.IsEachSetting ||
                swingMgr.IsEachSetting && swingMgr.SwingIndex == (int)MaidSwingType.Mune)
            {
                rect.width = rect.width * 2 / MyConst.SWING_SETTING_COUNT;

                var index = swingMgr.IsEachSetting ? swingMgr.MuneSettingIndex : swingMgr.CommonSaveIndex;
                for (int i = 0; i < MyConst.SWING_SETTING_COUNT; i++)
                {
                    var isSelected = GUI.Toggle(rect, index == i, i.ToString(), guiStyle.gsToggle);
                    if (isSelected)
                    {
                        index = i;
                        if (swingMgr.IsEachSetting)
                        {
                            swingMgr.MuneSettingIndex = index;
                        }
                        else
                        {
                            swingMgr.CommonSaveIndex = index;
                        }
                    }
                    rect.x += rect.width;
                }
            }
            else
            {
                rect.x += rect.width * 2;
            }

            rect.width = MyConst.GUI_WIDTH;
            if (GUI.Button(rect, label + "読込", guiStyle.gsButton))
            {
                switch (swingMgr.SwingIndex)
                {
                    case (int)MaidSwingType.Mune:
                        if (swingMgr.IsEachSetting)
                        {
                            swingMgr.ReadEachMuneParameter(maids);
                        }
                        else
                        {
                            swingMgr.ReadCommonMuneParameter(maids);
                        }
                        break;

                    case (int)MaidSwingType.Hair:
                        if (swingMgr.IsEachSetting)
                        {
                            swingMgr.ReadEachHairParameter(maids, maidIndex);
                        }
                        else
                        {
                            swingMgr.ReadCommonHairParameter(maids);
                        }
                        break;

                    case (int)MaidSwingType.Skirt:
                        if (swingMgr.IsEachSetting)
                        {
                            swingMgr.ReadEachSkirtParameter(maids, maidIndex);
                        }
                        else
                        {
                            swingMgr.ReadCommonSkirtParameter(maids);
                        }
                        break;
                }
            }
            rect.x += rect.width;
            if (GUI.Button(rect, label + "保存", guiStyle.gsButton))
            {
                switch (swingMgr.SwingIndex)
                {
                    case (int)MaidSwingType.Mune:
                        if (swingMgr.IsEachSetting)
                        {
                            swingMgr.SaveEachMuneParameter();
                        }
                        else
                        {
                            swingMgr.SaveCommonMuneParameter();
                        }
                        break;

                    case (int)MaidSwingType.Hair:
                        if (swingMgr.IsEachSetting)
                        {
                            swingMgr.SaveEachHairParameter(maids[maidIndex]);
                        }
                        else
                        {
                            swingMgr.SaveCommonHairParameter();
                        }
                        break;

                    case (int)MaidSwingType.Skirt:
                        if (swingMgr.IsEachSetting)
                        {
                            swingMgr.SaveEachSkirtParameter(maids[maidIndex]);
                        }
                        else
                        {
                            swingMgr.SaveCommonSkirtParameter();
                        }
                        break;
                }
            }            

            if (swingMgr.IsEachSetting)
            {
                maidMgr.GuiMaidIndex =
                    guiMgr.SetSelectedMaidButton(baseRow + 2, maids, maidMgr.GuiMaidIndex, maidMgr);
            }

            var row = 0;
            if (swingMgr.IsEachSetting)
            {
                if(swingMgr.SwingIndex == (int)MaidSwingType.Mune)
                {
                    row += 2;
                }
                else
                {
                    row -= 1;
                }
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2 + row;
            if (GUI.Button(rect, label + "リセット", guiStyle.gsButton))
            {
                switch (swingMgr.SwingIndex)
                {
                    case (int)MaidSwingType.Mune:
                        swingMgr.ResetMuneParameter(maids[maidIndex]);
                        break;

                    case (int)MaidSwingType.Hair:
                        swingMgr.ResetHairParameter(maids);
                        break;

                    case (int)MaidSwingType.Skirt:
                        if (!maidMgr.IsMultipleMaids)
                        {
                            swingMgr.ResetSkirtParameter(maids);
                        }
                        break;
                }
            }

        }

        private void SetMaidAreaSwingMune(List<Maid> maids, int maidIndex)
        {
            int baseRow = 5;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;

            int index;
            MaidMuneSet data;
            if (swingMgr.IsEachSetting)
            {
                if (MyHelper.CheckNull(swingMgr.EachMuneData))
                {
                    return;
                }
                index = swingMgr.MuneSettingIndex;
                data = swingMgr.EachMuneData[index];
            }
            else
            {
                if (MyHelper.CheckNull(swingMgr.CommonMuneData))
                {
                    return;
                }
                index = swingMgr.CommonSaveIndex;
                data = swingMgr.CommonMuneData[index];
            }

            if (swingMgr.IsEachSetting)
            {
                rect.width *= 2;
                GUI.Label(rect, "　サイズ範囲(from->to)", guiStyle.gsLabel);
                rect.x += rect.width;
                rect.width /= 2;
                guiMgr.SetNumberField(rect, data.minSize, ref data.minSize);
                rect.x += rect.width;
                guiMgr.SetNumberField(rect, data.maxSize, ref data.maxSize);
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            rect.x += rect.width * 3;
            swingMgr.IsInstant = GUI.Toggle(rect, swingMgr.IsInstant, "即時反映", guiStyle.gsToggle);
            data = SetSwingMune(maids, maidIndex, baseRow + 2, data);

            if (swingMgr.IsEachSetting)
            {
                swingMgr.EachMuneData[index] = data;
            }
            else
            {
                swingMgr.CommonMuneData[index] = data;
            }
        }

        private MaidMuneSet SetSwingMune(List<Maid> maids, int maidIndex, int baseRow, MaidMuneSet muneData)
        {
            foreach (int i in Enum.GetValues(typeof(MaidMuneParam)))
            {
                var value = 0f;
                var sliderDefault = 0f;
                var sliderMax = MyConst.SWING_COMMON_MAX;

                switch (i)
                {
                    case (int)MaidMuneParam.Gravity:
                        value = muneData.gravity;
                        sliderDefault = MyConst.MUNE_GRAVITY_DEFAULT;
                        sliderMax = MyConst.MUNE_GRAVITY_MAX;
                        break;
                    case (int)MaidMuneParam.Damping:
                        value = muneData.damping;
                        sliderDefault = MyConst.MUNE_DAMPING_DEFAULT;
                        break;
                    case (int)MaidMuneParam.Yawaraka:
                        value = muneData.yawaraka;
                        sliderDefault = MyConst.MUNE_YAWARAKA_DEFAULT;
                        break;
                    case (int)MaidMuneParam.MaxStiffness:
                        value = muneData.maxStiffness;
                        sliderDefault = MyConst.MUNE_MAX_STIFFNESS_DEFAULT;
                        break;
                    case (int)MaidMuneParam.MinStiffness:
                        value = muneData.minStiffness;
                        sliderDefault = MyConst.MUNE_MIN_STIFFNESS_DEFAULT;
                        break;
                    case (int)MaidMuneParam.MaxStiffnessBra:
                        value = muneData.maxStiffnessBra;
                        sliderDefault = MyConst.MUNE_MAX_STIFFNESS_BRA_DEFAULT;
                        break;
                    case (int)MaidMuneParam.MinStiffnessBra:
                        value = muneData.minStiffnessBra;
                        sliderDefault = MyConst.MUNE_MIN_STIFFNESS_BRA_DEFAULT;
                        break;
                }

                var isChanged = SetMuneSlider(baseRow + i, MyConst.MAID_MUNE_PARAM_LABEL[i], MyConst.SWING_COMMON_MIN, sliderMax, sliderDefault, ref value);
                if (isChanged)
                {
                    if (swingMgr.IsEachSetting)
                    {
                        SetJiggleBone(maids[maidIndex], value, i, ref muneData);
                    }
                    else
                    {
                        foreach (var maid in maids)
                        {
                            SetJiggleBone(maid, value, i, ref muneData);
                        }
                    }
                }
            }
            return muneData;
        }

        private bool SetMuneSlider(int baseRow, string label,
                                   float sliderMin, float sliderMax, float sliderDefault, ref float value)
        {
            var isChanged = false;
            var val = value;
            val = guiMgr.SetOneLineSlider(label, baseRow, val, sliderMin, sliderMax, sliderDefault, MyConst.GUI_ONE_SLIDER_SMALL);
            if (val != value)
            {
                value = val;
                isChanged = true;
            }
            return isChanged;
        }
        
        private void SetJiggleBone(Maid maid, float value, int index, ref MaidMuneSet muneData)
        {
            var muneL = maid.body0.jbMuneL;
            var muneR = maid.body0.jbMuneR;
            if (!swingMgr.IsInstant)
            {
                muneL = new jiggleBone();
                muneR = new jiggleBone();
            }

            switch (index)
            {
                case (int)MaidMuneParam.Gravity:
                    muneL.bGravity = value;
                    muneR.bGravity = value;
                    muneData.gravity = value;
                    break;
                case (int)MaidMuneParam.Damping:
                    muneL.bDamping = value;
                    muneR.bDamping = value;
                    muneData.damping = value;
                    break;
                case (int)MaidMuneParam.Yawaraka:
                    muneL.m_fMuneYawaraka = value;
                    muneR.m_fMuneYawaraka = value;
                    muneData.yawaraka = value;
                    break;
                case (int)MaidMuneParam.MaxStiffness:
                    muneL.bStiffness[0] = value;
                    muneR.bStiffness[0] = value;
                    muneData.maxStiffness = value;
                    break;
                case (int)MaidMuneParam.MinStiffness:
                    muneL.bStiffness[1] = value;
                    muneR.bStiffness[1] = value;
                    muneData.minStiffness = value;
                    break;
                case (int)MaidMuneParam.MaxStiffnessBra:
                    muneL.bStiffnessBRA[0] = value;
                    muneR.bStiffnessBRA[0] = value;
                    muneData.maxStiffnessBra = value;
                    break;
                case (int)MaidMuneParam.MinStiffnessBra:
                    muneL.bStiffnessBRA[1] = value;
                    muneR.bStiffnessBRA[1] = value;
                    muneData.minStiffnessBra = value;
                    break;
            }
        }

        private void SetMaidAreaSwingHair(List<Maid> maids, int maidIndex)
        {
            int baseRow = 5;

            Dictionary<TBody.SlotID, DynamicBone> bone;
            if (swingMgr.IsEachSetting)
            {
                bone = swingMgr.GetHairBone(maids[maidIndex]);
            }
            else
            {
                bone = swingMgr.CommonHairData[swingMgr.CommonSaveIndex];
            }
            if (MyHelper.CheckNull(bone))
            {
                return;
            }

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 4;
            var cnt = bone.Count() * (MyConst.MAID_HAIR_PARAM_LABEL.Count() + 1);
            rect.height = cnt * rect.height;
            var viewRect = rect;
            viewRect.height = MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow);
            guiStyle.gsButton.margin = new RectOffset(0, 0, 0, 0);
            scrollMaidHair = GUI.BeginScrollView(viewRect, scrollMaidHair, rect, false, true);

            var row = baseRow;
            foreach (var slot in bone.Keys)
            {
                rect.y = MyConst.GUI_HEIGHT * row;
                GUI.Label(rect, MyConst.HAIR_SLOT[slot], guiStyle.gsLabel);
                row++;
                var sliderDefault = 0f;
                var sliderMax = MyConst.SWING_COMMON_MAX;
                for (int i = 0; i < MyConst.MAID_HAIR_PARAM_LABEL.Count(); i++)
                {
                    var value = 0f;
                    switch (i)
                    {
                        case (int)MaidHairParam.Damping:
                            value = bone[slot].m_Damping;
                            sliderDefault = MyConst.HAIR_DAMPING_DEFAULT;
                            break;
                        case (int)MaidHairParam.Elasticity:
                            value = bone[slot].m_Elasticity;
                            sliderDefault = slot == TBody.SlotID.hairAho ? MyConst.HAIR_ELASTICITY_AHO_DEFAULT : MyConst.HAIR_ELASTICITY_DEFAULT;
                            break;
                        case (int)MaidHairParam.Stiffness:
                            value = bone[slot].m_Stiffness;
                            sliderDefault = MyConst.HAIR_STIFFNESS_DEFAULT;
                            break;
                        case (int)MaidHairParam.Inert:
                            value = bone[slot].m_Inert;
                            sliderDefault = MyConst.SWING_COMMON_MIN;
                            break;
                        case (int)MaidHairParam.Radius:
                            value = bone[slot].m_Radius;
                            sliderDefault = MyConst.HAIR_RADIUS_DEFAULT;
                            sliderMax = MyConst.HAIR_RADIUS_MAX;
                            break;
                    }

                    var isChanged = SetMuneSlider(row, MyConst.MAID_HAIR_PARAM_LABEL[i], MyConst.SWING_COMMON_MIN, sliderMax, sliderDefault, ref value);
                    if (isChanged)
                    {
                        if (swingMgr.IsEachSetting)
                        {
                            swingMgr.SetGuiHairBone(bone[slot], value, i);
                        }
                        else
                        {
                            foreach (var maid in maids)
                            {
                                var b = swingMgr.GetHairBone(maid);
                                if (!MyHelper.CheckNull(b))
                                {
                                    if (b.ContainsKey(slot))
                                    {
                                        swingMgr.SetGuiHairBone(b[slot], value, i);
                                    }
                                }
                            }
                            switch (i)
                            {
                                case (int)MaidHairParam.Damping:
                                    bone[slot].m_Damping = value;
                                    break;
                                case (int)MaidHairParam.Elasticity:
                                    bone[slot].m_Elasticity = value;
                                    break;
                                case (int)MaidHairParam.Stiffness:
                                    bone[slot].m_Stiffness = value;
                                    break;
                                case (int)MaidHairParam.Inert:
                                    bone[slot].m_Inert = value;
                                    break;
                                case (int)MaidHairParam.Radius:
                                    bone[slot].m_Radius = value;
                                    break;
                            }
                            swingMgr.CommonHairData[swingMgr.CommonSaveIndex] = bone;
                        }
                    }
                    row++;
                }
            }
            GUI.EndScrollView();
        }

        private void SetMaidAreaSwingSkirtMultipleMaids()
        {
            int baseRow = 6;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 4;
            GUI.Label(rect, "※複数メイドプラグインチェック時は干渉するため機能無効", guiStyle.gsLabel);
        }

        private void SetMaidAreaSwingSkirt(List<Maid> maids, int maidIndex)
        {
            int baseRow = 5;

            Dictionary<TBody.SlotID, DynamicSkirtBone> bone;
            if (swingMgr.IsEachSetting)
            {
                bone = swingMgr.GetSkirtBone(maids[maidIndex]);
            }
            else
            {
                bone = swingMgr.CommonSkirtData[swingMgr.CommonSaveIndex];
            }
            if (MyHelper.CheckNull(bone))
            {
                return;
            }

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 4;
            var cnt = bone.Count() * (MyConst.MAID_SKIRT_PARAM_LABEL.Count() + 1);
            rect.height = cnt * rect.height;
            var viewRect = rect;
            viewRect.height = MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow);
            guiStyle.gsButton.margin = new RectOffset(0, 0, 0, 0);
            scrollMaidSkirt = GUI.BeginScrollView(viewRect, scrollMaidSkirt, rect, false, true);

            var row = baseRow;
            foreach (var slot in bone.Keys)
            {
                rect = MyConst.DEFAULT_RECT;
                rect.y = MyConst.GUI_HEIGHT * row;
                GUI.Label(rect, MyConst.SKIRT_SLOT[slot], guiStyle.gsLabel);
                rect.x += rect.width * 3;
                swingMgr.GuiIsTemp = GUI.Toggle(rect, swingMgr.GuiIsTemp, "仮衣装保存", guiStyle.gsToggle);
                row++;

                var sliderDefault = 0.5f;
                var sliderMax = MyConst.SWING_COMMON_MAX;
                for (int i = 0; i < MyConst.MAID_SKIRT_PARAM_LABEL.Count(); i++)
                {
                    var value = 0f;
                    switch (i)
                    {
                        case (int)MaidSkirtParam.Radius:
                            value = bone[slot].m_fPanierRadius;
                            sliderDefault = MyConst.SKIRT_RADIUS_DEFAULT;
                            break;
                        case (int)MaidSkirtParam.Velocity:
                            value = bone[slot].m_fVelocityForceRate;
                            sliderDefault = MyConst.SKIRT_VELOCITY_DEFAULT;
                            break;
                        case (int)MaidSkirtParam.Force:
                            value = bone[slot].m_fPanierForce;
                            sliderDefault = MyConst.SKIRT_FORCE_DEFAULT;
                            break;
                        case (int)MaidSkirtParam.RegRadius:
                            value = bone[slot].m_fRegDefaultRadius;
                            sliderDefault = MyConst.SKIRT_REG_RADIUS_DEFAULT;
                            break;
                        case (int)MaidSkirtParam.Stiffness:
                            value = bone[slot].m_fPanierStiffnessRate;
                            sliderDefault = MyConst.SKIRT_STIFFNESS_DEFAULT;
                            break;
                        case (int)MaidSkirtParam.Stress:
                            value = bone[slot].m_fPanierStressForce;
                            sliderDefault = MyConst.SKIRT_STRESS_DEFAULT;
                            break;
                        case (int)MaidSkirtParam.Threshold:
                            value = bone[slot].m_fPanierForceDistanceThreshold;
                            sliderDefault = MyConst.SKIRT_THRESHOLD_DEFAULT;
                            break;
                    }

                    var isChanged = SetMuneSlider(row, MyConst.MAID_SKIRT_PARAM_LABEL[i], MyConst.SWING_COMMON_MIN, sliderMax, sliderDefault, ref value);
                    if (isChanged)
                    {
                        if (swingMgr.IsEachSetting)
                        {
                            swingMgr.SetGuiSkirtBone(bone[slot], value, i);
                        }
                        else
                        {
                            foreach (var maid in maids)
                            {
                                var b = swingMgr.GetSkirtBone(maid);
                                if (!MyHelper.CheckNull(b))
                                {
                                    if (b.ContainsKey(slot))
                                    {
                                        swingMgr.SetGuiSkirtBone(b[slot], value, i);
                                    }
                                }
                            }
                            switch (i)
                            {
                                case (int)MaidSkirtParam.Radius:
                                    bone[slot].m_fPanierRadius = value;
                                    break;
                                case (int)MaidSkirtParam.Velocity:
                                    bone[slot].m_fVelocityForceRate = value;
                                    break;
                                case (int)MaidSkirtParam.Force:
                                    bone[slot].m_fPanierForce = value;
                                    break;
                                case (int)MaidSkirtParam.RegRadius:
                                    bone[slot].m_fRegDefaultRadius = value;
                                    break;
                                case (int)MaidSkirtParam.Stiffness:
                                    bone[slot].m_fPanierStiffnessRate = value;
                                    break;
                                case (int)MaidSkirtParam.Stress:
                                    bone[slot].m_fPanierStressForce = value;
                                    break;
                                case (int)MaidSkirtParam.Threshold:
                                    bone[slot].m_fPanierForceDistanceThreshold = value;
                                    break;
                            }
                            swingMgr.CommonSkirtData[swingMgr.CommonSaveIndex] = bone;
                        }
                    }
                    row++;
                }
            }
            GUI.EndScrollView();
        }

        #endregion

        #region GuiMaidDress
        private void SetMaidAreaDressTop(List<Maid> maids, int maidIndex)
        {
            int baseRow = 2;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            var parts = MyConst.MAID_DRESS_LABEL;
            for (int i = 0; i < parts.Count(); i++)
            {
                if(i == MyConst.MAX_COLUMN)
                {
                    rect = MyConst.DEFAULT_RECT;
                    rect.y *= baseRow + 1;
                }
                var isSelected = GUI.Toggle(rect, i == dressMgr.DressTypeIndex, parts[i], guiStyle.gsToggle);
                if (isSelected && i != dressMgr.DressTypeIndex)
                {
                    dressMgr.DressTypeIndex = i;
                }
                rect.x += rect.width;
            }

            rect.x += rect.width * 2;
            dressMgr.IsMaidAll = GUI.Toggle(rect, dressMgr.IsMaidAll, "メイド一括", guiStyle.gsToggle);

            maidMgr.GuiMaidIndex =
                guiMgr.SetSelectedMaidButton(baseRow + 2, maids, maidIndex, maidMgr);
        }

        private void SetMaidAreaDressGroup(List<Maid> maids)
        {
            int baseRow = 5;
            try
            {
                if (MyHelper.CheckNull(dressMgr.DressGroupList))
                {
                    dressMgr.GetDressGroupList();
                }

                var rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow;
                GUI.Label(rect, "衣装グループ", guiStyle.gsLabel);
                var dressGroupIndex = dressMgr.DressGroupIndex;
                guiMgr.SetIndexChangedButton(ref rect, dressMgr.DressGroupList.Count(), ref dressGroupIndex);
                guiMgr.SetIndexChangedLabel(rect, dressMgr.DressGroupList[dressGroupIndex]);
                dressMgr.DressGroupIndex = dressGroupIndex;

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 1;
                GUI.Label(rect, "適用方法", guiStyle.gsLabel);
                rect.x += rect.width;
                if (GUI.Button(rect, "メイド指定", guiStyle.gsButton) && !MyHelper.CheckNull(dressMgr.DressGroupList))
                {
                    dressMgr.SetDanceGroupDress(maids);
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "リスト順", guiStyle.gsButton) && !MyHelper.CheckNull(dressMgr.DressGroupList))
                {
                    dressMgr.SetDanceOderGroupDress(maids);
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "ランダム", guiStyle.gsButton) && !MyHelper.CheckNull(dressMgr.DressGroupList))
                {
                    dressMgr.SetDanceRandomGroupDress(maids);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        private void SetMaidAreaDressList(List<Maid> maids, int maidIndex)
        {
            int baseRow = 9;
            var text = guiMgr.DressLabel;
            var isClick = guiMgr.SetSaveField(baseRow - 2, ref text);
            guiMgr.DressLabel = text;
            if (isClick && !string.IsNullOrEmpty(text))
            {
                new FileWriter().WriteDressList(dressMgr.DressDic, text);
                dressMgr.GetDressList();
            }

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            GUI.Label(rect, "衣装リスト", guiStyle.gsLabel);
            rect.x += rect.width * 3;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton) || MyHelper.CheckNull(dressMgr.DressList))
            {
                dressMgr.GetDressList();
                dressMgr.GetDressGroupList();
            }

            var index = guiMgr.SetSelectionGrid(baseRow, dressMgr.DressList,
                                         MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow),
                                         ref scrollDressList);
            if (index != dressMgr.DressList.Count() - 1)
            {
                dressMgr.SetListDress(maids, maidIndex, dressMgr.DressList[index]);
            }
        }

        private void SetMaidAreaDressTemp(List<Maid> maids, int maidIndex)
        {
            int baseRow = 7;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 2;
            rect.x += rect.width;
            if (GUI.Button(rect, "元取得", guiStyle.gsButton))
            {
                dressMgr.GetDressAllFileName(maids[maidIndex], false);
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "仮取得", guiStyle.gsButton))
            {
                dressMgr.GetDressAllFileName(maids[maidIndex], true);
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "クリア", guiStyle.gsButton))
            {
                dressMgr.ClearDressDicFileName();
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            rect.x += rect.width;
            var isSetAll = (GUI.Button(rect, "全適用", guiStyle.gsButton));
            rect.x += rect.width;
            var isDelAll = (GUI.Button(rect, "全解除", guiStyle.gsButton));
            rect.x += rect.width;
            if (GUI.Button(rect, "初期化", guiStyle.gsButton))
            {
                if (dressMgr.IsMaidAll)
                {
                    dressMgr.ResetDressMenu(maids);
                }
                else
                {
                    dressMgr.ResetDressMenu(maids[maidIndex]);
                }
                dressMgr.GetDressAllFileName(maids[maidIndex], false);
            }

            if (!MyHelper.CheckNull(dressMgr.DressDic))
            {
                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow;
                rect.width *= 4;
                rect.height = MyConst.DRESS_TAG.Count() * rect.height;
                var viewRect = rect;
                viewRect.height = MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow);
                guiStyle.gsButton.margin = new RectOffset(0, 0, 0, 0);
                scrollDressTemp = GUI.BeginScrollView(viewRect, scrollDressTemp, rect, false, true);
                var i = 0;
                foreach (var key in MyConst.DRESS_TAG.Keys)
                {
                    var text = dressMgr.DressDic[key];

                    rect = MyConst.DEFAULT_RECT;
                    rect.y *= baseRow + i;
                    GUI.Label(rect, MyConst.DRESS_TAG[key], guiStyle.gsLabel);
                    rect.x += rect.width;
                    rect.width *= 2;
                    text = guiMgr.SetTextField(rect, text);
                    rect.x += rect.width;
                    rect.width /= 4;
                    if ((GUI.Button(rect, "適用", guiStyle.gsButton) || isSetAll) &&
                        !string.IsNullOrEmpty(text))
                    {
                        dressMgr.SetTempDress(maids, maidIndex, key, text);
                    }
                    rect.x += rect.width;
                    if (GUI.Button(rect, "解除", guiStyle.gsButton) || isDelAll)
                    {
                        dressMgr.SetTempDress(maids, maidIndex, key, "");
                    }

                    dressMgr.DressDic[key] = text;
                    i++;
                }
                GUI.EndScrollView();
            }
        }

        private void SetMaidAreaPresetList(List<Maid> maids, int maidIndex)
        {
            int baseRow = 6;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            rect.width *= 3;
            isMaidPresetSave = GUI.Toggle(rect, isMaidPresetSave, "変更前服プリセット保存", guiStyle.gsToggle);
            rect.x += rect.width;
            rect.width /= 3;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton))
            {
                presetData = GameMain.Instance.CharacterMgr.PresetListLoad();
                presetData = presetData.FindAll(p => p.ePreType == CharacterMgr.PresetType.Wear);
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 4;
            if (MyHelper.CheckNull(presetData))
            {
                GUI.Label(rect, "リスト取得（服プリセットデータ）を実行でください。", guiStyle.gsLabel);
            }
            else
            {
                rect.height = (1 + (int)presetData.Count() / 4) * MyConst.GUI_HEIGHT * 4;
                var viewRect = rect;
                viewRect.height = MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow);
                scrollPreset = GUI.BeginScrollView(viewRect, scrollPreset, rect, false, true);
                for (int i = 0; i < presetData.Count(); i++)
                {
                    var ajust = baseRow + (int)Math.Floor((double)(i / MyConst.MAX_COLUMN) * 4);
                    rect = new Rect(MyConst.DEFAULT_RECT.x + MyConst.GUI_WIDTH * (i % MyConst.MAX_COLUMN),
                                    MyConst.GUI_HEIGHT * ajust,
                                    MyConst.GUI_WIDTH, MyConst.GUI_HEIGHT * 4);
                    if (presetWaitTime == 0f && GUI.Button(rect, presetData[i].texThum))
                    {
                        myGui.isGuiOn = false;
                        presetWaitTime = MyConst.PRESET_WAIT_TIME;
                        if (dressMgr.IsMaidAll)
                        {
                            foreach (var maid in maids)
                            {
                                dressMgr.SetWearPreset(presetData[i], isMaidPresetSave, maid);
                            }
                        }
                        else
                        {
                            dressMgr.SetWearPreset(presetData[i], isMaidPresetSave, maids[maidIndex]);
                        }
                        break;
                    }
                }
                GUI.EndScrollView();
            }
        }

        private void SetMaidAreaDressPorori(List<Maid> maids, int maidIndex)
        {
            int baseRow = 5;
            if (!MyHelper.CheckNull(dressMgr.MenuData.fileNameList))
            {
                var rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow;
                rect.width *= 3;
                GUI.Label(rect, "選択リスト： " + dressMgr.MenuData.label, guiStyle.gsLabel);
                rect.x += rect.width;
                rect.width /= 3;
                if (GUI.Button(rect, "切替", guiStyle.gsButton))
                {
                    SetMaidAreaDressMenuChange(maids, maidIndex);
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 1;
                GUI.Label(rect, "メニュー選択", guiStyle.gsLabel);
                var dressMenuIndex = dressMgr.DressMenuIndex;
                guiMgr.SetIndexChangedButton(ref rect, dressMgr.MenuData.fileNameList.Count(), ref dressMenuIndex);
                guiMgr.SetIndexChangedLabel(rect, dressMgr.MenuData.fileNameList[dressMenuIndex]);
                dressMgr.DressMenuIndex = dressMenuIndex;

            }
        }

        private void SetMaidAreaDressPororiList(List<Maid> maids, int maidIndex)
        {
            int baseRow = 8;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            rect.width *= 3;
            GUI.Label(rect, "メニューリスト", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width /= 3;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton) || MyHelper.CheckNull(dressMgr.DressMenuList))
            {
                dressMgr.GetDressMenuList();
            }

            var index = guiMgr.SetSelectionGrid(baseRow, dressMgr.DressMenuList,
                                         MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow),
                                         ref scrollDressPororiList);
            if (index != dressMgr.DressMenuList.Count() - 1)
            {
                dressMgr.GetDressMenuData(dressMgr.DressMenuList[index]);
                SetMaidAreaDressMenuChange(maids, maidIndex);
            }
        }
        private void SetMaidAreaDressMenuChange(List<Maid> maids, int maidIndex)
        {
            if (!MyHelper.CheckNull(dressMgr.MenuData.fileNameList))
            {
                var isChanged = dressMgr.SetTempDress(maids, maidIndex, dressMgr.MenuData.type, dressMgr.MenuData.fileNameList[dressMgr.DressMenuIndex]);
                if (isChanged)
                {
                    dressMgr.DressMenuIndex++;
                    if (dressMgr.MenuData.fileNameList.Count() <= dressMgr.DressMenuIndex)
                    {
                        dressMgr.DressMenuIndex = 0;
                    }
                }
            }
        }

        private void SetMaidAreaDressBind(List<Maid> maids, int maidIndex)
        {
            int baseRow = 5;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            dressMgr.IsBind = GUI.Toggle(rect, dressMgr.IsBind, "有効", guiStyle.gsToggle);
            rect.x += rect.width * 2;
            if (GUI.Button(rect, "サンプル出力", guiStyle.gsButton))
            {
                dressMgr.WriteSample(maids[maidIndex]);
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "解除", guiStyle.gsButton))
            {
                if (dressMgr.BindSlotDic.Count() == 1 || dressMgr.IsMaidAll)
                {
                    dressMgr.ClearBindSlotData();
                }
                else
                {
                    var slotNo = maidMgr.GetActiveSlotNo(maids[maidIndex]);
                    dressMgr.BindSlotDic.Remove(slotNo);
                }
                if (dressMgr.IsMaidAll)
                {
                    dressMgr.ResetDressMenu(maids);
                }
                else
                {
                    dressMgr.ResetDressMenu(maids[maidIndex]);
                }
            }
        }

        private void SetMaidAreaDressBindList(List<Maid> maids, int maidIndex)
        {
            int baseRow = 7;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            rect.width *= 3;
            GUI.Label(rect, "拘束リスト", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width /= 3;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton) || MyHelper.CheckNull(dressMgr.BindDic))
            {
                dressMgr.ReadBindData();
            }

            var labels = dressMgr.BindDic.Keys.ToList();
            labels.Add("");
            var index = guiMgr.SetSelectionGrid(baseRow, labels,
                                         MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow),
                                         ref scrollDressBindList);
            if (index != labels.Count() - 1)
            {
                var ms = new List<Maid>();
                if (!dressMgr.IsMaidAll)
                {
                    ms.Add(maids[maidIndex]);
                }
                else
                {
                    ms = maids;
                }
                foreach(var maid in ms)
                {
                    var slotNo = maidMgr.GetActiveSlotNo(maid);
                    dressMgr.BindSlotDic[slotNo] = labels[index];
                    dressMgr.SetBindData(maid, slotNo, false);
                }
            }
        }
        #endregion

        #region GuiMaidAppearance
        private void SetMaidAreaAppearanceTop(List<Maid> maids)
        {
            int baseRow = 2;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            var labels = MyConst.MAID_APPEARANCE_LABEL;
            for (int i = 0; i < labels.Count(); i++)
            {
                var isSelected = GUI.Toggle(rect, i == guiMgr.AppearanceIndex, labels[i], guiStyle.gsToggle);
                if (isSelected && i != guiMgr.AppearanceIndex)
                {
                    guiMgr.AppearanceIndex = i;
                }
                rect.x += rect.width;
            }
            guiMgr.IsMaidAppearanceAll = GUI.Toggle(rect, guiMgr.IsMaidAppearanceAll, "メイド一括", guiStyle.gsToggle);

            maidMgr.GuiMaidIndex =
                guiMgr.SetSelectedMaidButton(baseRow + 1, maids, maidMgr.GuiMaidIndex, maidMgr);

            var slotNo = maidMgr.GetActiveSlotNo(maids[maidMgr.GuiMaidIndex]);
            maidMgr.InitializeFacialSet(slotNo);
        }

        private void SetMaidAreaHairTemp(List<Maid> maids, int maidIndex)
        {
            int baseRow = 6;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 2;
            rect.x += rect.width;
            if (GUI.Button(rect, "元取得", guiStyle.gsButton))
            {
                hairMgr.GetHairMenuAllFileName(maids[maidIndex], false);
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "仮取得", guiStyle.gsButton))
            {
                hairMgr.GetHairMenuAllFileName(maids[maidIndex], true);
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "クリア", guiStyle.gsButton))
            {
                hairMgr.ClearHairMenuDicFileName();
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            rect.x += rect.width;
            var isSetAll = (GUI.Button(rect, "全適用", guiStyle.gsButton));
            rect.x += rect.width;
            var isDelAll = (GUI.Button(rect, "全解除", guiStyle.gsButton));
            rect.x += rect.width;
            if (GUI.Button(rect, "初期化", guiStyle.gsButton))
            {
                if (guiMgr.IsMaidAppearanceAll)
                {
                    hairMgr.ResetHairMenu(maids);
                }
                else
                {
                    hairMgr.ResetHairMenu(maids[maidIndex]);
                }
                hairMgr.GetHairMenuAllFileName(maids[maidIndex], false);
            }

            if (!MyHelper.CheckNull(hairMgr.HairMenuDic))
            {
                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow;
                rect.width *= 4;
                var i = 0;
                foreach (var key in MyConst.HAIR_TAG.Keys)
                {
                    var text = hairMgr.HairMenuDic[key];
                    rect = MyConst.DEFAULT_RECT;
                    rect.y *= baseRow + i;
                    GUI.Label(rect, MyConst.HAIR_TAG[key], guiStyle.gsLabel);
                    rect.x += rect.width;
                    rect.width *= 2;
                    text = guiMgr.SetTextField(rect, text);
                    rect.x += rect.width;
                    rect.width /= 4;
                    if ((GUI.Button(rect, "適用", guiStyle.gsButton) || isSetAll) &&
                        !string.IsNullOrEmpty(text))
                    {
                        hairMgr.SetTempHairMenu(maids, maidIndex, key, text, guiMgr.IsMaidAppearanceAll);
                    }
                    rect.x += rect.width;
                    if (key != MyConst.HAIR_F && key != MyConst.HAIR_R)
                    {
                        if (GUI.Button(rect, "解除", guiStyle.gsButton) || isDelAll)
                        {
                            hairMgr.SetTempHairMenu(maids, maidIndex, key, "", guiMgr.IsMaidAppearanceAll);
                        }
                    }
                    hairMgr.HairMenuDic[key] = text;
                    i++;
                }
            }
        }

        private void SetMaidAreaHairList(List<Maid> maids, int maidIndex)
        {
            int baseRow = 14;
            var text = guiMgr.HairMenuLabel;
            var isClick = guiMgr.SetSaveField(baseRow - 2, ref text);
            guiMgr.HairMenuLabel = text;
            if (isClick && !string.IsNullOrEmpty(text))
            {
                new FileWriter().WriteHairMenuList(hairMgr.HairMenuDic, text);
                hairMgr.GetHairMenuList();
            }

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            GUI.Label(rect, "髪リスト", guiStyle.gsLabel);
            rect.x += rect.width * 3;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton) || MyHelper.CheckNull(hairMgr.HairMenuList))
            {
                hairMgr.GetHairMenuList();
            }

            var index = guiMgr.SetSelectionGrid(baseRow, hairMgr.HairMenuList,
                                         MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow),
                                         ref scrollHairMenuList);
            if (index != hairMgr.HairMenuList.Count() - 1)
            {
                hairMgr.SetListHairMenu(maids, maidIndex, hairMgr.HairMenuList[index], guiMgr.IsMaidAppearanceAll);
            }
        }

        private void SetMaidAreaBody(List<Maid> maids, int maidIndex)
        {
            int baseRow = 5;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            rect.width *= 2;
            GUI.Label(rect, "体（一部部位）", guiStyle.gsLabel);

            var i = 0;
            var slotNo = maidMgr.GetActiveSlotNo(maids[maidIndex]);

            foreach (var key in MyConst.BODY_MORPH.Keys)
            {
                var defaultVal = 0f;
                if (i == 0)
                {
                    defaultVal = maids[maidIndex].GetProp(key).value;
                }

                var val1 = maidMgr.FaicalDic[slotNo].bodyMorphDic[key];
                var val2 = guiMgr.SetOneLineSlider(MyConst.BODY_MORPH[key], baseRow + i, val1, MyConst.BODY_MIN, MyConst.BODY_MAX, defaultVal, MyConst.GUI_ONE_SLIDER_NORMAL);
                if (val1 != val2)
                {
                    maidMgr.SetBodyKupa(maids, slotNo, key, val2, guiMgr.IsMaidAppearanceAll);
                }
                i++;
            }

            var data = maidMgr.AutoKupaData;
            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 11;
            GUI.Label(rect, "オートくぱ", guiStyle.gsLabel);
            rect.x += rect.width;
            data.isKupa = GUI.Toggle(rect, data.isKupa, "前穴", guiStyle.gsToggle);
            rect.x += rect.width;
            data.isAnalKupa = GUI.Toggle(rect, data.isAnalKupa, "後穴", guiStyle.gsToggle);
            data.minSize = guiMgr.SetOneLineSlider("最小値", baseRow + 12, data.minSize, MyConst.BODY_MIN, MyConst.BODY_MAX, MyConst.BODY_MIN, MyConst.GUI_ONE_SLIDER_NORMAL);
            data.maxSize = guiMgr.SetOneLineSlider("最大値", baseRow + 13, data.maxSize, MyConst.BODY_MIN, MyConst.BODY_MAX, MyConst.BODY_MAX, MyConst.GUI_ONE_SLIDER_NORMAL);
            data.interval = guiMgr.SetOneLineSlider("開閉間隔", baseRow + 14, data.interval, MyConst.BODY_MIN, MyConst.BODY_INTERVAL, MyConst.BODY_INTERVAL, MyConst.GUI_ONE_SLIDER_SMALL);
            if (data.maxSize < data.minSize)
            {
                data.maxSize = data.minSize;
            }
            if (data.isKupa != maidMgr.AutoKupaData.isKupa ||
               data.isAnalKupa != maidMgr.AutoKupaData.isAnalKupa ||
               data.minSize != maidMgr.AutoKupaData.minSize ||
               data.maxSize != maidMgr.AutoKupaData.maxSize ||
               data.interval != maidMgr.AutoKupaData.interval)
            {
                data.lerpTime = 0;
                data.isReverse = false;
                maidMgr.AutoKupaData = data;
            }
        }

        private void SetMaidAreaFacialTop(List<Maid> maids)
        {
            int baseRow = 4;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 0.8f;
            var isFacialEnabled = guiMgr.IsFacialEnabled;
            isFacialEnabled = GUI.Toggle(rect, isFacialEnabled, "有効", guiStyle.gsToggle);

            if (isFacialEnabled)
            {
                for (int i = 0; i < MyConst.MAID_FACIAL_LABEL.GetLength(0); i++)
                {
                    rect.x += rect.width;
                    var isSelected = GUI.Toggle(rect, i == guiMgr.FacialIndex, MyConst.MAID_FACIAL_LABEL[i], guiStyle.gsToggle);
                    if (isSelected && i != guiMgr.FacialIndex)
                    {
                        guiMgr.FacialIndex = i;
                    }
                }
            }
            else
            {
                rect.x += rect.width;
                if (GUI.Button(rect, "表情保持", guiStyle.gsButton))
                {
                    maidMgr.SetCurrentFacialValue(maids[maidMgr.GuiMaidIndex]);
                }

                if (guiMgr.IsFacialEnabled != isFacialEnabled)
                {
                    foreach (var maid in maids)
                    {
                        var tmL = maid.body0.trsEyeL;
                        var tmR = maid.body0.trsEyeR;
                        tmL.localPosition = new Vector3(tmL.localPosition.x, 0f, tmL.localPosition.z);
                        tmR.localPosition = new Vector3(tmL.localPosition.x, 0f, tmL.localPosition.z);
                    }
                }
            }
            guiMgr.IsFacialEnabled = isFacialEnabled;
        }

        private void SetMaidAreaFacialList(Maid maid)
        {
            int baseRow = 7;
            var text = guiMgr.CustomFaceLabel;
            var isClick = guiMgr.SetSaveField(baseRow - 2, ref text);
            guiMgr.CustomFaceLabel = text;
            if (isClick && !string.IsNullOrEmpty(text))
            {
                var slotNo = maidMgr.GetActiveSlotNo(maid);
                new FileWriter().WriteCustomFaceList(maidMgr.FaicalDic[slotNo].facialMorphDic, text);
                GetCustomFaceList();
            }

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            rect.width *= 2;
            GUI.Label(rect, "カスタム表情リスト", guiStyle.gsLabel);
            rect.x += rect.width * 1.5f;
            rect.width /= 2;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton) || MyHelper.CheckNull(customFaceList))
            {
                GetCustomFaceList();
            }

            var index = guiMgr.SetSelectionGrid(baseRow, customFaceList,
                                         MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow),
                                         ref scrollCustomFace);
            if (index != customFaceList.Count() - 1)
            {
                maidMgr.GetCustomFace(maid, customFaceList[index]);
            }
        }

        private void SetMaidAreaFacialOption(Maid maid, int baseRow, bool isFreeDance)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            GUI.Label(rect, "表情オプション" + (isFreeDance ? "（ダンス）" : ""), guiStyle.gsLabel); ;

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            int index = 0;
            var slotNo = maidMgr.GetActiveSlotNo(maid);
            var dic = isFreeDance ? maidMgr.DanceFaicalDic : maidMgr.FaicalDic[slotNo].facialMorphDic;

            foreach (var key in MyConst.FACE_OPTION_MORPH.Keys)
            {
                if (index > 0 && index % MyConst.MAX_COLUMN == 0)
                {
                    rect.y += rect.height;
                    rect.x = MyConst.DEFAULT_RECT.x;
                }
                var val = key;
                var isOn = dic[val] == MyConst.FACE_BLEND_VALUE;
                isOn = GUI.Toggle(rect, isOn, MyConst.FACE_OPTION_MORPH[key], guiStyle.gsToggle);
                dic[key] = isOn ? MyConst.FACE_BLEND_VALUE : 0f;
                rect.x += rect.width;
                index++;
            }
            if (isFreeDance)
            {
                maidMgr.DanceFaicalDic = dic;
            }
            else
            {
                var d = maidMgr.FaicalDic[slotNo];
                d.facialMorphDic = dic;
                maidMgr.FaicalDic[slotNo] = d;

                index = 18;
                rect = MyConst.DEFAULT_RECT;
                rect.y *= index;
                rect.width *= 2;
                GUI.Label(rect, "※以下は変更値が保存されます");

                var tmL = maid.body0.trsEyeL;
                var tmR = maid.body0.trsEyeR;

                /*
                var y = tmL.localScale.y;
                y = guiMgr.SetOneLineSlider("（瞳サイズ）", index + 1, y, 0f, 1.5f, 1f, MyConst.GUI_ONE_SLIDER_SMALL);
                if (y != tmL.localScale.y)
                {
                    tmL.localScale = new Vector3(1f, y, y);
                    tmR.localScale = new Vector3(1f, y, y);
                }
                */

                var y = tmL.localPosition.y;
                y = guiMgr.SetOneLineSlider("（瞳Y位置）", index + 1, y, 0f, 0.02f, 0f, MyConst.GUI_ONE_SLIDER_SMALL);
                if (y != tmL.localPosition.y)
                {
                    tmL.localPosition = new Vector3(tmL.localPosition.x, y, tmL.localPosition.z);
                    tmR.localPosition = new Vector3(tmL.localPosition.x, y * -1, tmL.localPosition.z);
                }

            }
        }

        private void SetMaidAreaFacialEye(Maid maid)
        {
            int baseRow = 5;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            var slotNo = maidMgr.GetActiveSlotNo(maid);

            var row = baseRow;
            foreach (var key in MyConst.FACE_MORPH.Keys)
            {
                maidMgr.FaicalDic[slotNo].facialMorphDic[key] =
                    guiMgr.SetOneLineSlider(MyConst.FACE_MORPH[key], row, maidMgr.FaicalDic[slotNo].facialMorphDic[key],
                                            MyConst.FACIAL_MIN, MyConst.FACIAL_MAX, MyConst.FACIAL_MIN, MyConst.GUI_ONE_SLIDER_SMALL);
                row++;
            }
        }

        private void SetMaidAreaFacialMouth(Maid maid)
        {
            int baseRow = 5;
            var row = baseRow;
            var slotNo = maidMgr.GetActiveSlotNo(maid);

            foreach (var key in MyConst.MOUTH_MORPH.Keys)
            {
                maidMgr.FaicalDic[slotNo].facialMorphDic[key] =
                    guiMgr.SetOneLineSlider(MyConst.MOUTH_MORPH[key], row, maidMgr.GetMorphValue(maid, key),
                                            MyConst.FACIAL_MIN, MyConst.FACIAL_MAX, MyConst.FACIAL_MIN, MyConst.GUI_ONE_SLIDER_SMALL);
                row++;
            }
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= row;
            rect.width *= 2;
            guiMgr.IsKuchipakuDisabled = GUI.Toggle(rect, guiMgr.IsKuchipakuDisabled, "口パク無効", guiStyle.gsToggle);
        }
        #endregion

        #region GuiMaidMotion
        private void SetMaidAreaMotionTop(List<Maid> maids)
        {
            int baseRow = 2;
            maidMgr.GuiMaidIndex =
                    guiMgr.SetSelectedMaidButton(baseRow, maids, maidMgr.GuiMaidIndex, maidMgr);

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            rect.width *= 4f / 3f;
            foreach (int key in Enum.GetValues(typeof(MotionProcType)))
            {
                var selected = GUI.Toggle(rect, guiMgr.MotionProcTypeIndex == key, MyConst.MAID_MOTION_PROC_LABEL[key], guiStyle.gsToggle);
                if (selected)
                {
                    guiMgr.MotionProcTypeIndex = key;
                }
                rect.x += rect.width;
            }

            if (guiMgr.MotionProcTypeIndex == (int)MotionProcType.Motion && !tlWindowMgr.IsEnabled && !tlPlaySet.isPlay)
            {
                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 2;
                rect.width *= 2;
                tlPlaySet.isViewAngle = GUI.Toggle(rect, tlPlaySet.isViewAngle, "視野角有効", guiStyle.gsToggle);

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 4;
                GUI.Label(rect, "選択タイプ：", guiStyle.gsLabel);
                rect.x += rect.width;
                rect.width *= 2;
                var label = tlPlaySet.isOfficialDance ? MyConst.TIMELINE_TYPE_LABEL[0] : MyConst.TIMELINE_TYPE_LABEL[1];
                GUI.Label(rect, label, guiStyle.gsLabel);
                rect.x += rect.width;
                rect.width /= 2;
                label = tlPlaySet.isOfficialDance ? MyConst.TIMELINE_TYPE_LABEL[1].Substring(0, 4) : MyConst.TIMELINE_TYPE_LABEL[0];
                if (GUI.Button(rect, label, guiStyle.gsButton))
                {
                    InitializeTimeLine(!tlPlaySet.isOfficialDance);
                }
            }

        }

        private void SetMaidAreaMotionFrame(List<Maid> maids, bool isMorph)
        {
            var mgr = isMorph ? (Timeline)morphMgr : (Timeline)boneMgr;
            int baseRow = 4;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            var label = string.Format("フレーム:{0} (秒:{1})",
                        mgr.SelectedFrame.ToString("0000"),
                        (mgr.SelectedFrame * MyConst.FRAME_CONVERSION_RATIO).ToString(MyConst.DECIMAL_FORMAT));
            GUI.Label(rect, label, guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            rect.width *= 4f / 3f;
            for (int i = 0; i < MyConst.MAID_MOTION_UPDATE_LABEL.Count(); i++)
            {
                label = string.Format(MyConst.MAID_MOTION_UPDATE_LABEL[i], isMorph ? "表情" : "ボーン");
                var selected = GUI.Toggle(rect, i == mgr.UpdateIndex, label, guiStyle.gsToggle);
                if (selected)
                {
                    mgr.UpdateIndex = i;
                }
                rect.x += rect.width;
            }

            var data = new List<int>();
            foreach (var maid in maids)
            {
                data.Add(maidMgr.GetActiveSlotNo(maid));
            }
            mgr.SweepItemData(data);
        }

        private void SetMaidAreaBoneUpdate(Maid maid, int slotNo)
        {;
            var boneName = boneMgr.SelectedName;
            int baseRow = 6;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "設定ボーン指定", guiStyle.gsLabel);
            rect.x += rect.width * 3;
            if (GUI.Button(rect, "現ポーズ適用", guiStyle.gsButton))
            {
                boneMgr.SetCurrentBone(maid, slotNo);
            }

            var dic = boneMgr.ItemDeletionDic;
            SetMaidAreaMotionSelecterView(baseRow + 1, true, false, ref dic, ref boneName, ref scrollMaidFrameSelection);
            boneMgr.SelectedName = boneName;

            var bone = maid.body0.GetBone(boneName);
            var data = new MotionTimeLineSet();
            data.position = boneMgr.GetPosition(slotNo);
            data.rotation = boneMgr.GetRotation(slotNo);
            var resetValue = Vector3.zero;

            if (boneName == MyConst.BONE_ALL)
            {
                var position = data.position;
                guiMgr.SetPositionSlider(baseRow + 6, ref position, MyConst.BONE_DEFAULT_POSITON[boneName]);
                if (data.position != position)
                {
                    bone.transform.localPosition = position;
                    data.position = position;
                }
            }
            if (MyConst.BONE_DEFAULT_ROTATION.ContainsKey(boneName))
            {
                resetValue = MyConst.BONE_DEFAULT_ROTATION[boneName];
            }
            var rotation = data.rotation;
            MyHelper.AdjustRotation(ref rotation.x);
            MyHelper.AdjustRotation(ref rotation.y);
            MyHelper.AdjustRotation(ref rotation.z);
            guiMgr.SetBoneSlider(baseRow + 9, ref rotation, resetValue);
            if (data.rotation != rotation)
            {
                bone.transform.localRotation = Quaternion.Euler(rotation);
                data.rotation = rotation;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 12;
            rect.x += rect.width * 3;
            if (GUI.Button(rect, "全アンドゥ", guiStyle.gsButton))
            {
                boneMgr.GetResetValue(ref data.position, ref data.rotation);
                if (boneName == MyConst.BONE_ALL)
                {
                    bone.transform.localPosition = data.position;
                }
                bone.transform.localRotation = Quaternion.Euler(data.rotation);
            }
            
            var easing = boneMgr.GetEasingData(slotNo);
            if (0 < boneMgr.SelectedFrame)
            {
                SetMaidAreaMotionEasing(ref easing);
            }
            data.frame = boneMgr.SelectedFrame;
            data.name = boneName;
            data.easing = easing;
            boneMgr.UpdateBoneData(data, slotNo);
        }

        private void SetMaidAreaMotionEasing(ref int easing)
        {
            int baseRow = 19;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "イージング", guiStyle.gsLabel);
            guiMgr.SetIndexChangedButton(ref rect, Enum.GetNames(typeof(EasingType)).Length, ref easing);
            var label = easing.ToString("00") + ": " + Enum.GetName(typeof(EasingType), easing);
            guiMgr.SetIndexChangedLabel(rect, label);
        }

        private void SetMaidAreaItemSelecter(bool isMorph)
        {
            var mgr = isMorph ? (Timeline)morphMgr : (Timeline)boneMgr;
            var labels = isMorph ? MyConst.MORPH_GROUP_LABEL : MyConst.BONE_GROUP_LABEL;
            var isClick = false;
            var isSelected = false;

            int baseRow = 6;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            if (GUI.Button(rect, "選択", guiStyle.gsButton))
            {
                isClick = true;
                isSelected = true;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "解除", guiStyle.gsButton))
            {
                isClick = true;
            }
            rect.x += rect.width;
            for (int i = 0; i < labels.Count(); i++)
            {
                var selected = GUI.Toggle(rect, i == mgr.GroupIndex, labels[i], guiStyle.gsToggle);
                if (selected)
                {
                    mgr.GroupIndex = i;
                }
                if (i == 0)
                {
                    rect = MyConst.DEFAULT_RECT;
                    rect.y *= baseRow + 1;
                    rect.width /= 2;
                }
                else
                {
                    rect.x += rect.width;
                }
            }

            if (isClick)
            {
                var dic = isMorph ? MyConst.ALL_FACIAL_MORPH : tlWindowMgr.GetBoneGroup();
                foreach (var pair in dic)
                {
                    if (mgr.GroupIndex == 0 ||
                        pair.Value.Substring(0, 1) == mgr.GroupIndex.ToString())
                    {
                        switch (mgr.UpdateIndex)
                        {
                            case (int)MotionUpdateType.BoneAddition:
                                if (mgr.ItemAddtionDic.ContainsKey(pair.Key))
                                {
                                    mgr.ItemAddtionDic[pair.Key] = isSelected;
                                }
                                if (mgr.ItemDeletionDic.ContainsKey(pair.Key))
                                {
                                    mgr.ItemDeletionDic[pair.Key] = isSelected;
                                }
                                break;
                            case (int)MotionUpdateType.NewFrame:
                                mgr.ItemNewFrameDic[pair.Key] = isSelected;
                                break;
                        }
                    }
                }
            }
        }

        private void SetMaidAreaMotionFrameUpdate(Maid maid, int slotNo, bool isMorph)
        {
            var mgr = isMorph ? (Timeline)morphMgr : (Timeline)boneMgr;
            var label = isMorph ? "表情" : "ボーン";
            int baseRow = 8;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, string.Format("追加{0}指定", label), guiStyle.gsLabel);
            if (!MyHelper.CheckNull(mgr.ItemAddtionDic))
            {
                rect.x += rect.width * 3;
                if (GUI.Button(rect, "追加", guiStyle.gsButton) && mgr.SelectedFrame != 0)
                {
                    if (isMorph)
                    {
                        morphMgr.AddTimeLineItem(maid, slotNo);
                    }
                    else
                    {
                        boneMgr.AddTimeLineItem(maid, slotNo);
                    }
                }
                var dic = mgr.ItemAddtionDic;
                var selectedName = morphMgr.SelectedName;
                SetMaidAreaMotionSelecterView(baseRow + 1, false, isMorph, ref dic, ref selectedName, ref scrollMaidFrameAddition);
                morphMgr.SelectedName = selectedName;
                mgr.ItemAddtionDic = dic;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 6;
            GUI.Label(rect, string.Format("削除{0}指定", label), guiStyle.gsLabel);
            if (!MyHelper.CheckNull(mgr.ItemDeletionDic))
            {
                rect.x += rect.width * 3;
                if (GUI.Button(rect, "削除", guiStyle.gsButton) && mgr.SelectedFrame != 0)
                {
                    if (isMorph)
                    {
                        morphMgr.DeleteTimeLineItem(slotNo);
                    }
                    else
                    {
                        boneMgr.DeleteTimeLineItem(slotNo);
                    }
                }
                var dic = mgr.ItemDeletionDic;
                var selectedName = morphMgr.SelectedName;
                SetMaidAreaMotionSelecterView(baseRow + 7, false, isMorph, ref dic, ref selectedName, ref scrollMaidFrameDeletion);
                morphMgr.SelectedName = selectedName;
                mgr.ItemDeletionDic = dic;
            }
        }

        private void SetMaidAreaMotionNewFrame(Maid maid, int slotNo, bool isMorph)
        {
            var mgr = isMorph ? (Timeline)morphMgr : (Timeline)boneMgr;
            var label = isMorph ? "表情" : "ボーン";
            int baseRow = 9;
            if (!mgr.ExistsKeyFrame(slotNo))
            {
                var rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow;
                rect.width *= 3;
                GUI.Label(rect, string.Format("未設定フレーム追加{0}指定", label), guiStyle.gsLabel);
                if (!MyHelper.CheckNull(mgr.ItemNewFrameDic))
                {
                    rect.x += rect.width;
                    rect.width /= 3;
                    if (GUI.Button(rect, "追加", guiStyle.gsButton) && mgr.SelectedFrame != 0)
                    {
                        if (isMorph)
                        {
                            morphMgr.CreateNewFrame(maid, slotNo, mgr.SelectedFrame);

                        }
                        else
                        {
                            boneMgr.CreateNewFrame(maid, slotNo, mgr.SelectedFrame);
                        }
                    }
                    var dic = mgr.ItemNewFrameDic;
                    var selectedName = mgr.SelectedName;
                    SetMaidAreaMotionSelecterView(baseRow + 1, false, isMorph, ref dic, ref selectedName, ref scrollMaidFrameNewFrame);
                    mgr.SelectedName = selectedName;
                    mgr.ItemNewFrameDic = dic;
                }
            }
        }

        private void SetMaidAreaMotionSelecterView(int baseRow, bool isValueUpdating, bool isMorph,
                                                   ref Dictionary<string, bool> itemDic,  ref string selectedName, ref Vector2 scroll)
        {
            var dic = isMorph ? MyConst.ALL_FACIAL_MORPH : tlWindowMgr.GetBoneGroup();
            var rect = MyConst.DEFAULT_RECT;
            rect.width *= 4;
            rect.height = Mathf.Ceil(dic.Count() / MyConst.GUI_GRID_COLUMN) * rect.height;
            var viewRect = rect;
            viewRect.y *= baseRow;
            viewRect.height = MyConst.GUI_HEIGHT * MyConst.GUI_FRAME_BONE;
            scroll = GUI.BeginScrollView(viewRect, scroll, rect, false, true);

            rect = MyConst.DEFAULT_RECT;
            rect.width *= 2;
            var index = 0;
            foreach (var pair in dic)
            {
                if (itemDic.ContainsKey(pair.Key))
                {
                    if (isValueUpdating)
                    {
                        var selected = GUI.Toggle(rect, selectedName == pair.Key, pair.Value, guiStyle.gsToggle);
                        if (selected)
                        {
                            selectedName = pair.Key;
                        }
                    }
                    else
                    {
                        itemDic[pair.Key] = GUI.Toggle(rect, itemDic[pair.Key], pair.Value, guiStyle.gsToggle);
                    }
                    rect.x += rect.width;
                    index++;
                }
                if (index == MyConst.GUI_GRID_COLUMN)
                {
                    rect.x = MyConst.DEFAULT_RECT.x;
                    rect.y += rect.height;
                    index = 0;
                }
            }
            GUI.EndScrollView();
        }

        private void SetMaidAreaMorphUpdate(Maid maid, int slotNo)
        {
            var morphName = morphMgr.SelectedName;
            int baseRow = 6;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "設定表情指定", guiStyle.gsLabel);
            rect.x += rect.width * 3;

            var dic = morphMgr.ItemDeletionDic;
            SetMaidAreaMotionSelecterView(baseRow + 1, true, true, ref dic, ref morphName, ref scrollMaidFrameSelection);
            var data = new MotionTimeLineSet();
            data.frame = morphMgr.SelectedFrame;
            data.name = morphName;
            data.morphValue = maidMgr.GetMorphValue(maid, morphName);
            data.morphValue = guiMgr.SetOneLineSlider("表情値", baseRow + 6, data.morphValue, MyConst.FACIAL_MIN, MyConst.FACIAL_MAX, MyConst.FACIAL_MIN, MyConst.GUI_ONE_SLIDER_SMALL);
            morphMgr.SelectedName = morphName;
            morphMgr.UpdateMorphData(data, slotNo, morphName);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 7;
            morphMgr.MouthText = guiMgr.SetTextField(rect, morphMgr.MouthText);
            rect.x += rect.width;
            if (GUI.Button(rect, "口パク文字", guiStyle.gsButton))
            {
                var fReader = new FileReader();
                var path = fReader.GetFilePath(MyConst.FILE_MAID_MOUTH, "");
                if (!string.IsNullOrEmpty(path))
                {
                    var mouth = fReader.ReadMotionMouthMorphData(path);
                    if (mouth.ContainsKey(morphMgr.MouthText))
                    {
                        foreach (var pair in mouth[morphMgr.MouthText])
                        {
                            var d = new MotionTimeLineSet();
                            d.frame = morphMgr.SelectedFrame;
                            d.name = pair.Key;
                            d.morphValue = pair.Value;
                            morphMgr.UpdateMorphData(d, slotNo, d.name);
                        }
                    }
                }
            }
        }

        private void SetMaidAreaMorphUpdateAll(Maid maid, int slotNo)
        {
            int baseRow = 14;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            for (int i = 0; i < MyConst.MOTION_FACIAL_LABEL.Count(); i++)
            {
                var isSelected = GUI.Toggle(rect, i == morphMgr.SelectedFacial, MyConst.MOTION_FACIAL_LABEL[i], guiStyle.gsToggle);
                if (isSelected && i != morphMgr.SelectedFacial)
                {
                    morphMgr.SelectedFacial = i;
                }
                rect.x += rect.width;
            }

            var labels = new List<string>();
            var isCustom = morphMgr.SelectedFacial == (int)TimeLineMorphType.Custom;
            if (isCustom)
            {
                if (MyHelper.CheckNull(customFaceList))
                {
                    GetCustomFaceList();
                }
                labels = customFaceList;
            }
            else
            {
                switch (morphMgr.SelectedFacial)
                {
                    case (int)TimeLineMorphType.General:
                        labels = MyConst.FACE_GENERAL_LABEL.ToList();
                        break;
                    case (int)TimeLineMorphType.Dance:
                        labels = MyConst.FACE_DANCE_LABEL.ToList();
                        break;
                    case (int)TimeLineMorphType.Ero:
                        labels = MyConst.FACE_ERO_LABEL.ToList();
                        break;
                }
                labels.Add("");
            }

            var row = baseRow + 1;
            var index = guiMgr.SetSelectionGrid(row, labels,
                        MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - row), ref scrollMotionFicial);
            if (index != labels.Count() - 1)
            {
                if (isCustom)
                {
                    morphMgr.SetCustomFacialData(labels[index], slotNo);
                }
                else
                {
                    maidMgr.UpdateFaceAnime(maid, labels[index]);
                }
            }
        }

        private void SetMaidAreaCameraFrame()
        {
            int baseRow = 4;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            var label = string.Format("フレーム:{0} (秒:{1})",
                        mCameraMgr.SelectedFrame.ToString("0000"),
                        (mCameraMgr.SelectedFrame * MyConst.FRAME_CONVERSION_RATIO).ToString(MyConst.DECIMAL_FORMAT));
            GUI.Label(rect, label, guiStyle.gsLabel);

            var pos = cameraMgr.CurrentPosition;
            var rot = cameraMgr.CurrentRotation;
            var labelFormat = "x={0:0.00} y={1:0.00} z={2:0.00}";
            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            GUI.Label(rect, "位置座標", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 3;
            GUI.Label(rect, string.Format(labelFormat, pos.x, pos.y, pos.z), guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 3;
            GUI.Label(rect, "回転座標", guiStyle.gsLabel);
            rect.x += MyConst.GUI_WIDTH;
            rect.width = MyConst.GUI_WIDTH * 3;
            GUI.Label(rect, string.Format(labelFormat, rot.x, rot.y, rot.z), guiStyle.gsLabel);
        }

        private void SetMaidAreaPoseBone(Maid maid)
        {
            int baseRow = 4;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            if (GUI.Button(rect, "一時保持", guiStyle.gsButton))
            {
                var dic = new Dictionary<string, MaidPoseeBoneSet>();
                foreach (var key in MyConst.BONE_NAME_ALL.Keys)
                {
                    var boneName = key;
                    var mp = maid.body0.GetBone(boneName);
                    var mmp = new MaidPoseeBoneSet();
                    mmp.boneName = boneName;
                    mmp.localPosition = mp.transform.localPosition;
                    mmp.localRotation = mp.transform.localRotation;
                    dic[MyConst.BONE_NAME_ALL[key]] = mmp;
                }
                if (MyHelper.CheckNull(captureMgr.PoseBoneDic))
                {
                    captureMgr.PoseBoneDic = new Dictionary<string, Dictionary<string, MaidPoseeBoneSet>>();
                }
                dic[""] = new MaidPoseeBoneSet();
                captureMgr.PoseBoneDic[inputBone + DateTime.Now.ToString("HHmmss")] = dic;
            }

            rect.x += rect.width;
            rect.width *= 3;
            inputBone = guiMgr.SetTextField(rect, inputBone);
            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;

            if (MyHelper.CheckNull(captureMgr.PoseBoneDic))
            {
                rect.width *= 3;
                GUI.Label(rect, "保持しているポーズセットデータはありません。", guiStyle.gsLabel);
            }
            else
            {
                GUI.Label(rect, "対象ポーズ", guiStyle.gsLabel);
                var index = captureMgr.PoseDicIndex;
                guiMgr.SetIndexChangedButton(ref rect, captureMgr.PoseBoneDic.Count(), ref index);
                guiMgr.SetIndexChangedLabel(rect, captureMgr.PoseBoneDic.ToList()[index].Key);
                captureMgr.PoseDicIndex = index;

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 2;
                rect.x += rect.width * 2;
                if (GUI.Button(rect, "停止", guiStyle.gsButton))
                {
                    maidMgr.StopAnimation(maid);
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "削除", guiStyle.gsButton))
                {
                    captureMgr.PoseBoneDic.Remove(captureMgr.PoseBoneDic.ToList()[captureMgr.PoseDicIndex].Key);
                    captureMgr.PoseDicIndex = 0;
                    captureMgr.PoseListIndex = 0;
                    if (!MyHelper.CheckNull(captureMgr.PoseBoneDic))
                    {
                        captureMgr.PoseListIndex = captureMgr.PoseBoneDic.Count();
                    }
                }
                rect.x -= rect.width * 3;
            }
        }

        private void SetMaidAreaPoseBoneGroup(Maid maid)
        {
            int baseRow = 6;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "グループ適用", guiStyle.gsLabel);

            if (!MyHelper.CheckNull(captureMgr.PoseBoneDic))
            {
                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 1;
                rect.width /= 2;
                for (int i = 1; i < MyConst.BONE_GROUP_LABEL.Count(); i++)
                {
                    if (GUI.Button(rect, MyConst.BONE_GROUP_LABEL[i], guiStyle.gsButton))
                    {
                        foreach (var key in MyConst.BONE_NAME_ALL.Keys)
                        {
                            var label = MyConst.BONE_NAME_ALL[key];
                            if (label.Substring(0, 1) == i.ToString())
                            {
                                var saveKey = captureMgr.PoseBoneDic.Keys.ToList()[captureMgr.PoseDicIndex];
                                var bone = captureMgr.PoseBoneDic[saveKey][label];
                                maid.body0.GetBone(bone.boneName).transform.localPosition = bone.localPosition;
                                maid.body0.GetBone(bone.boneName).transform.localRotation = bone.localRotation;
                            }
                        }
                    }
                    rect.x += rect.width;
                }
            }
        }

        private void SetMaidAreaPoseBoneList(Maid maid)
        {
            int baseRow = 9;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            rect.width *= 3;
            GUI.Label(rect, "部位別適用（要モーション停止）", guiStyle.gsLabel);

            if (!MyHelper.CheckNull(captureMgr.PoseBoneDic))
            {
                rect.x += rect.width;
                rect.width /= 3;
                if (GUI.Button(rect, "全適用", guiStyle.gsButton))
                {
                    foreach (var pair in MyConst.BONE_NAME_ALL)
                    {
                        var saveKey = captureMgr.PoseBoneDic.Keys.ToList()[captureMgr.PoseDicIndex];
                        var bone = captureMgr.PoseBoneDic[saveKey][pair.Value];
                        maid.body0.GetBone(bone.boneName).transform.localPosition = bone.localPosition;
                        maid.body0.GetBone(bone.boneName).transform.localRotation = bone.localRotation;
                    }
                }

                var key = captureMgr.PoseBoneDic.Keys.ToList()[captureMgr.PoseDicIndex];
                var labelList = captureMgr.PoseBoneDic[key].Keys.ToList();
                var index = guiMgr.SetSelectionGrid(baseRow, labelList,
                                                     MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow),
                                                     ref scrollPoseBorn);

                if (index != captureMgr.PoseBoneDic[key].Count() - 1)
                {
                    var bone = captureMgr.PoseBoneDic[key][labelList[index]];
                    maid.body0.GetBone(bone.boneName).transform.localPosition = bone.localPosition;
                    maid.body0.GetBone(bone.boneName).transform.localRotation = bone.localRotation;
                }
            }
        }

        private void SetMaidAreaCapture(Maid maid)
        {
            int baseRow = 4;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "保存ファイル名", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 3;
            captureMgr.SaveFileName = guiMgr.SetTextField(rect, captureMgr.SaveFileName);
            rect.x += rect.width;

            if (!captureMgr.IsAnimationCapture)
            {
                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 1;
                GUI.Label(rect, "모션", guiStyle.gsLabel);
                rect.x += rect.width;
                if (captureMgr.IsMotionCapture)
                {
                    rect.width *= 2;
                    GUI.Label(rect, "캡처 중", guiStyle.gsLabel);
                    rect.x += rect.width;
                    rect.width /= 2;
                    if (GUI.Button(rect, "終了", guiStyle.gsButton))
                    {
                        captureMgr.EndCapture(false, null);
                    }
                }
                else
                {
                    if (GUI.Button(rect, "캡처", guiStyle.gsButton))
                    {
                        if (string.IsNullOrEmpty(captureMgr.SaveFileName))
                        {
                            Console.WriteLine("저장 파일 이름을 입력하십시오");
                        }
                        else
                        {
                            captureMgr.SetMotionCapture();
                        }
                    }
                    rect.x += rect.width;
                    if (GUI.Button(rect, "시선 없음", guiStyle.gsButton))
                    {
                        maidMgr.SetEyeToCamera(maid, Maid.EyeMoveType.無し, MyConst.ANIMATION_NO_FADE_TIME);
                    }
                }
            }

            if (!captureMgr.IsMotionCapture)
            {
                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 3;
                GUI.Label(rect, "アニメ(.anm)", guiStyle.gsLabel);
                rect.x += rect.width;
                if (captureMgr.IsAnimationCapture)
                {
                    rect.width *= 2;
                    GUI.Label(rect, "キャプチャー中", guiStyle.gsLabel);
                    rect.x += rect.width;
                    rect.width /= 2;
                    if (GUI.Button(rect, "終了", guiStyle.gsButton))
                    {
                        captureMgr.EndCapture(true, maid);
                    }
                }
                else
                {
                    rect.width *= 3;
                    captureMgr.AnimationFileName = guiMgr.SetTextField(rect, captureMgr.AnimationFileName);

                    rect = MyConst.DEFAULT_RECT;
                    rect.y *= baseRow + 4;
                    rect.x += rect.width;
                    if (GUI.Button(rect, "再生", guiStyle.gsButton) &&
                        !string.IsNullOrEmpty(captureMgr.AnimationFileName))
                    {
                        if (captureMgr.IsMyPose)
                        {
                            captureMgr.PlayMyPoseAnimation(maid);
                        }
                        else
                        {
                            captureMgr.PlayOfficialAnimation(maid);
                        }
                    }
                    rect.x += rect.width;
                    if (GUI.Button(rect, "停止", guiStyle.gsButton))
                    {
                        maidMgr.ResetAnimation(maid, MyConst.ANIMATION_FADE_TIME);
                    }                    

                    rect = MyConst.DEFAULT_RECT;
                    rect.y *= baseRow + 5;
                    rect.x += rect.width;
                    captureMgr.IsMyPose = GUI.Toggle(rect, captureMgr.IsMyPose, "Myポーズ", guiStyle.gsToggle);
                    rect.x += rect.width;
                    captureMgr.IsLoopMotion = GUI.Toggle(rect, captureMgr.IsLoopMotion, "ループ出力", guiStyle.gsToggle);
                    rect.x += rect.width;
                    captureMgr.IsOldAnimation = GUI.Toggle(rect, captureMgr.IsOldAnimation, "CM3D2", guiStyle.gsToggle);

                    rect = MyConst.DEFAULT_RECT;
                    rect.y *= baseRow + 6;
                    rect.x += rect.width;
                    if (GUI.Button(rect, captureMgr.IsMyPose ? "TL変換" : "キャプチャー", guiStyle.gsButton))
                    {
                        if (string.IsNullOrEmpty(captureMgr.SaveFileName))
                        {
                            Console.WriteLine("保存ファイル名を入力してください");
                        }
                        else
                        {
                            if (captureMgr.IsMyPose)
                            {
                                captureMgr.ConvertMyPoseFile();
                            }
                            else
                            {
                                captureMgr.SetAnimationCapture(maid);
                            }
                        }
                    }

                    if (captureMgr.IsMyPose)
                    {
                        rect = MyConst.DEFAULT_RECT;
                        rect.y *= baseRow + 7;
                        rect.x += rect.width;
                        if (GUI.Button(rect, ".anm調整", guiStyle.gsButton))
                        {
                            captureMgr.AdjustMyPoseFile();
                        }
                        rect.x += rect.width;
                        captureMgr.IsToe = GUI.Toggle(rect, captureMgr.IsToe, "つま先調整", guiStyle.gsToggle);
                        rect.x += rect.width;
                        captureMgr.IsInterpolationOff = GUI.Toggle(rect, captureMgr.IsInterpolationOff, "補間オフ", guiStyle.gsToggle);
                    }
                }
            }
        }

        private void SetMaidAreaCaptureBoneGroup(bool isCapture)
        {
            var isClick = false;
            var from = 0;
            var to = 0;

            int baseRow = 12;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            var label = (isCapture ? "変換・調整" : "出力") + "ボーン選択";
            GUI.Label(rect, label, guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            captureMgr.IsReset = GUI.Toggle(rect, captureMgr.IsReset, "解除", guiStyle.gsToggle);
            rect.x += rect.width;
            if (GUI.Button(rect, "指以外", guiStyle.gsButton))
            {
                isClick = true;
                from = 0;
                to = 4;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "指", guiStyle.gsButton))
            {
                isClick = true;
                from = 5;
                to = 6;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "つま先", guiStyle.gsButton))
            {
                isClick = true;
                from = 7;
                to = 8;
            }
            if (isClick)
            {
                foreach (var pair in MyConst.BONE_NAME_ALL)
                {
                    var num = int.Parse(pair.Value.Substring(0, 1));
                    if (from <= num && num <= to)
                    {
                        captureMgr.SelectedBoneDic[pair.Key] = !captureMgr.IsReset;
                    }
                }
            }
        }

        private void SetMaidAreaCaptureBoneSelect()
        {
            var dic = MyConst.BONE_NAME_ALL;
            int baseRow = 14;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 4;
            rect.height = Mathf.Ceil(dic.Count() / MyConst.GUI_GRID_COLUMN) * rect.height;
            var viewRect = rect;
            viewRect.height = MyConst.GUI_HEIGHT * (MyConst.GUI_FRAME_BONE + 1);
            scrollMaidCaptureBone = GUI.BeginScrollView(viewRect, scrollMaidCaptureBone, rect, false, true);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            var index = 0;
            foreach (var pair in dic)
            {
                captureMgr.SelectedBoneDic[pair.Key] = GUI.Toggle(rect, captureMgr.SelectedBoneDic[pair.Key], pair.Value, guiStyle.gsToggle);
                rect.x += rect.width;
                index++;
                if (index == MyConst.GUI_GRID_COLUMN)
                {
                    rect.x = MyConst.DEFAULT_RECT.x;
                    rect.y += rect.height;
                    index = 0;
                }
            }
            GUI.EndScrollView();
        }

        private void SetMaidAreaMotionComment()
        {
            int baseRow = 6;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            rect.width *= 4;
            var label = "";
            switch (guiMgr.MotionProcTypeIndex)
            {
                case (int)MotionProcType.Motion:
                    label = "キャプチャー中のため、使用できません";
                    break;
                case (int)MotionProcType.Capture:
                    label = "タイムラインが有効のため、使用できません";
                    break;
            }
            GUI.Label(rect, label, guiStyle.gsLabel);
        }


        #endregion

        #region GuiMaidMove
        private void SetMaidAreaMoveTop(List<Maid> maids)
        {
            int baseRow = 2;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            var isEnabled = moveMgr.IsEnabled;
            isEnabled = GUI.Toggle(rect, isEnabled, "有効", guiStyle.gsToggle);
            if (isEnabled != moveMgr.IsEnabled)
            {
                if (!isEnabled)
                {
                    moveMgr.ClearMyPoseData(maids);
                    foreach (var maid in maids)
                    {
                        maidMgr.ResetAnimation(maid, MyConst.ANIMATION_FADE_TIME);
                    }
                }
                moveMgr.IsEnabled = isEnabled;
            }
            rect.x += rect.width;
            moveMgr.IsAutoForward = GUI.Toggle(rect, moveMgr.IsAutoForward, "自動前進", guiStyle.gsToggle);
            rect.x += rect.width;
            moveMgr.IsAutoRound = GUI.Toggle(rect, moveMgr.IsAutoRound, "自動回転", guiStyle.gsToggle);
            rect.x += rect.width;
            moveMgr.IsAll = GUI.Toggle(rect, moveMgr.IsAll, "メイド一括", guiStyle.gsToggle);

            maidMgr.GuiMaidIndex =
               guiMgr.SetSelectedMaidButton(baseRow + 1, maids, maidMgr.GuiMaidIndex, maidMgr);
        }

        private void SetMaidAreaMoveControl(List<Maid> maids)
        {
            int baseRow = 4;
            var guiMaidIndex = maidMgr.GuiMaidIndex;
            var maid = maids[guiMaidIndex];
            var pos = maid.transform.position;
            var rot = maid.transform.eulerAngles;
            var y = 0f;
            var h = 0f;
            var z = 0f;

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 0.75f;
            rect.height *= 2;

            if (!moveMgr.IsAutoForward && GUI.RepeatButton(rect, "前進", guiStyle.gsButton))
            {
                z = moveMgr.SpeedForward;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.x += rect.width;
            rect.width /= 2;
            if (!moveMgr.IsAutoRound && GUI.RepeatButton(rect, "右回", guiStyle.gsButton))
            {
                y = moveMgr.SpeedRotation;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "+45", guiStyle.gsButton)) y = 45;
            rect.x += rect.width;
            if (GUI.Button(rect, "+90", guiStyle.gsButton)) y = 90;
            rect.x += rect.width;
            if (GUI.Button(rect, "+180", guiStyle.gsButton)) y = 180;
            rect.x += rect.width * 2;
            if (GUI.RepeatButton(rect, "上昇", guiStyle.gsButton)) h = moveMgr.SpeedUpDown;

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            rect.x += rect.width;
            rect.width /= 2;
            if (!moveMgr.IsAutoRound && GUI.RepeatButton(rect, "左回", guiStyle.gsButton)) y = -moveMgr.SpeedRotation;
            rect.x += rect.width;
            if (GUI.Button(rect, "-45", guiStyle.gsButton)) y = -45;
            rect.x += rect.width;
            if (GUI.Button(rect, "-90", guiStyle.gsButton)) y = -90;
            rect.x += rect.width;
            if (GUI.Button(rect, "0", guiStyle.gsButton)) y = rot.y * -1;
            rect.x += rect.width * 2;
            if (GUI.RepeatButton(rect, "下降", guiStyle.gsButton)) h = -moveMgr.SpeedUpDown;

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            rect.width = rect.width * 4 / 6;
            GUI.Label(rect, "前進速度", guiStyle.gsLabel);
            rect.x += rect.width;
            var speed = moveMgr.SpeedForward;
            guiMgr.SetNumberField(rect, moveSpeed.maidForward, ref speed);
            moveMgr.SpeedForward = speed;
            rect.x += rect.width;
            GUI.Label(rect, "回転速度", guiStyle.gsLabel);
            rect.x += rect.width;
            speed = moveMgr.SpeedRotation;
            guiMgr.SetNumberField(rect, moveSpeed.maidRotation, ref speed);
            moveMgr.SpeedRotation = speed;
            rect.x += rect.width;
            GUI.Label(rect, "上下速度", guiStyle.gsLabel);
            rect.x += rect.width;
            speed = moveMgr.SpeedUpDown;
            guiMgr.SetNumberField(rect, moveSpeed.maidUpDown, ref speed);
            moveMgr.SpeedUpDown = speed;

            if (rot.y + y != rot.y)
            {
                moveMgr.SetMaidMovingRotationY(maids, guiMaidIndex, y);
            }
            if (pos.y + h != pos.y)
            {
                moveMgr.SetMaidMovingPositionY(maids, guiMaidIndex, h);
            }

            if (pos != pos + maid.transform.forward * z)
            {
                moveMgr.SetMaidMovingPositionZ(maids, guiMaidIndex, z);
                moveMgr.IsMove = true;
            }
            else
            {
                moveMgr.IsMove = false;
            }
        }

        private void SetMaidAreaMoveList(List<Maid> maids)
        {
            int baseRow = 8;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            rect.width *= 3;
            GUI.Label(rect, "動くリスト", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width /= 3;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton) || MyHelper.CheckNull(movingList))
            {
                GetMovingList();
            }

            var index = guiMgr.SetSelectionGrid(baseRow, movingList,
                                         MyConst.GUI_HEIGHT * 6,
                                         ref scrollMoving);
            if (index != movingList.Count() - 1)
            {
                moveMgr.ClearMyPoseData(maids);
                if (moveMgr.GetMyPoseData(movingList[index]))
                {
                    moveMgr.IsEnabled = true;
                    moveMgr.IsAutoForward = false;
                    moveMgr.IsAutoRound = false;
                }
            }
        }

        private void SetMaidAreaMoveTransform(Maid maid)
        {
            int baseRow = 14;
            var tm = maid.transform;
            var vec = tm.position;
            guiMgr.SetPositionSlider(baseRow, ref vec, Vector3.zero);
            if (vec != tm.position)
            {
                maid.transform.position = vec;
                tm.position = vec;
            }

            vec = tm.eulerAngles;
            guiMgr.SetRotationSlider(baseRow + 3, ref vec, Vector3.zero);
            if (vec != tm.eulerAngles)
            {
                maid.transform.rotation = Quaternion.Euler(vec);
                tm.rotation = Quaternion.Euler(vec);
            }
        }

        /*
        private void SetMaidAreaChangingBody()
        {
            int baseRow = 8;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 4;
            GUI.Label(rect, "全ストックメイドボディ一括変更", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "ボディ名", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 3;
            guiMgr.BodyMenu = guiMgr.SetTextField(rect, guiMgr.BodyMenu);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            rect.x += rect.width;
            var isSet = GUI.Button(rect, "ボディ設定", guiStyle.gsButton);
            rect.x += rect.width * 2;
            if (GUI.Button(rect, "初期化", guiStyle.gsButton))
            {
                guiMgr.BodyMenu = MyConst.OFFICIAL_BODY;
                isSet = true;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 4;
            rect.width *= 4;
            foreach (var notice in MyConst.BODY_CHANGE_NOTICE)
            {
                GUI.Label(rect, notice, guiStyle.gsLabel);
                rect.y += MyConst.GUI_HEIGHT;
            }

            if (isSet && !string.IsNullOrEmpty(guiMgr.BodyMenu))
            {
                maidMgr.ChangeBodyMenu(guiMgr.BodyMenu);

            }
        }
        */

        #endregion

        #region GuiLookAt
        private void SetLookAtAreaTop()
        {
            int baseRow = 2;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            var menu = MyConst.LOOK_AT_CAMERA_LABEL;
            var width = rect.width * 4 / menu.Count();
            rect.width = width;
            for (int i = 0; i < menu.Count(); i++)
            {
                var isSelected = GUI.Toggle(rect, i == maidLookAt.lookAtIndex, menu[i], guiStyle.gsToggle);
                if (isSelected && i != maidLookAt.lookAtIndex)
                {
                    maidLookAt.lookAtIndex = i;
                    maidLookAt.cameraIndex = 0;
                }
                rect.x += width;
            }

            ReleaseLookAt();
        }

        private void SetLookAtAreaTopOfDivision()
        {
            int baseRow = 4;
            var dividedIndex = maidLookAt.dividedIndex == MyConst.PRE_INDEX ? 0 : maidLookAt.dividedIndex;
            var isNewLine = (float)Math.Ceiling(MyConst.LOOK_AT_DIVIDED_LABEL.Count() / 2f);

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width = rect.width * 4f / isNewLine;
            for (int i = 0; i < MyConst.LOOK_AT_DIVIDED_LABEL.Count(); i++)
            {
                if (isNewLine == i)
                {
                    rect = MyConst.DEFAULT_RECT;
                    rect.y *= baseRow + 1;
                    rect.width = rect.width * 4f / isNewLine;
                }
                var isSelected = GUI.Toggle(rect, i == dividedIndex, MyConst.LOOK_AT_DIVIDED_LABEL[i], guiStyle.gsToggle);
                if (isSelected && i != maidLookAt.dividedIndex)
                {
                    dividedIndex = i;
                    maidLookAt.cameraIndex = 0;
                }
                rect.x += rect.width;
            }

            if (maidLookAt.dividedIndex != dividedIndex)
            {
                var count = int.Parse(MyConst.LOOK_AT_DIVIDED_LABEL[dividedIndex].Substring(0, 1));
                for (int i = 0; i < maidLookAt.divisionSet.Count(); i++)
                {
                    maidLookAt.divisionSet[i].isLookAt = i < count;
                    if (maidLookAt.divisionSet[i].distanceSlider == 0)
                    {
                        maidLookAt.divisionSet[i].distanceSlider = lookAtSet.distance;
                    }
                }
                maidLookAt.dividedIndex = dividedIndex;
            }

            if (lookAtMgrDiv == null)
            {
                lookAtMgrDiv = new LookAtCameraManager(maidLookAt.divisionSet.Count(), false);
                maidLookAt.cameraIndex = 0;
            }
            isWasdOn = false;
        }

        private void SetLookAtAreaTopOfSubCamera()
        {
            int baseRow = 4;
            for (int i = 0; i < MyConst.LOOK_AT_SUB_LABEL.Count(); i++)
            {
                var rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow;
                rect.x += rect.width * i;
                var sub = maidLookAt.subSet[i];
                sub.isLookAt = GUI.Toggle(rect, sub.isLookAt, MyConst.LOOK_AT_SUB_LABEL[i], guiStyle.gsToggle);

                if (sub.isLookAt)
                {
                    rect.y += MyConst.GUI_HEIGHT;
                    rect.width /= 3;

                    for (int j = 0; j < MyConst.LOOK_AT_SUB_SIZE_LABEL.Count(); j++)
                    {
                        var isSelected = GUI.Toggle(rect, j == sub.subSizeIndex, MyConst.LOOK_AT_SUB_SIZE_LABEL[j], guiStyle.gsToggle);
                        if (isSelected && j != sub.subSizeIndex)
                        {
                            sub.subSizeIndex = j;
                        }
                        rect.x += rect.width;
                    }
                    if (sub.distanceSlider == 0)
                    {
                        sub.distanceSlider = lookAtSet.distance;
                    }
                }
                else
                {
                    rect.x += rect.width * 4;
                }
                maidLookAt.subSet[i] = sub;
            }

            if (lookAtMgrSub == null)
            {
                lookAtMgrSub = new LookAtCameraManager(maidLookAt.subSet.Count(), false);
                maidLookAt.cameraIndex = 0;
            }
        }

        private void SetLookAtAreaTopOfLockCamera()
        {
            if (lookAtMgrLock == null)
            {
                lookAtMgrLock = new LookAtCameraManager(maidLookAt.lockSet.Count(), false);
                maidLookAt.cameraIndex = 0;
            }
        }

        private void SetLookAtAreaCameraSelectOfDivision()
        {
            int baseRow = 10;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "カメラ選択", guiStyle.gsLabel);
            guiMgr.SetIndexChangedButton(ref rect, maidLookAt.divisionSet.Where(e => e.isLookAt).Count(), ref maidLookAt.cameraIndex);
            var label = maidLookAt.cameraIndex == 0 ? "メインカメラ" : "分割カメラ" + maidLookAt.cameraIndex;
            guiMgr.SetIndexChangedLabel(rect, label);

            if (maidLookAt.isAll)
            {
                var count = int.Parse(MyConst.LOOK_AT_DIVIDED_LABEL[maidLookAt.dividedIndex].Substring(0, 1));
                for (int i = 0; i < maidLookAt.divisionSet.Count(); i++)
                {
                    if (i != maidLookAt.cameraIndex)
                    {
                        var div = maidLookAt.divisionSet[i];
                        var maidIndex = div.maidIndex;
                        var autoAngleIndex = div.autoAngleIndex;
                        var autoCamera = div.autoCamera;
                        div = maidLookAt.divisionSet[maidLookAt.cameraIndex];
                        div.isLookAt = i < count;
                        div.maidIndex = maidIndex;
                        div.autoAngleIndex = autoAngleIndex;
                        div.autoCamera = autoCamera;
                        maidLookAt.divisionSet[i] = div;
                    }
                }
            }
        }

        private void SetLookAtAreaCameraSelectOfSubCamera()
        {
            int baseRow = 10;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "カメラ選択", guiStyle.gsLabel);
            guiMgr.SetIndexChangedButton(ref rect, maidLookAt.subSet.Count(), ref maidLookAt.cameraIndex);
            var label = MyConst.LOOK_AT_SUB_LABEL[maidLookAt.cameraIndex];
            guiMgr.SetIndexChangedLabel(rect, label);

            if (maidLookAt.isAll)
            {
                for (int i = 0; i < MyConst.LOOK_AT_SUB; i++)
                {
                    if (i != maidLookAt.cameraIndex)
                    {
                        var sub = maidLookAt.subSet[i];
                        var isLookAt = sub.isLookAt;
                        var maidIndex = sub.maidIndex;
                        var subSizeIndex = sub.subSizeIndex;
                        var autoAngleIndex = sub.autoAngleIndex;
                        var autoCamera = sub.autoCamera;
                        sub = maidLookAt.subSet[maidLookAt.cameraIndex];
                        sub.isLookAt = isLookAt;
                        sub.maidIndex = maidIndex;
                        sub.subSizeIndex = subSizeIndex;
                        sub.autoAngleIndex = autoAngleIndex;
                        sub.autoCamera = autoCamera;
                        maidLookAt.subSet[i] = sub;
                    }
                }
            }
        }

        private void SetLookAtAreaCameraSetting1(List<Maid> maids)
        {
            int baseRow = 8;
            var eachSet = maidLookAt.divisionSet[maidLookAt.cameraIndex];
            if (maidLookAt.lookAtIndex == (int)LookAtCameraType.SubCamera)
            {
                eachSet = maidLookAt.subSet[maidLookAt.cameraIndex];
            }

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            var isLookAtMaidEye = maidLookAt.isMaidEye;
            isLookAtMaidEye = GUI.Toggle(rect, isLookAtMaidEye, "視線制御", guiStyle.gsToggle);
            rect.x += rect.width;
            if (maidLookAt.lookAtIndex == (int)LookAtCameraType.SubCamera)
            {
                maidLookAt.isMotionOn = false;
            }
            else
            {
                maidLookAt.isMotionOn = GUI.Toggle(rect, maidLookAt.isMotionOn, "メインカメラモーションON", guiStyle.gsToggle);
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            maidLookAt.isAll = GUI.Toggle(rect, maidLookAt.isAll, "カメラ一括", guiStyle.gsToggle);

            if (isLookAtMaidEye != maidLookAt.isMaidEye)
            {
                if (!isLookAtMaidEye)
                {
                    for (int i = 0; i < maids.Count(); i++)
                    {
                        maidMgr.SetEyeToCamera(maids[i], Maid.EyeMoveType.目と顔を向ける);
                    }
                }
                maidLookAt.isMaidEye = isLookAtMaidEye;
            }

            if (maidLookAt.lookAtIndex == (int)LookAtCameraType.SubCamera)
            {
                maidLookAt.subSet[maidLookAt.cameraIndex] = eachSet;
            }
            else
            {
                maidLookAt.divisionSet[maidLookAt.cameraIndex] = eachSet;
            }
        }

        private void SetLookAtAreaCameraSetting2(List<Maid> maids)
        {
            int baseRow = 12;
            try
            {
                SetLookAtAreaCameraSetting(maids, baseRow, false, ref maidLookAt);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        private void SetLookAtAreaCameraSetting(List<Maid> maids, int baseRow, bool isScreen, ref MaidLookAtSet mLookAt)
        {
            var eachSet = mLookAt.divisionSet[mLookAt.cameraIndex];
            if (mLookAt.lookAtIndex == (int)LookAtCameraType.SubCamera)
            {
                eachSet = mLookAt.subSet[mLookAt.cameraIndex];
            }
            else if (mLookAt.lookAtIndex == (int)LookAtCameraType.LockOn)
            {
                mLookAt.isMotionOn = false;
                eachSet = mLookAt.lockSet[mLookAt.cameraIndex];
                eachSet.isLookAt = true;
                eachSet.typeIndex = MyConst.PRE_INDEX;
            }

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            eachSet.maidIndex = guiMgr.SetSelectedMaidButton(baseRow, maids, eachSet.maidIndex, maidMgr);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            rect.width *= 2;

            eachSet.isRandomMaid = GUI.Toggle(rect, eachSet.isRandomMaid, "ランダムメイド", guiStyle.gsToggle);
            rect.x += rect.width;
            rect.width /= 2;
            GUI.Label(rect, "切替タイム", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width = MyConst.GUI_WIDTH * 3 / 4;
            if (mLookAt.randomTime == 0)
            {
                mLookAt.randomTime = lookAtSet.randomTime;
            }
            guiMgr.SetNumberField(rect, lookAtSet.randomTime, ref mLookAt.randomTime);
            rect.x += rect.width;
            rect.width = MyConst.GUI_WIDTH / 4;
            if (GUI.Button(rect, "R", guiStyle.gsButton))
            {
                mLookAt.randomTime = lookAtSet.randomTime;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            GUI.Label(rect, "注視ポイント", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width /= 2;
            var parts = MyConst.LOOK_AT_POINT_LABEL;
            for (int i = 0; i < parts.GetLength(0); i++)
            {
                var isSelected = GUI.Toggle(rect, i == eachSet.pointIndex, parts[i], guiStyle.gsToggle);
                if (isSelected && i != eachSet.pointIndex)
                {
                    eachSet.pointIndex = i;
                }
                rect.x += rect.width;
            }
            if (eachSet.typeIndex == (int)LookAtType.Auto)
            {
                eachSet.isRandomPoint = false;
            }
            else
            {
                rect.width = MyConst.GUI_WIDTH;
                eachSet.isRandomPoint = GUI.Toggle(rect, eachSet.isRandomPoint, "ランダム", guiStyle.gsToggle);
            }

            if (mLookAt.lookAtIndex != (int)LookAtCameraType.LockOn)
            {
                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 3;
                GUI.Label(rect, "カメラタイプ", guiStyle.gsLabel);
                rect.x += rect.width;
                rect.width = rect.width * 3 / MyConst.LOOK_AT_TYPE_LABEL.Count();
                for (int i = 0; i < MyConst.LOOK_AT_TYPE_LABEL.Count(); i++)
                {
                    var isSelected = GUI.Toggle(rect, i == eachSet.typeIndex, MyConst.LOOK_AT_TYPE_LABEL[i], guiStyle.gsToggle);
                    if (isSelected && i != eachSet.typeIndex)
                    {
                        eachSet.typeIndex = i;
                        eachSet.autoCamera = new CameraTransformSet();
                        eachSet.autoAngleIndex = MyConst.PRE_INDEX;
                    }
                    rect.x += rect.width;
                }
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 4;
            if (eachSet.typeIndex == (int)LookAtType.Auto)
            {
                var count = MyConst.LOOK_AT_AUTO_LABEL.Count();
                rect.width = rect.width * 4 / count;
                for (int i = 0; i < count; i++)
                {
                    lookAtSet.autoData[i].isEnabled = GUI.Toggle(rect, lookAtSet.autoData[i].isEnabled, MyConst.LOOK_AT_AUTO_LABEL[i], guiStyle.gsToggle);
                    rect.x += rect.width;
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 5;
                GUI.Label(rect, "対象アングル", guiStyle.gsLabel);
                guiMgr.SetIndexChangedButton(ref rect, count, ref maidLookAt.autoIndex);
                guiMgr.SetIndexChangedLabel(rect, MyConst.LOOK_AT_AUTO_LABEL[maidLookAt.autoIndex]);

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 6;
                GUI.Label(rect, "移動量(xyz)", guiStyle.gsLabel);
                rect.x += rect.width;
                var pos = lookAtSet.autoData[maidLookAt.autoIndex].position;
                guiMgr.SetNumberField(rect, 0f, ref pos.x);
                rect.x += rect.width;
                guiMgr.SetNumberField(rect, 0f, ref pos.y);
                rect.x += rect.width;
                guiMgr.SetNumberField(rect, 0f, ref pos.z);
                pos.x = Mathf.Max(pos.x, 0f);
                pos.y = Mathf.Max(pos.y, 0f);
                pos.z = Mathf.Max(pos.z, MyConst.LOOK_AT_AUTO_MIN_Z);
                lookAtSet.autoData[maidLookAt.autoIndex].position = pos;

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 7;
                GUI.Label(rect, "切替タイム範囲", guiStyle.gsLabel);
                rect.x += rect.width;
                var time = lookAtSet.autoData[maidLookAt.autoIndex].autoTime;
                guiMgr.SetNumberField(rect, 0f, ref time.x);
                rect.x += rect.width;
                guiMgr.SetNumberField(rect, 0f, ref time.y);
                rect.x += rect.width;
                if(time.y < time.x)
                {
                    time.y = time.x;
                }
            }
            else
            {
                if (eachSet.typeIndex == (int)LookAtType.Around)
                {
                    GUI.Label(rect, "周囲指定", guiStyle.gsLabel);
                    rect.x += rect.width;
                    rect.width = rect.width * 3 / MyConst.LOOK_AT_ROUOND_LABEL.Count();
                    for (int i = 0; i < MyConst.LOOK_AT_ROUOND_LABEL.Count(); i++)
                    {
                        var isSelected = GUI.Toggle(rect, i == eachSet.aroundTypeIndex, MyConst.LOOK_AT_ROUOND_LABEL[i], guiStyle.gsToggle);
                        if (isSelected && i != eachSet.aroundTypeIndex)
                        {
                            eachSet.aroundTypeIndex = i;
                        }
                        rect.x += rect.width;
                    }
                }
                if (mLookAt.lookAtIndex == (int)LookAtCameraType.LockOn)
                {
                    GUI.Label(rect, "追掛速度", guiStyle.gsLabel);
                    rect.x += rect.width;
                    guiMgr.SetNumberField(rect, MyConst.LOOK_AT_CHASING_SPEED, ref mLookAt.chasingSpeed);
                    if (mLookAt.chasingSpeed < MyConst.LOOK_AT_CHASING_SPEED)
                    {
                        mLookAt.chasingSpeed = MyConst.LOOK_AT_CHASING_SPEED;
                    }
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 5;
                GUI.Label(rect, "カメラ距離", guiStyle.gsLabel);
                rect.x += rect.width;
                rect.width *= 2;
                rect.y += rect.height / 3;
                rect.height /= 2;
                var distance = isScreen ? lookAtSet.distanceScreen : lookAtSet.distance;
                if (eachSet.distanceSlider == 0)
                {
                    eachSet.distanceSlider = distance;
                }
                var slider = MyConst.ZOOM_MAX / 5;
                eachSet.distanceSlider = GUI.HorizontalSlider(rect, eachSet.distanceSlider, slider * -1, slider);

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 5;
                rect.x += rect.width * 3;
                rect.width = MyConst.GUI_WIDTH * 3 / 4;
                guiMgr.SetNumberField(rect, eachSet.distanceSlider, ref eachSet.distanceSlider);
                rect.x += rect.width;
                rect.width = MyConst.GUI_WIDTH / 4;
                if (GUI.Button(rect, "R", guiStyle.gsButton))
                {
                    eachSet.distanceSlider = distance;
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 6;
                eachSet.isOffsetX = GUI.Toggle(rect, eachSet.isOffsetX, "X位置調整", guiStyle.gsToggle);
                rect.x += rect.width;
                guiMgr.SetNumberField(rect, 0f, ref eachSet.offsetX);
                rect.x += rect.width;
                eachSet.isFixedRotX = GUI.Toggle(rect, eachSet.isFixedRotX, "X回転固定", guiStyle.gsToggle);
                rect.x += rect.width;
                guiMgr.SetNumberField(rect, MyConst.LOOK_AT_FIXED_ROT_X, ref eachSet.fixedRotX);

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 7;
                eachSet.isFixedPosY = GUI.Toggle(rect, eachSet.isFixedPosY, "Y位置固定", guiStyle.gsToggle);
                rect.x += rect.width;
                guiMgr.SetNumberField(rect, MyConst.LOOK_AT_FIXED_POS_Y, ref eachSet.fixedPosY);
                rect.x += rect.width;
                eachSet.isFixedRotY = GUI.Toggle(rect, eachSet.isFixedRotY, "Y回転固定", guiStyle.gsToggle);
                rect.x += rect.width;
                guiMgr.SetNumberField(rect, MyConst.LOOK_AT_FIXED_ROT_Y, ref eachSet.fixedRotY);
            }

            if (mLookAt.lookAtIndex == (int)LookAtCameraType.SubCamera)
            {
                mLookAt.subSet[mLookAt.cameraIndex] = eachSet;
            }
            else if (mLookAt.lookAtIndex == (int)LookAtCameraType.LockOn)
            {
                mLookAt.lockSet[mLookAt.cameraIndex] = eachSet;
            }
            else
            {
                mLookAt.divisionSet[mLookAt.cameraIndex] = eachSet;
            }
        }

        private void SetLookAtAreaCameraSetting3()
        {
            int baseRow = 7;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width = rect.width * 4 / 6;
            if (GUI.Button(rect, "読込", guiStyle.gsButton))
            {
                ReadLookAtSettingData();
            }
            rect.x += rect.width;
            for (int i = 0; i < MyConst.LOOK_AT_SETTING_LABEL.Count(); i++)
            {
                var isSelected = GUI.Toggle(rect, i == maidLookAt.settingIndex, MyConst.LOOK_AT_SETTING_LABEL[i], guiStyle.gsToggle);
                if (isSelected && i != maidLookAt.settingIndex)
                {
                    maidLookAt.settingIndex = i;
                }
                rect.x += rect.width;
            }
            if (GUI.Button(rect, "保存", guiStyle.gsButton))
            {
                new FileWriter().WriteLookAtCameraList(maidLookAt, MyConst.LOOK_AT_SETTING_LABEL[maidLookAt.settingIndex]);
            }
        }

        #endregion

        #region GuiBackground
        private void SetBgAreaTop()
        {
            int baseRow = 2;
            var text = guiMgr.BackgroundLabel;
            var isClick = guiMgr.SetSaveField(baseRow, ref text);
            guiMgr.BackgroundLabel = text;
            if (isClick && !string.IsNullOrEmpty(text))
            {
                new FileWriter().WriteBackgroudList(text, bgMgr.GetBackgroundName());
                bgMgr.ReadBackgroundData();
            }

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "背景リスト", guiStyle.gsLabel);
            rect.x += rect.width * 2;
            if (GUI.Button(rect, "背景削除", guiStyle.gsButton))
            {
                bgMgr.DeleteBackground();
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton) || MyHelper.CheckNull(bgMgr.BackgroundDic))
            {
                bgMgr.ReadBackgroundData();
            }
        }

        private void SetBgAreaList()
        {
            int baseRow = 4;
            var labelList = bgMgr.BackgroundDic.Keys.ToList();
            var index = guiMgr.SetSelectionGrid(baseRow, labelList,
                                         MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow),
                                         ref scrollBackground);

            if (index != bgMgr.BackgroundDic.Count() - 1)
            {
                var key = labelList[index];
                if (bgMgr.BackgroundIndex != index ||
                    (!string.IsNullOrEmpty(bgMgr.BackgroundDic[key].bgName) &&
                     bgMgr.BackgroundDic[key].bgName != bgMgr.GetBackgroundName()))
                {
                    bgMgr.BackgroundIndex = index;
                    bgMgr.ChangeBackground(bgMgr.BackgroundDic[key]);
                    bgMgr.BgPosition = bgMgr.BackgroundDic[key].position;
                    bgMgr.BgRotation = bgMgr.BackgroundDic[key].rotation;
                    bgMgr.Scale = bgMgr.BackgroundDic[key].scale;
                }
            }
        }

        private void SetBgAreaTransform()
        {
            int baseRow = 2;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "座標変更", guiStyle.gsLabel);
            rect.x += rect.width * 3;
            if (GUI.Button(rect, "リセット", guiStyle.gsButton))
            {
                bgMgr.BgPosition = Vector3.zero;
                bgMgr.BgRotation = Vector3.zero;
                bgMgr.Scale = MyConst.SCALE_DEFAULT;
                bgMgr.SetBackgroundPosition(bgMgr.BgPosition);
                bgMgr.SetBackgroundRotation(bgMgr.BgRotation);
                bgMgr.SetBackgroundScale(bgMgr.Scale);
            }

            var pos = bgMgr.BgPosition;
            guiMgr.SetPositionSlider(baseRow + 1, ref pos, Vector3.zero);
            if (pos != bgMgr.BgPosition)
            {
                bgMgr.SetBackgroundPosition(pos);
                bgMgr.BgPosition = pos;
            }

            var rot = bgMgr.BgRotation;
            guiMgr.SetRotationSlider(baseRow + 4, ref rot, Vector3.zero);
            if (rot != bgMgr.BgRotation)
            {
                bgMgr.SetBackgroundRotation(rot);
                bgMgr.BgRotation = rot;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 7;
            var scale = guiMgr.SetOneLineSlider("サイズ", baseRow + 7, bgMgr.Scale,
                                                guiMgr.TransformSlider.scaleMin.z, guiMgr.TransformSlider.scaleMax.z,
                                                MyConst.SCALE_DEFAULT, MyConst.GUI_ONE_SLIDER_SMALL);
            if (scale != bgMgr.Scale)
            {
                bgMgr.SetBackgroundScale(scale);
                bgMgr.Scale = scale;
            }
        }

        private void SetBgAreaColor()
        {
            int baseRow = 11;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "空間色設定", guiStyle.gsLabel);
            rect.x += rect.width * 2;
            if (GUI.Button(rect, "背景削除", guiStyle.gsButton))
            {
                bgMgr.DeleteBackground();
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "リセット", guiStyle.gsButton))
            {
                bgMgr.BgColor = MyHelper.SetColorBlack();
                cameraMgr.SetBackgroundColor(bgMgr.BgColor);
            }

            var color = bgMgr.BgColor;
            guiMgr.SetColorSlider(baseRow + 1, ref color, false);
            if (!Equals(color, bgMgr.BgColor))
            {
                cameraMgr.SetBackgroundColor(bgMgr.BgColor);
                bgMgr.BgColor = color;
            }
        }

        private void SetBgAreaSkybox()
        {
            int baseRow = 16;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "Skybox(仮)", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 3;
            var skyboxSet = bgMgr.SkyboxSet;
            skyboxSet.isPngFoloder = GUI.Toggle(rect, skyboxSet.isPngFoloder, "PNGフォルダ指定(他フルパス指定)", guiStyle.gsToggle);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "テクスチャー", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 3;
            if (string.IsNullOrEmpty(skyboxSet.textureName))
            {
                skyboxSet.textureName = "";
            }
            skyboxSet.textureName = guiMgr.SetTextField(rect, skyboxSet.textureName);
            bgMgr.SkyboxSet = skyboxSet;

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            rect.x += rect.width;
            if (GUI.Button(rect, "設定", guiStyle.gsButton) && !string.IsNullOrEmpty(skyboxSet.textureName))
            {
                bgMgr.DeleteBackground();
                bgMgr.SetSkybox();
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "解除", guiStyle.gsButton))
            {
                bgMgr.ResetSkybox();
            }
        }

        private void SetBgAreaPartsTop()
        {
            int baseRow = 2;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            if (MyHelper.CheckNull(bgMgr.BgPartsDic))
            {
                rect.width *= 3;
                GUI.Label(rect, "背景パーツを追加してください", guiStyle.gsLabel);
            }
            else
            {
                var index = bgMgr.bgPartsIndex;
                GUI.Label(rect, "対象パーツ", guiStyle.gsLabel);
                guiMgr.SetIndexChangedButton(ref rect, bgMgr.BgPartsDic.Count(), ref index);
                var key = bgMgr.BgPartsDic.Keys.ToList()[index];
                guiMgr.SetIndexChangedLabel(rect, key);

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 1;
                rect.x += rect.width;
                if (GUI.Button(rect, "パーツ削除", guiStyle.gsButton))
                {
                    bgMgr.DestroyBgParts(key);
                    index = 0;
                }
                bgMgr.bgPartsIndex = index;
            }
        }

        private void SetBgAreaPartsList()
        {
            int baseRow = 4;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            GUI.Label(rect, "パーツリスト", guiStyle.gsLabel);
            rect.x += rect.width * 2;
            if (GUI.Button(rect, "背景削除", guiStyle.gsButton))
            {
                bgMgr.DeleteBackground();
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton) || MyHelper.CheckNull(bgMgr.BgPartsList))
            {
                bgMgr.GetBgPartsList();
            }

            var index = guiMgr.SetSelectionGrid(baseRow, bgMgr.BgPartsList,
                                         MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow),
                                         ref scrollBackgroundParts);

            if (index != bgMgr.BgPartsList.Count() - 1)
            {
                bgMgr.LoadBgParts(bgMgr.BgPartsList[index]);
            }
        }

        private void SetBgAreaInstanceComboList()
        {
            int baseRow = 2;
            if (MyHelper.CheckNull(bgMgr.BackgroundDic))
            {
                if (bgMgr.ReadBackgroundData())
                {
                    bgMgr.BackgroundIndex = bgMgr.BackgroundDic.Count() - 1;
                }
                else
                {
                    bgMgr.BackgroundIndex = 0;
                }
                bgMgr.BgInstanceIndex = 0;
            }
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "背景選択", guiStyle.gsLabel);
            if (!MyHelper.CheckNull(bgMgr.BackgroundDic))
            {
                var data = bgMgr.BackgroundDic.Keys.ToList();
                rect.x += rect.width;
                rect.width *= 3;
                if (GUI.Button(rect, data[bgMgr.BgInstanceIndex], guiStyle.gsCombo) && bgMgr.BackgroundDic.Count > 1)
                {
                    bgMgr.IsBgInstanceComboOn = !bgMgr.IsBgInstanceComboOn;
                }

                if (bgMgr.IsBgInstanceComboOn && bgMgr.BackgroundDic.Count > 1)
                {
                    var isBgComboOn = bgMgr.IsBgInstanceComboOn;
                    var index = guiMgr.SetCommboList(baseRow, data,
                                                     ref scrollBgInstanceList, ref isBgComboOn);
                    if (!isBgComboOn)
                    {
                        bgMgr.BgInstanceIndex = index;
                    }
                    bgMgr.IsBgInstanceComboOn = isBgComboOn;
                }
            }
        }

        private void SetBgAreaInstanceTop()
        {
            int baseRow = 3;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            if (GUI.Button(rect, "ロード", guiStyle.gsButton) && !MyHelper.CheckNull(bgMgr.BackgroundDic))
            {
                var key = bgMgr.BackgroundDic.Keys.ToList()[bgMgr.BgInstanceIndex];
                bgMgr.SetBgInstance(bgMgr.BackgroundDic[key].bgName);
            }

            rect.x += rect.width;
            if (GUI.Button(rect, "削除", guiStyle.gsButton))
            {
                bgMgr.DestroyBgInstance();
            }

            rect.x += rect.width;
            if (GUI.Button(rect, "一括表示", guiStyle.gsButton))
            {
                bgMgr.SetActiveAllBgInstance(true);
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "一括非表示", guiStyle.gsButton))
            {
                bgMgr.SetActiveAllBgInstance(false);
            }
        }

        private void SetBgAreaInstanceList()
        {
            int baseRow = 5;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;

            var bgName = "";
            if (!MyHelper.CheckNull(bgMgr.BackgroundDic))
            {
                var data = bgMgr.BackgroundDic.Keys.ToList();
                bgName = bgMgr.BackgroundDic[data[bgMgr.BgInstanceIndex]].bgName;
            }
            rect.width *= 3;
            var label = "パーツリスト:" + bgName;
            GUI.Label(rect, label, guiStyle.gsLabel);

            var labelList = bgMgr.GetBgInstanceLabelList();
            labelList = labelList.OrderByDescending(l => l).ToList();

            rect.x += rect.width;
            rect.width /= 3;
            if (GUI.Button(rect, "名称出力", guiStyle.gsButton))
            {
                if (!MyHelper.CheckNull(labelList))
                {
                    Console.WriteLine(label);
                    Console.WriteLine(string.Join(" ", labelList.ToArray()));
                }
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            var index = guiMgr.SetSelectionGrid(baseRow, labelList,
                                        MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow),
                                        ref scrollBackground);

            if (index != labelList.Count() - 1)
            {
                bgMgr.SetActiveOneBgInstance(labelList[index]);
            }
        }

        private void SetBgAreaForeground()
        {
            int baseRow = 3;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            rect.x += rect.width * 2;
            if (GUI.Button(rect, "一括解除", guiStyle.gsButton))
            {
                for (int i = 0; i < bgMgr.ForegroundSet.Count(); i++)
                {
                    bgMgr.DestoryForeground(i);
                }
            }
            rect.x += rect.width;
            GUI.Label(rect, "透明度(0-255)", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 4;
            rect.height *= bgMgr.ForegroundSet.Count() * 3;
            var viewRect = rect;
            viewRect.height = MyConst.GUI_HEIGHT * 9;
            scrollForeground = GUI.BeginScrollView(viewRect, scrollForeground, rect, false, true);

            for (int i = 0; i < bgMgr.ForegroundSet.Count(); i++)
            {
                var data = bgMgr.ForegroundSet[i];
                var ajustedRow = baseRow + i * 3;

                rect = MyConst.DEFAULT_RECT;
                rect.y *= ajustedRow + 1;
                rect.width *= 2;
                data.isFixedSize = GUI.Toggle(rect, data.isFixedSize, "固定サイズ(縦,横)", guiStyle.gsToggle);
                if (data.isFixedSize)
                {
                    rect.x += rect.width;
                    rect.width /= 2;
                    var d = data.width;
                    guiMgr.SetNumberField(rect, 0, ref d);
                    data.width = d;
                    rect.x += rect.width;
                    d = data.height;
                    guiMgr.SetNumberField(rect, 0, ref d);
                    data.height = d;
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= ajustedRow;
                rect.x += rect.width;
                rect.width *= 2;
                data.pngName = guiMgr.SetTextField(rect, data.pngName);
                rect.x += rect.width;
                rect.width /= 2;
                var a = (int)data.alpha;
                guiMgr.SetNumberField(rect, 0, ref a);
                data.alpha = a;
                bgMgr.ForegroundSet[i] = data;

                rect = MyConst.DEFAULT_RECT;
                rect.y *= ajustedRow;
                if (GUI.Button(rect, "PNG " + (i + 1) + " 表示", guiStyle.gsButton) && !string.IsNullOrEmpty(data.pngName))
                {
                    bgMgr.SetForeground(i);
                }
            }
            GUI.EndScrollView();
        }

        private void SetBgAreaMaidMask(List<Maid> maids)
        {
            int baseRow = 13;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "部位マスク", guiStyle.gsLabel);
            rect.x += rect.width;
            for (int i = 0; i < MyConst.MAID_MASK_LABEL.Count(); i++)
            {
                var isSelected = GUI.Toggle(rect, i == bgMgr.MaidMaskIndex, MyConst.MAID_MASK_LABEL[i], guiStyle.gsToggle);
                if (isSelected)
                {
                    bgMgr.MaidMaskIndex = i;
                }
                rect.x += rect.width;
            }

            var mask = bgMgr.MaidMaskDic[bgMgr.MaidMaskIndex];
            var isUpdate = false;
            var isCopy = false;
            if (GUI.Button(rect, "コピー", guiStyle.gsButton))
            {
                isCopy = true;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "マスクPNG", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 2;
            mask.pngName = guiMgr.SetTextField(rect, mask.pngName);
            rect.x += rect.width;
            rect.width /= 2;
            if (GUI.Button(rect, "設定", guiStyle.gsButton) && !string.IsNullOrEmpty(mask.pngName))
            {
                isUpdate = true;
                mask.isEnabled = true;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            GUI.Label(rect, "サイズ(縦,横)", guiStyle.gsLabel);
            rect.x += rect.width;
            var m = mask.width;
            guiMgr.SetNumberField(rect, 0, ref m);
            mask.width = m;
            rect.x += rect.width;
            m = mask.height;
            guiMgr.SetNumberField(rect, 0, ref m);
            mask.height = m;
            rect.x += rect.width;
            if (GUI.Button(rect, "全解除", guiStyle.gsButton))
            {
                bgMgr.DestoryMaidMask(true);
            }
            guiMgr.SetColorSlider(baseRow + 3, ref mask.color, true);

            foreach (int key in Enum.GetValues(typeof(MaidMaskParam)))
            {
                if (key == bgMgr.MaidMaskIndex || isCopy)
                {
                    bgMgr.MaidMaskDic[key] = mask;
                }
            }
            if (isUpdate)
            {
                bgMgr.SetMaidMask(maids, maidMgr);
            }
        }

        #endregion

        #region GuiStageObject

        private void SetStageObjectAreaTop()
        {
            int baseRow = 2;
            var stageeData = stageMgr.StageObjectData;

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            if (MyHelper.CheckNull(stageeData))
            {
                rect.width *= 3;
                GUI.Label(rect, "オブジェクトを追加してください", guiStyle.gsLabel);
            }
            else
            {
                GUI.Label(rect, "対象", guiStyle.gsLabel);
                guiMgr.SetIndexChangedButton(ref rect, stageeData.Count(), ref stageObjectIndex);
                guiMgr.SetIndexChangedLabel(rect, stageeData[stageObjectIndex].key + stageObjectIndex);
                stageMgr.StageObjectData = stageeData;

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 1;
                rect.x += rect.width;
                if (GUI.Button(rect, "削除", guiStyle.gsButton))
                {
                    stageMgr.DestroySatgeObjedt(stageObjectIndex);
                    stageObjectIndex = 0;
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "全削除", guiStyle.gsButton))
                {
                    stageMgr.DestroyAllSatgeObjedt();
                    stageObjectIndex = 0;
                }
                rect.x += rect.width;
                if (stageMgr.IsStageObjectSetting)
                {
                    stageMgr.IsStageObjectTransform = GUI.Toggle(rect, stageMgr.IsStageObjectTransform, ">色・座標", guiStyle.gsToggle);
                }
            }
        }

        private void SetStageObjectAreaList()
        {
            int baseRow = 5;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            rect.width *= 2;
            GUI.Label(rect, "オブジェクトリスト", guiStyle.gsLabel);
            rect.width /= 2;
            rect.x += rect.width * 3;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton) || MyHelper.CheckNull(stageMgr.StageObjectList))
            {
                stageMgr.GetStageObjectList();
            }

            var index = guiMgr.SetSelectionGrid(baseRow, stageMgr.StageObjectList,
                                         MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow),
                                         ref scrollStageObject);

            if (index != stageMgr.StageObjectList.Count() - 1)
            {
                stageMgr.CreateSatgeObjedt(index, renderTextureSet, maidMgr);
                if (!MyHelper.CheckNull(stageMgr.StageObjectData))
                {
                    stageObjectIndex = stageMgr.StageObjectData.Count() - 1;
                }
            }
        }

        private void SetStageObjectAreaOption(List<Maid> maids)
        {
            int baseRow = 5;
            if (!MyHelper.CheckNull(stageMgr.StageObjectData))
            {
                var data = stageMgr.StageObjectData[stageObjectIndex];
                var type = stageMgr.GetStageObjectType(data.key);
                if (type == (PrimitiveType)MyConst.STAGE_OBJECT_SCREEN ||
                    type == (PrimitiveType)MyConst.STAGE_OBJECT_CURVED_SCREEN)
                {
                    data = SetStageObjectAreaOptionScreen(maids, baseRow, data);
                }
                else if (type != (PrimitiveType)MyConst.STAGE_OBJECT_MIRROR)
                {
                    if (!data.videoMgr.IsPlayed())
                    {
                        data = SetStageObjectAreaOptionCommon(baseRow, data);
                    }
                    if (type == (PrimitiveType)MyConst.STAGE_OBJECT_LINE)
                    {
                        data = SetStageObjectAreaOptionLine(baseRow, data);
                    }
                    else if (type == (PrimitiveType)MyConst.STAGE_OBJECT_POLE)
                    {
                        data = SetStageObjectAreaOptionPole(maids, baseRow, data);
                    }
                    else
                    {
                        data = SetStageObjectAreaOptionVideo(baseRow + 5, data);
                    }
                }
                stageMgr.StageObjectData[stageObjectIndex] = data;
            }
        }

        private FreeStageObjectSet SetStageObjectAreaOptionScreen(List<Maid> maids, int baseRow, FreeStageObjectSet data)
        {
            if (!MyHelper.CheckNull(maids))
            {
                SetLookAtAreaCameraSetting(maids, baseRow, true, ref data.maidLookAt);
                var isUnderWear = false;
                var isNude = false;

                var rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 8;
                rect.width *= 2;
                GUI.Label(rect, "脱衣設定(未対応MODあり)", guiStyle.gsLabel);
                rect.x += rect.width;
                rect.width /= 2;
                rect.x += rect.width;
                if (GUI.Button(rect, "元衣装設定", guiStyle.gsButton))
                {
                    dressMgr.ResetDressMenu(maids);
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 9;
                if (GUI.Button(rect, "体表示", guiStyle.gsButton))
                {
                    stageMgr.ViewMaidBody(maids);
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "下着", guiStyle.gsButton))
                {
                    isUnderWear = true;
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "丸見え", guiStyle.gsButton))
                {
                    isNude = true;
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "マスク全解除", guiStyle.gsButton))
                {
                    stageMgr.ClearAllMask(maids);
                    stageMgr.ViewMaidBody(maids);
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 10;
                if (GUI.Button(rect, "脱衣", guiStyle.gsButton))
                {
                    stageMgr.SetScreenUndress(true);
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "着衣", guiStyle.gsButton))
                {
                    stageMgr.SetScreenUndress(false);
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "マスクON", guiStyle.gsButton))
                {
                    stageMgr.SetMask(maids, true);
                    stageMgr.ViewMaidBody(maids);
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "マスクOFF", guiStyle.gsButton))
                {
                    stageMgr.SetMask(maids, false);
                    stageMgr.ViewMaidBody(maids);
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 11;
                int index = 0;
                foreach (var pair in MyConst.UNDRESS_SLOT.Where(d => 0 < d.Key))
                {
                    if (index > 0 && index % MyConst.MAX_COLUMN == 0)
                    {
                        rect.y += rect.height;
                        rect.x = MyConst.DEFAULT_RECT.x;
                    }
                    stageMgr.ScreenUndressDic[pair.Key] = GUI.Toggle(rect, stageMgr.ScreenUndressDic[pair.Key], pair.Value, guiStyle.gsToggle);
                    rect.x += rect.width;
                    index++;
                }
                foreach (var pair in MyConst.SCREEN_UNDRESS_EXTRA_SLOT)
                {
                    if (index > 0 && index % MyConst.MAX_COLUMN == 0)
                    {
                        rect.y += rect.height;
                        rect.x = MyConst.DEFAULT_RECT.x;
                    }
                    stageMgr.ScreenUndressDic[pair.Key] = GUI.Toggle(rect, stageMgr.ScreenUndressDic[pair.Key], pair.Value, guiStyle.gsToggle);
                    rect.x += rect.width;
                    index++;
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 14;
                var isAll = false;
                var isCheck = false;
                if (GUI.Button(rect, "全てON", guiStyle.gsButton))
                {
                    isAll = true;
                    isCheck = true;
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "全てOFF", guiStyle.gsButton))
                {
                    isAll = true;
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "設定取得", guiStyle.gsButton))
                {
                    stageMgr.ReadSettingXml();
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "情報出力", guiStyle.gsButton))
                {
                    stageMgr.ExportScreenUndressList();
                }

                if (isAll || isUnderWear || isNude)
                {
                    ChekStageObjectAreaOptionScreen(isCheck);
                }
                if (isUnderWear)
                {
                    stageMgr.ScreenUndressDic[TBody.SlotID.bra] = true;
                    stageMgr.ScreenUndressDic[TBody.SlotID.panz] = true;
                    stageMgr.SetMask(maids, false);
                    ChekStageObjectAreaOptionScreen(false);
                    stageMgr.ScreenUndressDic[TBody.SlotID.chikubi] = true;
                    stageMgr.ScreenUndressDic[TBody.SlotID.underhair] = true;
                    stageMgr.SetMask(maids, true);
                    ChekStageObjectAreaOptionScreen(false);
                    stageMgr.ScreenUndressDic[TBody.SlotID.wear] = true;
                    stageMgr.ScreenUndressDic[TBody.SlotID.skirt] = true;
                    stageMgr.ScreenUndressDic[TBody.SlotID.onepiece] = true;
                    stageMgr.SetScreenUndress(true);
                    ChekStageObjectAreaOptionScreen(false);
                    stageMgr.ScreenUndressDic[TBody.SlotID.bra] = true;
                    stageMgr.ScreenUndressDic[TBody.SlotID.panz] = true;
                    stageMgr.SetScreenUndress(false);
                    stageMgr.ViewMaidBody(maids);
                }
                if (isNude)
                {
                    stageMgr.ScreenUndressDic[TBody.SlotID.chikubi] = true;
                    stageMgr.ScreenUndressDic[TBody.SlotID.underhair] = true;
                    stageMgr.SetMask(maids, false);
                    ChekStageObjectAreaOptionScreen(false);
                    stageMgr.ScreenUndressDic[TBody.SlotID.wear] = true;
                    stageMgr.ScreenUndressDic[TBody.SlotID.skirt] = true;
                    stageMgr.ScreenUndressDic[TBody.SlotID.onepiece] = true;
                    stageMgr.ScreenUndressDic[TBody.SlotID.mizugi] = true;
                    stageMgr.ScreenUndressDic[TBody.SlotID.bra] = true;
                    stageMgr.ScreenUndressDic[TBody.SlotID.panz] = true;
                    stageMgr.SetScreenUndress(true);
                    stageMgr.ViewMaidBody(maids);
                }
            }
            else
            {
                SetMenuAreaNoMaid(baseRow);
            }
            return data;
        }

        private void ChekStageObjectAreaOptionScreen(bool isCheck)
        {
            foreach (var key in stageMgr.ScreenUndressDic.Keys.ToList())
            {
                stageMgr.ScreenUndressDic[key] = isCheck;
            }
        }

        private FreeStageObjectSet SetStageObjectAreaOptionVideo(int baseRow, FreeStageObjectSet data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "１回転秒数", guiStyle.gsLabel);
            rect.x += rect.width;
            var time = stageMgr.RotatedTime;
            guiMgr.SetNumberField(rect, 0f, ref time);
            stageMgr.RotatedTime = time;
            rect.x += rect.width;
            var isRotating = stageMgr.IsRotatingITween();
            if (GUI.Button(rect, isRotating ? "停止" : "横回転", guiStyle.gsButton))
            {
                if (isRotating)
                {
                    stageMgr.StopITween(data.stageObject, data.rotation);
                }
                else
                {
                    stageMgr.RotateToITween(data.stageObject);
                }
            }
            rect.x += rect.width;
            stageMgr.IsTurnedRight = GUI.Toggle(rect, stageMgr.IsTurnedRight, "右回転", guiStyle.gsToggle);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            GUI.Label(rect, "映像", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 3;
            data.videoMgr.VideoName = guiMgr.SetTextField(rect, data.videoMgr.VideoName);

            var isPlayed = data.videoMgr.IsPlayed();
            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 3;
            rect.x += rect.width;
            if (GUI.Button(rect, isPlayed ? "停止" : "再生", guiStyle.gsButton))
            {
                if (isPlayed)
                {
                    data.videoMgr.EndVideo();
                    stageMgr.StopITween(data.stageObject, data.rotation);
                }
                else
                {
                    data.videoMgr.LoadStageObjectVideo(data.stageObject, data.isCurved);
                }
            }

            if (isPlayed)
            {
                rect.x += rect.width;
                var isPause = data.videoMgr.IsPause();
                if (GUI.Button(rect, isPause ? "再開" : "一時停止", guiStyle.gsButton))
                {
                    data.videoMgr.PauseVideo(!isPause);
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 5;
                rect.width *= 2;
                GUI.Label(rect, "現在タイム:" + data.videoMgr.GetCurrentTime().ToString(MyConst.DECIMAL_FORMAT), guiStyle.gsLabel);
                rect.x += rect.width;
                rect.width /= 2;
                time = data.videoMgr.SeekTime;
                guiMgr.SetNumberField(rect, 0f, ref time);
                data.videoMgr.SeekTime = time;
                rect.x += rect.width;
                if (GUI.Button(rect, "シーク", guiStyle.gsButton))
                {
                    data.videoMgr.SeekVideo(time);
                }
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 4;
            rect.x += rect.width;
            data.videoMgr.IsLooping = GUI.Toggle(rect, data.videoMgr.IsLooping, "ループ再生", guiStyle.gsToggle);
            rect.x += rect.width;
            data.videoMgr.IsMuted = GUI.Toggle(rect, data.videoMgr.IsMuted, "音声ミュート", guiStyle.gsToggle);
            rect.x += rect.width;
            data.videoMgr.IsTransparent = GUI.Toggle(rect, data.videoMgr.IsTransparent, "透過", guiStyle.gsToggle);
            if (!data.videoMgr.IsMuted && !isPlayed)
            {
                var volume = data.videoMgr.Volume;
                data.videoMgr.Volume = guiMgr.SetOneLineSlider("ボリューム", baseRow + 6, volume, 0f, MyConst.VOLUME_MAX, MyConst.VOLUME_MAX / 10f, MyConst.VOLUME_MAX / 10f);
            }
            return data;
        }

        private FreeStageObjectSet SetStageObjectAreaOptionLine(int baseRow, FreeStageObjectSet data)
        {
            var frameWidth = data.lineSet.frameWidth;
            frameWidth = guiMgr.SetOneLineSlider("線幅", baseRow + 4, frameWidth,
                                        MyConst.GUI_ONE_SLIDER_MIN, MyConst.GUI_ONE_SLIDER_NORMAL, MyConst.LINE_FRAME_WIDTH, MyConst.GUI_ONE_SLIDER_SMALL);
            var numCornerVertices = data.lineSet.numCornerVertices;
            numCornerVertices = (int)guiMgr.SetOneLineSlider("角丸み", baseRow + 5, numCornerVertices,
                                        MyConst.GUI_ONE_SLIDER_MIN, MyConst.GUI_ONE_SLIDER_NORMAL * 100, MyConst.LINE_FRAME_NUM_CORNER, MyConst.GUI_ONE_SLIDER_NORMAL);
            if (frameWidth != data.lineSet.frameWidth || numCornerVertices != data.lineSet.numCornerVertices)
            {
                var renderer = data.stageObject.GetOrAddComponent<LineRenderer>();
                renderer.startWidth = frameWidth;
                renderer.endWidth = frameWidth;
                renderer.numCornerVertices = numCornerVertices;
                data.lineSet.frameWidth = frameWidth;
                data.lineSet.numCornerVertices = numCornerVertices;
            }
            return data;
        }

        private FreeStageObjectSet SetStageObjectAreaOptionPole(List<Maid> maids, int baseRow, FreeStageObjectSet data)
        {
            if (!MyHelper.CheckNull(maids))
            {
                var maidIndex = data.maidIndex;
                maidIndex =
                    guiMgr.SetSelectedMaidButton(baseRow + 4, maids, maidIndex, maidMgr);
                if (maidIndex != data.maidIndex)
                {
                    data.maidIndex = maidIndex;
                }

                var rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 5;
                rect.x += rect.width;
                if (GUI.Button(rect, "位置調整", guiStyle.gsButton))
                {
                    stageMgr.SetPolePosition(stageObjectIndex, maids[data.maidIndex].transform.position);
                }
            }
            return data;
        }

        private FreeStageObjectSet SetStageObjectAreaOptionCommon(int baseRow, FreeStageObjectSet data)
        {
            var isUpdate = false;
            var isTexture = false;

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "テクスチャー", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 3;
            data.textureName = guiMgr.SetTextField(rect, data.textureName);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            data.isTrans = GUI.Toggle(rect, data.isTrans, "透過", guiStyle.gsToggle);
            rect.x += rect.width;
            var isCheck = data.isLight;
            data.isLight = GUI.Toggle(rect, data.isLight, "発光", guiStyle.gsToggle);
            if (isCheck != data.isLight)
            {
                data.isUnlight = false;
                isUpdate = true;
            }
            rect.x += rect.width;
            isCheck = data.isUnlight;
            data.isUnlight = GUI.Toggle(rect, data.isUnlight, "発光(常時)", guiStyle.gsToggle);
            if (isCheck != data.isUnlight)
            {
                data.isLight = false;
                isUpdate = true;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            data.isRepeat = GUI.Toggle(rect, data.isRepeat, "リピート", guiStyle.gsToggle);
            rect.x += rect.width;
            GUI.Label(rect, "サイズ(横,縦)", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, MyConst.SCALE_DEFAULT, ref data.textureScaleX);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, MyConst.SCALE_DEFAULT, ref data.textureScaleY);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 3;
            rect.x += rect.width;
            if (GUI.Button(rect, "設定", guiStyle.gsButton))
            {
                isTexture = true;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "解除", guiStyle.gsButton))
            {
                stageMgr.RemoveStageObjcetTexture(stageObjectIndex);
            }
            else
            {
                stageMgr.StageObjectData[stageObjectIndex] = data;
                if (isTexture || isUpdate)
                {
                    stageMgr.SetStageObjectMaterial(stageObjectIndex, isTexture);
                }
            }
            return data;
        }

        private void SetStageObjectAreaTransform()
        {
            int baseRow = 5;
            if (!MyHelper.CheckNull(stageMgr.StageObjectData))
            {
                var isUpdate = false;
                var data = stageMgr.StageObjectData[stageObjectIndex];

                var compare = data.position;
                guiMgr.SetPositionSlider(baseRow, ref data.position, Vector3.zero);
                if (compare != data.position)
                {
                    data.stageObject.transform.position = data.position;
                    isUpdate = true;
                }

                compare = data.rotation;
                guiMgr.SetRotationSlider(baseRow + 3, ref data.rotation, Vector3.zero);
                if (compare != data.rotation)
                {
                    data.stageObject.transform.rotation = Quaternion.Euler(data.rotation);
                    isUpdate = true;
                }

                compare = data.scale;
                guiMgr.SetScaleSlider(baseRow + 6, ref data.scale);
                if (compare != data.scale)
                {
                    data.stageObject.transform.localScale = data.scale;
                    isUpdate = true;
                }

                var min = guiMgr.TransformSlider.scaleMin.z;
                var max = guiMgr.TransformSlider.scaleMax.z;
                var label = "サイズ一括";
                var type = stageMgr.GetStageObjectType(data.key);
                var value = data.allScale;
                switch (type)
                {
                    case (PrimitiveType)MyConst.STAGE_OBJECT_SCREEN:
                    case (PrimitiveType)MyConst.STAGE_OBJECT_CURVED_SCREEN:
                        value = guiMgr.SetOneLineSlider(label, baseRow + 9, value, min, max, MyConst.SCALE_DEFAULT, MyConst.GUI_ONE_SLIDER_SMALL);
                        if (value != data.allScale)
                        {
                            data.allScale = value;
                            data.scale = new Vector3(value, 1f, value * MyConst.SCREEN_RATIO_HEIGH / MyConst.SCREEN_RATIO_WIDTH);
                            data.stageObject.transform.localScale = data.scale;
                        }

                        var rect = MyConst.DEFAULT_RECT;
                        rect.y *= baseRow + 11;
                        var isTrans = data.isTrans;
                        isTrans = GUI.Toggle(rect, isTrans, "透明度", guiStyle.gsToggle);
                        var color = data.color;
                        if (isTrans)
                        {
                            guiMgr.SetAlphaSlider(baseRow + 11, ref data.color);
                        }
                        if (isTrans != data.isTrans || !Equals(color, data.color))
                        {
                            data.isTrans = isTrans;
                            stageMgr.SetSatgeObjedtScreenAlpha(data.stageObject, data.color, isTrans);
                        }
                        break;
                    case (PrimitiveType)MyConst.STAGE_OBJECT_MIRROR:
                        value = guiMgr.SetOneLineSlider(label, baseRow + 9, value, min, max, MyConst.SCALE_DEFAULT, MyConst.GUI_ONE_SLIDER_SMALL);
                        if (value != data.allScale)
                        {
                            data.allScale = value;
                            data.scale = new Vector3(value, 1f, value);
                            data.stageObject.transform.localScale = data.scale;
                        }
                        break;

                    default:
                        value = guiMgr.SetOneLineSlider(label, baseRow + 9, value, min, max, MyConst.SCALE_DEFAULT, MyConst.GUI_ONE_SLIDER_SMALL);
                        if (value != data.allScale)
                        {
                            data.allScale = value;
                            data.scale = new Vector3(value, value, value);
                            data.stageObject.transform.localScale = data.scale;
                            isUpdate = true;
                        }

                        var colorCompare = data.color;
                        guiMgr.SetColorSlider(baseRow + 11, ref data.color, true);
                        if (!Equals(colorCompare, data.color))
                        {
                            stageMgr.SetSatgeObjedtColor(data.stageObject, data.color);
                            isUpdate = true;
                        }
                        break;
                }

                if (isUpdate && !string.IsNullOrEmpty(data.lineSet.type))
                {
                    var objMgr = new DanceObjectManager(data.lineSet);
                    objMgr.TransformLine(data.stageObject, data.lineSet.type);
                }
                stageMgr.StageObjectData[stageObjectIndex] = data;
            }
        }

        #endregion

        #region GuiStageModel
        private void SetModelAreaMenu()
        {
            int baseRow = 2;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "対象", guiStyle.gsLabel);
            if (!MyHelper.CheckNull(modelMgr.ModelData))
            {
                guiMgr.SetIndexChangedButton(ref rect, modelMgr.ModelData.Count(), ref modModelIndex);
                guiMgr.SetIndexChangedLabel(rect, modelMgr.ModelData[modModelIndex].viewName);

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 1;
                rect.x += rect.width * 3;
                if (GUI.Button(rect, "削除", guiStyle.gsButton))
                {
                    modelMgr.DeleteModModel(modModelIndex);
                    modModelIndex = 0;
                }
                rect.x -= rect.width * 3;
            }
            else
            {
                rect.x += rect.width;
                rect.width *= 3;
                GUI.Label(rect, "モデルがありません", guiStyle.gsLabel);

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 1;
            }
            rect.width *= 3;
            GUI.Label(rect, ".model指定(拡張子不要)", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            if (GUI.Button(rect, "ロード", guiStyle.gsButton) && !string.IsNullOrEmpty(inputModel))
            {
                if (modelMgr.LoadModel(inputModel, false))
                {
                    modModelIndex = modelMgr.ModelData.Count() - 1;
                }
            }
            rect.x += rect.width;
            rect.width *= 3;
            inputModel = guiMgr.SetTextField(rect, inputModel);
        }

        private void SetModelAreaList()
        {
            int baseRow = 7;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            GUI.Label(rect, "モデルリスト", guiStyle.gsLabel);
            rect.x += rect.width * 3;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton) || MyHelper.CheckNull(modelMgr.ModelList))
            {
                modelMgr.ReadModeLabel();
            }

            var index = guiMgr.SetSelectionGrid(baseRow, modelMgr.ModelList,
                                         MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow),
                                         ref scrollStageModel);

            if (index != modelMgr.ModelList.Count() - 1)
            {
                if (modelMgr.LoadModel(modelMgr.ModelList[index], true))
                {
                    modModelIndex = modelMgr.ModelData.Count() - 1;
                }
            }
        }

        private void SetModelAreaTransform(List<Maid> maids)
        {
            int baseRow = 6;
            if (!MyHelper.CheckNull(modelMgr.ModelData))
            {
                var data = modelMgr.ModelData[modModelIndex];

                var compare = data.position;
                guiMgr.SetPositionSlider(baseRow, ref data.position, Vector3.zero);
                if (compare != data.position)
                {
                    data.modelObject.transform.position = data.position;
                }

                compare = data.rotation;
                guiMgr.SetRotationSlider(baseRow + 3, ref data.rotation, Vector3.zero);
                if (compare != data.rotation)
                {
                    data.modelObject.transform.rotation = Quaternion.Euler(data.rotation);
                }

                compare = data.scale;
                guiMgr.SetScaleSlider(baseRow + 6, ref data.scale);
                if (compare != data.scale)
                {
                    data.modelObject.transform.localScale = data.scale;
                }

                var min = guiMgr.TransformSlider.scaleMin.z;
                var max = guiMgr.TransformSlider.scaleMax.z;
                var label = "サイズ一括";
                var value = data.allScale;
                value = guiMgr.SetOneLineSlider(label, baseRow + 9, value, min, max, MyConst.SCALE_DEFAULT, MyConst.GUI_ONE_SLIDER_NORMAL);
                if (value != data.allScale)
                {
                    data.allScale = value;
                    data.scale = new Vector3(value, value, value);
                    data.modelObject.transform.localScale = data.scale;
                }

                var rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 11;
                rect.width *= 2;
                data.isFollowing = GUI.Toggle(rect, data.isFollowing, "メイド追従ON", guiStyle.gsToggle);

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 12;

                data.maidIndex =
                    guiMgr.SetSelectedMaidButton(baseRow + 12, maids, data.maidIndex, maidMgr);

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 13;
                GUI.Label(rect, "追従ポイント", guiStyle.gsLabel);
                rect.x += rect.width;
                var parts = MyConst.MODEL_FOLLOWING_POINT_LABEL;
                rect.width *= 3f / parts.Count();
                for (int i = 0; i < parts.GetLength(0); i++)
                {
                    var isSelected = GUI.Toggle(rect, i == data.pointIndex, parts[i], guiStyle.gsToggle);
                    if (isSelected && i != data.pointIndex)
                    {
                        data.pointIndex = i;
                    }
                    rect.x += rect.width;
                }

                modelMgr.ModelData[modModelIndex] = data;
            }
        }
        #endregion

        #region GuiStageParticle
        private void SetBubbleLameAreaMenu()
        {
            int baseRow = 2;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            if (MyHelper.CheckNull(particleMgr.BubbleLameData))
            {
                rect.width *= 3;
                GUI.Label(rect, "泡・ラメを追加してください", guiStyle.gsLabel);
            }
            else
            {
                var menu = MyConst.STAGE_PARTICLE_LABEL;
                for (int i = 0; i < menu.Count(); i++)
                {
                    var isSelected = GUI.Toggle(rect, i == particleMgr.BubbleLameMenuIndex, menu[i], guiStyle.gsToggle);
                    if (isSelected && i != particleMgr.BubbleLameMenuIndex)
                    {
                        particleMgr.BubbleLameMenuIndex = i;
                    }
                    rect.x += rect.width;
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 1;
                var index = particleMgr.BubbleLameIndex;
                GUI.Label(rect, "対象", guiStyle.gsLabel);
                guiMgr.SetIndexChangedButton(ref rect, particleMgr.BubbleLameData.Count(), ref index);
                var label = particleMgr.BubbleLameData[index].label;
                guiMgr.SetIndexChangedLabel(rect, label);
                particleMgr.BubbleLameIndex = index;
            }
        }

        private void SetBubbleLameList()
        {
            int baseRow = 6;
            var text = particleMgr.BubbleLameLable;
            var isClick = guiMgr.SetSaveField(baseRow - 2, ref text);
            particleMgr.BubbleLameLable = text;
            if (isClick && !string.IsNullOrEmpty(text))
            {
                var data = particleMgr.BubbleLameData[particleMgr.BubbleLameIndex];
                new FileWriter().WriteBubleLameList(data, text);
                data.label = text + particleMgr.BubbleLameData.Count().ToString("00");
                particleMgr.BubbleLameData[particleMgr.BubbleLameIndex] = data;
                particleMgr.GetBubbleLameList();
            }

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            rect.width *= 2;
            GUI.Label(rect, "泡・ラメリスト", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width /= 2;
            if (GUI.Button(rect, "削除", guiStyle.gsButton) && !MyHelper.CheckNull(particleMgr.BubbleLameData))
            {
                particleMgr.DestroyBubbleLame();
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton) || MyHelper.CheckNull(particleMgr.BubbleLameList))
            {
                particleMgr.GetBubbleLameList();
            }

            var index = guiMgr.SetSelectionGrid(baseRow, particleMgr.BubbleLameList,
                                         MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow),
                                         ref scrollStageBubbleLame);
            if (index != particleMgr.BubbleLameList.Count() - 1)
            {
                particleMgr.LoadBubbleLame(particleMgr.BubbleLameList[index]);
            }
        }

        private void SetBubbleLameAreaModule()
        {
            int baseRow = 4;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            if (!MyHelper.CheckNull(particleMgr.BubbleLameData))
            {
                var data = particleMgr.BubbleLameData[particleMgr.BubbleLameIndex];

                data.minSize = guiMgr.SetOneLineSlider("サイズ最小", baseRow, data.minSize, 0f, 1f, 0.05f, MyConst.GUI_ONE_SLIDER_SMALL);
                data.maxSize = guiMgr.SetOneLineSlider("サイズ最大", baseRow + 1, data.maxSize, 0f, 1f, 0.3f, MyConst.GUI_ONE_SLIDER_SMALL);

                data.minEnergy = guiMgr.SetOneLineSlider("生存時間最小", baseRow + 2, data.minEnergy, 0f, 10f, 5f, MyConst.GUI_ONE_SLIDER_NORMAL);
                data.maxEnergy = guiMgr.SetOneLineSlider("生存時間最大", baseRow + 3, data.maxEnergy, 0f, 10f, 5f, MyConst.GUI_ONE_SLIDER_NORMAL);

                data.minEmission = guiMgr.SetOneLineSlider("発生個数最小", baseRow + 4, data.minEmission, 0f, 100f, 10f, MyConst.GUI_ONE_SLIDER_NORMAL);
                data.maxEmission = guiMgr.SetOneLineSlider("発生個数最大", baseRow + 5, data.maxEmission, 0f, 100f, 20f, MyConst.GUI_ONE_SLIDER_NORMAL);

                data.worldVelocity.x = guiMgr.SetOneLineSlider("初期速度X", baseRow + 6, data.worldVelocity.x, -1f, 1f, 0f, MyConst.GUI_ONE_SLIDER_SMALL);
                data.worldVelocity.y = guiMgr.SetOneLineSlider("初期速度Y", baseRow + 7, data.worldVelocity.y, -1f, 1f, 0f, MyConst.GUI_ONE_SLIDER_SMALL);
                data.worldVelocity.z = guiMgr.SetOneLineSlider("初期速度Z", baseRow + 8, data.worldVelocity.z, -1f, 1f, 0f, MyConst.GUI_ONE_SLIDER_SMALL);

                data.rndVelocity.x = guiMgr.SetOneLineSlider("ランダム速度X", baseRow + 9, data.rndVelocity.x, 0f, 1f, 1f, MyConst.GUI_ONE_SLIDER_SMALL);
                data.rndVelocity.y = guiMgr.SetOneLineSlider("ランダム速度Y", baseRow + 10, data.rndVelocity.y, 0f, 1f, 1f, MyConst.GUI_ONE_SLIDER_SMALL);
                data.rndVelocity.z = guiMgr.SetOneLineSlider("ランダム速度Z", baseRow + 11, data.rndVelocity.z, 0f, 1f, 1f, MyConst.GUI_ONE_SLIDER_SMALL);

                data.angularVelocity = guiMgr.SetOneLineSlider("放出角速度", baseRow + 12, data.angularVelocity, 0f, 1f, 0f, MyConst.GUI_ONE_SLIDER_SMALL);
                data.rndAngularVelocity = guiMgr.SetOneLineSlider("ランダム角速度", baseRow + 13, data.rndAngularVelocity, 0f, 1f, 0f, MyConst.GUI_ONE_SLIDER_SMALL);

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 14;
                data.rndRotation = GUI.Toggle(rect, data.rndRotation, "ランダム回転", guiStyle.gsToggle);

                particleMgr.BubbleLameData[particleMgr.BubbleLameIndex] = data;
                particleMgr.SetBubbleLameParameter(true, false);
            }
        }

        private void SetBubbleLameAreaPosition()
        {
            int baseRow = 4;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            if (!MyHelper.CheckNull(particleMgr.BubbleLameData))
            {
                var data = particleMgr.BubbleLameData[particleMgr.BubbleLameIndex];

                guiMgr.SetPositionSlider(baseRow, ref data.position, Vector3.zero);
                guiMgr.SetRotationSlider(baseRow + 3, ref data.rotation, Vector3.zero);
                guiMgr.SetColorSlider(baseRow + 6, ref data.color, true);

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 11;
                GUI.Label(rect, "テクスチャー", guiStyle.gsLabel);
                rect.x += rect.width;
                rect.width *= 3;
                data.textureName = guiMgr.SetTextField(rect, data.textureName);

                var isTexture = false;
                var isRemove = false;
                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 12;
                rect.x += rect.width;
                if (GUI.Button(rect, "設定", guiStyle.gsButton))
                {
                    isTexture = true;
                }
                rect.x += rect.width;
                if (GUI.Button(rect, "解除", guiStyle.gsButton))
                {
                    isRemove = true;
                }
                particleMgr.BubbleLameData[particleMgr.BubbleLameIndex] = data;
                particleMgr.SetBubbleLameParameter(isTexture, isRemove);
            }
        }

        private void SetParticleAreaMenu()
        {
            int baseRow = 2;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            if (MyHelper.CheckNull(particleMgr.ParticleData))
            {
                rect.width *= 3;
                GUI.Label(rect, "パーティクルを追加してください", guiStyle.gsLabel);
            }
            else
            {
                rect.width = rect.width * 4 / 6;
                foreach (int type in Enum.GetValues(typeof(ParticleModuleType)))
                {
                    var name = type == 0 ? ">読込" : ">設定" + type;
                    var isSelected = GUI.Toggle(rect, particleMgr.ParticleMenuIndex == type, name, guiStyle.gsToggle);
                    if (isSelected)
                    {
                        particleMgr.ParticleMenuIndex = type;
                    }
                    rect.x += rect.width;
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 1;
                var index = particleMgr.ParticleIndex;
                GUI.Label(rect, "対象", guiStyle.gsLabel);
                guiMgr.SetIndexChangedButton(ref rect, particleMgr.ParticleData.Count(), ref index);
                var label = particleMgr.ParticleData[index].label + index;
                guiMgr.SetIndexChangedLabel(rect, label);
                particleMgr.ParticleIndex = index;
            }
        }

        private void SetParticleAreaList()
        {
            int baseRow = 6;

            /*
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 3;
            GUI.Label(rect, "公式(Particle/)", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 2;
            particleMgr.OfficialLable = guiMgr.SetTextField(rect, particleMgr.OfficialLable);
            rect.x += rect.width;
            rect.width /= 2;
            if (GUI.Button(rect, "読込", guiStyle.gsButton) && !string.IsNullOrEmpty(particleMgr.OfficialLable))
            {
                particleMgr.LoadOfficialParticle(particleMgr.OfficialLable);
            }
            */

            var text = particleMgr.ParticleLable;
            var isClick = guiMgr.SetSaveField(baseRow - 2, ref text);
            particleMgr.ParticleLable = text;
            if (isClick && !string.IsNullOrEmpty(text))
            {
                var data = particleMgr.ParticleData[particleMgr.ParticleIndex];
                new FileWriter().WriteParticleList(data, text);
                data.label = text + particleMgr.ParticleData.Count().ToString("00");
                particleMgr.ParticleData[particleMgr.ParticleIndex] = data;
                particleMgr.GetParticleList();
            }

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            rect.width *= 2;
            GUI.Label(rect, "パーティクルリスト", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width /= 2;
            if (GUI.Button(rect, "削除", guiStyle.gsButton) && !MyHelper.CheckNull(particleMgr.ParticleData))
            {
                particleMgr.DestroyParticle();
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton) || MyHelper.CheckNull(particleMgr.ParticleList))
            {
                particleMgr.GetParticleList();
            }

            var index = guiMgr.SetSelectionGrid(baseRow, particleMgr.ParticleList,
                                         MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow),
                                         ref scrollStageParticle);
            if (index != particleMgr.ParticleList.Count() - 1)
            {
                particleMgr.LoadParticle(index);
            }
        }

        private void SetParticleAreaModule()
        {
            var index = particleMgr.ParticleIndex;
            var data = particleMgr.ParticleData[index];

            int baseRow = 5;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            if (GUI.Button(rect, "設定更新", guiStyle.gsButton))
            {
                data.particle = particleMgr.UpdateParticle(data, false, true);
                particleMgr.PlayParticle(true);
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "停止/再開", guiStyle.gsButton))
            {
                particleMgr.PlayParticle(false);
            }
            rect.x += rect.width * 2;
            if (GUI.Button(rect, "クリア", guiStyle.gsButton))
            {
                particleMgr.PlayParticle(true);
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            var viewRect = rect;
            viewRect.width *= 4;
            viewRect.height = MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow);
            switch (particleMgr.ParticleMenuIndex)
            {
                case (int)ParticleModuleType.ModGroup1:
                    rect.height *= 29;
                    scrollStageParticleModule1 = GUI.BeginScrollView(viewRect, scrollStageParticleModule1, rect, false, true);
                    SetParticleAreaModule(baseRow, ref data.main);
                    SetParticleAreaModule(baseRow + 10, ref data.emission);
                    SetParticleAreaModule(baseRow + 16, ref data.shape);
                    GUI.EndScrollView();
                    break;
                case (int)ParticleModuleType.ModGroup2:
                    rect.height *= 24;
                    scrollStageParticleModule2 = GUI.BeginScrollView(viewRect, scrollStageParticleModule2, rect, false, true);
                    SetParticleAreaModule(baseRow, ref data.colorOverLifetime);
                    SetParticleAreaModule(baseRow + 12, ref data.colorBySpeed);
                    GUI.EndScrollView();
                    break;
                case (int)ParticleModuleType.ModGroup3:
                    rect.height *= 43;
                    scrollStageParticleModule3 = GUI.BeginScrollView(viewRect, scrollStageParticleModule3, rect, false, true);
                    SetParticleAreaModule(baseRow, ref data.inheritVelocity);
                    SetParticleAreaModule(baseRow + 3, ref data.velocityOverLifetime);
                    SetParticleAreaModule(baseRow + 8, ref data.limitVelocityOverLifetime);
                    SetParticleAreaModule(baseRow + 14, ref data.forceOverLifetime);
                    SetParticleAreaModule(baseRow + 19, ref data.externalForces);
                    SetParticleAreaModule(baseRow + 22, ref data.sizeOverLifetime);
                    SetParticleAreaModule(baseRow + 27, ref data.sizeBySpeed);
                    SetParticleAreaModule(baseRow + 33, ref data.rotationOverLifetime);
                    SetParticleAreaModule(baseRow + 38, ref data.rotationBySpeed);
                    GUI.EndScrollView();
                    break;
                case (int)ParticleModuleType.ModGroup4:
                    SetParticleAreaModule(baseRow, ref data.collision);
                    SetParticleAreaModule(baseRow + 6, ref data.noise);
                    SetParticleAreaModule(baseRow + 12, ref data.render);
                    //SetParticleAreaModule(baseRow + 11, ref data.textureSheetAnimation);
                    break;
                case (int)ParticleModuleType.Position:
                    rect.height *= 18;
                    scrollStageParticleModule5 = GUI.BeginScrollView(viewRect, scrollStageParticleModule5, rect, false, true);
                    SetParticleAreaPosition(baseRow, ref data);
                    GUI.EndScrollView();
                    break;
            }
            particleMgr.ParticleData[index] = data;
        }

        private void SetParticleAreaModule(int baseRow, ref ParticleMain data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            GUI.Label(rect, "◆メイン", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "動作時間", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 5f, ref data.duration);
            rect.x += rect.width;
            GUI.Label(rect, "最大数", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 1000, ref data.maxParticles);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            data.isLoop = GUI.Toggle(rect, data.isLoop, "ループON", guiStyle.gsToggle);

            SetParticleAreaMinMax(baseRow + 3, "放出遅延", 0f, ref data.startDelay);
            SetParticleAreaMinMax(baseRow + 4, "放出寿命", 1f, ref data.startLifetime);
            SetParticleAreaMinMax(baseRow + 5, "初期速度", 0.1f, ref data.startSpeed);
            SetParticleAreaMinMax(baseRow + 6, "初期サイズ", 0.1f, ref data.startSize);
            SetParticleAreaMinMax(baseRow + 7, "初期角度", 0f, ref data.startRotation);
            SetParticleAreaMinMax(baseRow + 8, "重力値", 0f, ref data.gravityModifier);
        }

        private void SetParticleAreaModule(int baseRow, ref ParticleEmission data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            data.enabled = GUI.Toggle(rect, data.enabled, "◆発生方法有効", guiStyle.gsToggle);

            SetParticleAreaMinMax(baseRow + 1, "時間発生数", 100, ref data.rateOverTime);
            SetParticleAreaMinMax(baseRow + 2, "距離発生数", 0f, ref data.rateOverDistance);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 3;
            GUI.Label(rect, "バースト", guiStyle.gsLabel);
            rect.x += rect.width;
            GUI.Label(rect, "タイム", guiStyle.gsLabel);
            rect.x += rect.width;
            GUI.Label(rect, "最小数", guiStyle.gsLabel);
            rect.x += rect.width;
            GUI.Label(rect, "最大数", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 4;
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.burst.z);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.burst.x);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.burst.y);
        }

        private void SetParticleAreaModule(int baseRow, ref ParticleShape data)
        {
            var label = Enum.GetNames(typeof(ParticleSystemShapeType)).ToList();
            var inedx = (int)data.shapeType;
            var mode = Enum.GetNames(typeof(ParticleSystemShapeMultiModeValue));

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            data.enabled = GUI.Toggle(rect, data.enabled, "◆形状有効", guiStyle.gsToggle);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "放出形状", guiStyle.gsLabel);
            guiMgr.SetIndexChangedButton(ref rect, label.Count(), ref inedx);
            guiMgr.SetIndexChangedLabel(rect, label[inedx]);
            data.shapeType = (ParticleSystemShapeType)inedx;

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            GUI.Label(rect, "円錐角度", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.angle);
            rect.x += rect.width;
            GUI.Label(rect, "球状方向量", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.sphericalDirectionAmount);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 3;
            GUI.Label(rect, "ランダム方向量", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.randomDirectionAmount);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 4;
            GUI.Label(rect, "箱サイズ(x,y,z)", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.boxSize.x);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.boxSize.y);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.boxSize.z);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 5;
            GUI.Label(rect, "半径設定", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 6;
            for (int i = 0; i < mode.Count(); i++)
            {
                if (GUI.Toggle(rect, i == (int)data.radiusMode, mode[i], guiStyle.gsToggle))
                {
                    data.radiusMode = (ParticleSystemShapeMultiModeValue)i;
                }
                rect.x += rect.width;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 7;
            GUI.Label(rect, "型半径", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.radius);
            rect.x += rect.width;
            GUI.Label(rect, "放出点間隔", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.radiusSpread);

            SetParticleAreaMinMax(baseRow + 8, "放出速度", 0f, ref data.radiusSpeed);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 9;
            GUI.Label(rect, "円弧設定", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 10;
            for (int i = 0; i < mode.Count(); i++)
            {
                if (GUI.Toggle(rect, i == (int)data.arcMode, mode[i], guiStyle.gsToggle))
                {
                    data.arcMode = (ParticleSystemShapeMultiModeValue)i;
                }
                rect.x += rect.width;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 11;
            GUI.Label(rect, "角度", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.arc);
            rect.x += rect.width;
            GUI.Label(rect, "放出点間隔", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.arcSpread);

            SetParticleAreaMinMax(baseRow + 12, "放出速度", 0f, ref data.arcSpeed);
        }

        private void SetParticleAreaModule(int baseRow, ref ParticleColorOverLifetime data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            data.enabled = GUI.Toggle(rect, data.enabled, "◆寿命色変化有効", guiStyle.gsToggle);

            var gradientIndex = particleMgr.LifeGradientIndex;
            var alphaIndex = particleMgr.LifeAlphaIndex;
            SetParticleAreaModuleColor(baseRow, ref gradientIndex, ref alphaIndex, ref data.mode, ref data.isRandom, ref data.gradientColor, ref data.gradientAlpha);
            particleMgr.LifeGradientIndex = gradientIndex;
            particleMgr.LifeAlphaIndex = alphaIndex;
        }

        private void SetParticleAreaModule(int baseRow, ref ParticleColorBySpeed data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            data.enabled = GUI.Toggle(rect, data.enabled, "◆速度色変化有効", guiStyle.gsToggle);

            var gradientIndex = particleMgr.SpeedGradientIndex;
            var alphaIndex = particleMgr.SpeedAlphaIndex;
            SetParticleAreaModuleColor(baseRow, ref gradientIndex, ref alphaIndex, ref data.mode, ref data.isRandom, ref data.gradientColor, ref data.gradientAlpha);
            particleMgr.SpeedGradientIndex = gradientIndex;
            particleMgr.SpeedAlphaIndex = alphaIndex;

            SetParticleAreaMinMax(baseRow + 11, "速度範囲", 0f, ref data.range);
        }

        private void SetParticleAreaModuleColor(int baseRow,
                                                ref int gradientIndex, ref int alphaIndex, ref ParticleSystemGradientMode mode, ref bool isRandom,
                                                ref Dictionary<ParticleSystemGradientMode, GradientColorKey[]> gradientColor,
                                                ref Dictionary<ParticleSystemGradientMode, GradientAlphaKey[]> gradientAlpha)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "モード", guiStyle.gsLabel);
            var isMatching = false;
            foreach (var pair in MyConst.PARTICLE_GRADIENT_TYPE)
            {
                rect.x += rect.width;
                var isSelected = GUI.Toggle(rect, pair.Key == mode, pair.Value, guiStyle.gsToggle);
                if (isSelected)
                {
                    mode = pair.Key;
                    isMatching = true;
                }
            }
            if (!isMatching)
            {
                mode = ParticleSystemGradientMode.Gradient;
            }
            rect.x += rect.width;
            isRandom = GUI.Toggle(rect, isRandom, "ランダム", guiStyle.gsToggle);

            var gc = gradientColor[mode];
            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            GUI.Label(rect, "グラデーション", guiStyle.gsLabel);
            guiMgr.SetIndexChangedButton(ref rect, gc.Count(), ref gradientIndex);
            guiMgr.SetIndexChangedLabel(rect, "設定" + gradientIndex);

            Color32 color = gc[gradientIndex].color;
            guiMgr.SetColorSlider(baseRow + 3, ref color, false);
            gc[gradientIndex].color = color;

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 6;
            GUI.Label(rect, "タイム(0<->1)", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref gc[gradientIndex].time);
            gradientColor[mode] = gc;

            var ac = gradientAlpha[mode];
            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 8;
            GUI.Label(rect, "透明度変化", guiStyle.gsLabel);
            guiMgr.SetIndexChangedButton(ref rect, ac.Count(), ref alphaIndex);
            guiMgr.SetIndexChangedLabel(rect, "設定" + alphaIndex);
            color = new Color(0f, 0f, 0f, ac[alphaIndex].alpha);
            guiMgr.SetAlphaSlider(baseRow + 9, ref color);
            ac[alphaIndex].alpha = ((Color)color).a;

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 10;
            GUI.Label(rect, "タイム(0<->1)", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref ac[alphaIndex].time);
            gradientAlpha[mode] = ac;
        }

        private void SetParticleAreaModule(int baseRow, ref ParticleInheritVelocity data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            data.enabled = GUI.Toggle(rect, data.enabled, "◆速度反映有効", guiStyle.gsToggle);

            SetParticleAreaMinMax(baseRow + 1, "速度割合", 0f, ref data.curve);
        }

        private void SetParticleAreaModule(int baseRow, ref ParticleVelocityOverLifetime data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            data.enabled = GUI.Toggle(rect, data.enabled, "◆寿命速度変化有効", guiStyle.gsToggle);

            SetParticleAreaMinMaxXYZ(baseRow + 1, "加速範囲", 0f, ref data.speed);
        }

        private void SetParticleAreaModule(int baseRow, ref ParticleLimitVelocityOverLifetime data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            data.enabled = GUI.Toggle(rect, data.enabled, "◆寿命速度制限有効", guiStyle.gsToggle);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "減速値", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.dampen);

            SetParticleAreaMinMaxXYZ(baseRow + 2, "制限速度", 0f, ref data.limit);
        }

        private void SetParticleAreaModule(int baseRow, ref ParticleForceOverLifetime data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            data.enabled = GUI.Toggle(rect, data.enabled, "◆引力有効", guiStyle.gsToggle);
            rect.width /= 2;
            rect.x += rect.width * 3;
            data.randomized = GUI.Toggle(rect, data.randomized, "ランダム", guiStyle.gsToggle);

            SetParticleAreaMinMaxXYZ(baseRow + 1, "引力範囲", 0f, ref data.force);
        }

        private void SetParticleAreaModule(int baseRow, ref ParticleExternalForces data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            data.enabled = GUI.Toggle(rect, data.enabled, "◆外力有効", guiStyle.gsToggle);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "外力乗数", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.multiplier);
        }

        private void SetParticleAreaModule(int baseRow, ref ParticleSizeOverLifetime data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            data.enabled = GUI.Toggle(rect, data.enabled, "◆寿命サイズ変化有効", guiStyle.gsToggle);

            SetParticleAreaMinMaxXYZ(baseRow + 1, "サイズ変化", 0f, ref data.size);
        }

        private void SetParticleAreaModule(int baseRow, ref ParticleSizeBySpeed data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            data.enabled = GUI.Toggle(rect, data.enabled, "◆速度サイズ変化有効", guiStyle.gsToggle);

            SetParticleAreaMinMaxXYZ(baseRow + 1, "サイズ変化", 0f, ref data.size);
            SetParticleAreaMinMax(baseRow + 4, "速度範囲", 0f, ref data.range);
        }

        private void SetParticleAreaModule(int baseRow, ref ParticleRotationOverLifetime data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            data.enabled = GUI.Toggle(rect, data.enabled, "◆寿命回転変化有効", guiStyle.gsToggle);

            SetParticleAreaMinMaxXYZ(baseRow + 1, "回転変化", 0f, ref data.rotation);
        }

        private void SetParticleAreaModule(int baseRow, ref ParticleRotationBySpeed data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            data.enabled = GUI.Toggle(rect, data.enabled, "◆速度回転変化有効", guiStyle.gsToggle);

            SetParticleAreaMinMaxXYZ(baseRow + 1, "回転変化", 0f, ref data.rotation);
            SetParticleAreaMinMax(baseRow + 4, "速度範囲", 0f, ref data.range);
        }

        private void SetParticleAreaModule(int baseRow, ref ParticleCollision data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            data.enabled = GUI.Toggle(rect, data.enabled, "◆衝突有効", guiStyle.gsToggle);

            SetParticleAreaMinMax(baseRow + 1, "減速範囲", 0f, ref data.dampen);
            SetParticleAreaMinMax(baseRow + 2, "反発力範囲", 0f, ref data.bounce);
            SetParticleAreaMinMax(baseRow + 3, "減少寿命範囲", 0f, ref data.lifetimeLoss);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 4;
            GUI.Label(rect, "消滅速度", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.minKillSpeed);
        }

        private void SetParticleAreaModule(int baseRow, ref ParticleNoise data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            data.enabled = GUI.Toggle(rect, data.enabled, "◆ノイズ有効", guiStyle.gsToggle);

            SetParticleAreaMinMaxXYZ(baseRow + 1, "効果強弱範囲", 0f, ref data.strength);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 4;
            GUI.Label(rect, "変化度合", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.frequency);
            rect.x += rect.width;
            data.damping = GUI.Toggle(rect, data.damping, "挙動拡大", guiStyle.gsToggle);
        }

        private void SetParticleAreaModule(int baseRow, ref ParticleRender data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            data.enabled = GUI.Toggle(rect, data.enabled, "◆レンダー有効", guiStyle.gsToggle);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "モード", guiStyle.gsLabel);
            var mode = Enum.GetNames(typeof(ParticleSystemRenderMode));
            var index = (int)data.mode;
            guiMgr.SetIndexChangedButton(ref rect, mode.Count(), ref index);
            guiMgr.SetIndexChangedLabel(rect, mode[index]);
            data.mode = (ParticleSystemRenderMode)index;
        }

        private void SetParticleAreaPosition(int baseRow, ref DanceParticle data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "座標", guiStyle.gsLabel);
            guiMgr.SetPositionSlider(baseRow + 1, ref data.position, Vector3.zero);
            guiMgr.SetRotationSlider(baseRow + 4, ref data.rotation, Vector3.zero);
            guiMgr.SetScaleSlider(baseRow + 7, ref data.scale);

            var min = guiMgr.TransformSlider.scaleMin.z;
            var max = guiMgr.TransformSlider.scaleMax.z;
            var label = "サイズ一括";
            var value = data.allScale;
            value = guiMgr.SetOneLineSlider(label, baseRow + 10, value, min, max, MyConst.SCALE_DEFAULT, MyConst.GUI_ONE_SLIDER_NORMAL);
            if (value != data.allScale)
            {
                data.allScale = value;
                data.scale = new Vector3(value, value, value);
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 11;
            rect.width *= 2;
            data.isColor = GUI.Toggle(rect, data.isColor, "カラー設定有効", guiStyle.gsToggle);
            if (data.isColor)
            {
                guiMgr.SetColorSlider(baseRow + 12, ref data.color, true);
            }
            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 16;
            GUI.Label(rect, "テクスチャー", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 3;
            data.textureName = guiMgr.SetTextField(rect, data.textureName);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 17;
            GUI.Label(rect, "シェーダー", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 3;
            data.shaderName = guiMgr.SetTextField(rect, data.shaderName);
        }

        private void SetParticleAreaMinMaxXYZ(int baseRow, string label, float defaultVal, ref ParticleMinMaxXYZ data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 3;
            GUI.Label(rect, label, guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width /= 3;
            if (GUI.Button(rect, "x->y,z Copy", guiStyle.gsButton))
            {
                data.y = data.x;
                data.z = data.x;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "　最小値(x,y,z)", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, defaultVal, ref data.x.x);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, defaultVal, ref data.y.x);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, defaultVal, ref data.z.x);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            GUI.Label(rect, "　最大値(x,y,z)", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, defaultVal, ref data.x.y);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, defaultVal, ref data.y.y);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, defaultVal, ref data.z.y);
        }

        private void SetParticleAreaMinMax(int baseRow, string label, float defaultVal, ref Vector2 data)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            GUI.Label(rect, label + " (最小値,最大値)", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width /= 2;
            guiMgr.SetNumberField(rect, defaultVal, ref data.x);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, defaultVal, ref data.y);
        }

        #endregion

        #region GuiStageEach

        private void SetStageObjectEachAreaTop()
        {
            int baseRow = 2;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            for (int i = 0; i < MyConst.STAGE_OBJECT_LABEL.Count(); i++)
            {
                var isSelected = GUI.Toggle(rect, i == stageMgr.EachIndex, MyConst.STAGE_OBJECT_LABEL[i], guiStyle.gsToggle);
                if (isSelected)
                {
                    stageMgr.EachIndex = i;
                }
                rect.x += rect.width;
            }
        }

        private void WindowFunctionCrowd()
        {
            int baseRow = 3;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.x += rect.width * 2;
            if (GUI.Button(rect, "作成", guiStyle.gsButton))
            {
                stageMgr.CreateCrowdData();
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "削除", guiStyle.gsButton))
            {
                stageMgr.DeleteCrowdData();
            }

            var data = stageMgr.CrowdSet;
            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "円の数", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0, ref data.layer);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            GUI.Label(rect, "一周の人数", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0, ref data.mobNumber);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 3;
            GUI.Label(rect, "中心距離", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.centerDistance);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 4;
            GUI.Label(rect, "モブ横間隔", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.mobDistanceX);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 5;
            GUI.Label(rect, "モブ縦間隔", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.mobDistanceZ);

            stageMgr.CrowdSet = data;
        }

        private void SetStageObjectEachAreaCyalumeTop()
        {
            int baseRow = 3;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width /= 2;
            for (int i = 0; i < MyConst.STAGE_OBJECT_CYALUME_MAX; i++)
            {
                var isSelected = GUI.Toggle(rect, i == stageMgr.CyalumeIndex, (i + 1).ToString(), guiStyle.gsToggle);
                if (isSelected)
                {
                    stageMgr.CyalumeIndex = i;
                }
                rect.x += rect.width;
            }
            rect.width *= 2;
            if (GUI.Button(rect, "読込", guiStyle.gsButton))
            {
                stageMgr.ReadCyalumeData();
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "作成", guiStyle.gsButton))
            {
                stageMgr.CreateCyalumeData();
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "削除", guiStyle.gsButton))
            {
                stageMgr.DeleteCyalumeData();
            }
        }

        private void SetStageObjectEachAreaCyalumeMain()
        {
            var data = stageMgr.CyalumeSet[stageMgr.CyalumeIndex];

            int baseRow = 4;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "1階個数(横,縦)", guiStyle.gsLabel);
            rect.x += rect.width;
            var width = (int)data.floor1st.x;
            var height = (int)data.floor1st.y;
            guiMgr.SetNumberField(rect, 0, ref width);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0, ref height);
            data.floor1st = new Vector2(width, height);
            rect.x += rect.width;
            data.isPair1st = GUI.Toggle(rect, data.isPair1st, "ペア表示", guiStyle.gsToggle);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "2階個数(横,縦)", guiStyle.gsLabel);
            rect.x += rect.width;
            width = (int)data.floor2nd.x;
            height = (int)data.floor2nd.y;
            guiMgr.SetNumberField(rect, 0, ref width);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0, ref height);
            data.floor2nd = new Vector2(width, height);
            rect.x += rect.width;
            data.isPair2nd = GUI.Toggle(rect, data.isPair2nd, "ペア表示", guiStyle.gsToggle);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            GUI.Label(rect, "ペア間隔", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.pairSpace);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 3;
            rect.x += rect.width;
            GUI.Label(rect, "　x", guiStyle.gsLabel);
            rect.x += rect.width;
            GUI.Label(rect, "　y", guiStyle.gsLabel);
            rect.x += rect.width;
            GUI.Label(rect, "　z", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 4;
            GUI.Label(rect, "1階端位置", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.position1st.x);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.position1st.y);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.position1st.z);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 5;
            GUI.Label(rect, "2階端位置", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.position2nd.x);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.position2nd.y);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.position2nd.z);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 6;
            GUI.Label(rect, "位置調整", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.positionAdjustment.x);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.positionAdjustment.y);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.positionAdjustment.z);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 7;
            GUI.Label(rect, "回転", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.rotation.x);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.rotation.y);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.rotation.z);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 8;
            GUI.Label(rect, "サイズ", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.scale.x);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.scale.y);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.scale.z);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 9;
            GUI.Label(rect, "移動距離", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.moveDistance.x);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.moveDistance.y);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.moveDistance.z);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 10;
            GUI.Label(rect, "移動時間", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.moveTime);
            rect.x += rect.width;
            GUI.Label(rect, "Y軸回転量", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.rotationAddY);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 11;
            stageMgr.IsCyalumeSelectedLeft = GUI.Toggle(rect, stageMgr.IsCyalumeSelectedLeft, "左色", guiStyle.gsToggle);
            rect.x += rect.width;
            stageMgr.IsCyalumeSelectedLeft = !GUI.Toggle(rect, !stageMgr.IsCyalumeSelectedLeft, "右色", guiStyle.gsToggle);
            
            if (!data.isRandomChanged)
            {
                rect.x += rect.width;
                GUI.Label(rect, "フェード時間", guiStyle.gsLabel);
                rect.x += rect.width;
                guiMgr.SetNumberField(rect, 0f, ref data.fadeTime);
            }
            else
            {
                data.fadeTime = 0f;
            }

            var index = stageMgr.IsCyalumeSelectedLeft ? 0 : 1;
            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 12;
            GUI.Label(rect, "　RGB", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0, ref data.color[index].r);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0, ref data.color[index].g);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0, ref data.color[index].b);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 13;
            GUI.Label(rect, "　透明度", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0, ref data.color[index].a);
            rect.x += rect.width;
            data.isRandomColor = GUI.Toggle(rect, data.isRandomColor, "単色ランダム", guiStyle.gsToggle);
            if (data.isRandomColor)
            {
                data.isRandomColors = false;
            }
            rect.x += rect.width;
            data.isRandomColors = GUI.Toggle(rect, data.isRandomColors, "多色ランダム", guiStyle.gsToggle);
            if (data.isRandomColors)
            {
                data.isRandomColor = false;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 14;
            rect.x += rect.width;
            data.isRandomChanged = GUI.Toggle(rect, data.isRandomChanged, "色変更ON", guiStyle.gsToggle);
            rect.x += rect.width;
            GUI.Label(rect, "変更タイム間隔", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.changeTime);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 15;
            GUI.Label(rect, "テクスチャー", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 3;
            data.textureName = guiMgr.SetTextField(rect, data.textureName);

            stageMgr.CyalumeSet[stageMgr.CyalumeIndex] = data;
        }

        #endregion

        #region GuiStageLight

        private void SetLightAreaTop()
        {
            int baseRow = 2;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            var parts = MyConst.STAGE_LIGHT_LABEL;
            for (int i = 0; i < parts.Count(); i++)
            {
                var isSelected = GUI.Toggle(rect, i == lightMgr.LightTypeIndex, parts[i], guiStyle.gsToggle);
                if (isSelected && i != lightMgr.LightTypeIndex)
                {
                    lightMgr.LightTypeIndex = i;
                }
                rect.x += rect.width;
            }
        }

        private void SetLightAreaMain()
        {
            int baseRow = 4;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            var isMainLightOff = this.isMainLightOff;
            this.isMainLightOff = GUI.Toggle(rect, isMainLightOff, "メインライトOFF", guiStyle.gsToggle);
            if (isMainLightOff != this.isMainLightOff)
            {
                lightMgr.SetMainLight(!this.isMainLightOff);
                if (this.isMainLightOff)
                {
                    mainLightColor = MyHelper.SetColorWhite();
                }
                else
                {
                    mainLightColor = MyHelper.SetColorWhite();
                }
            }

            var color = mainLightColor;
            guiMgr.SetColorSlider(baseRow + 1, ref mainLightColor, false);
            if (!Equals(color, mainLightColor))
            {
                lightMgr.GetMainLight().color = mainLightColor;
            }
        }

        private void SetLightAreaSub()
        {
            int baseRow = 9;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            var isSubLightOn = this.isSubLightOn;
            this.isSubLightOn = GUI.Toggle(rect, isSubLightOn, "サブライトON", guiStyle.gsToggle);
            if (isSubLightOn != this.isSubLightOn)
            {
                if (this.isSubLightOn)
                {
                    lightMgr.CreateSubLight();
                }
                else
                {
                    lightMgr.DestroyLight(lightMgr.SubLight.light);
                }
            }

            if (this.isSubLightOn)
            {
                var isUpdate = false;
                rect.width /= 2;
                rect.x += rect.width * 3;
                if (GUI.Button(rect, "リスト取得", guiStyle.gsButton))
                {
                    ReadLightData(LightType.Directional, 0);
                    isUpdate = true;
                }

                var subLight = lightMgr.SubLight;

                var color = subLight.color;
                guiMgr.SetColorSlider(baseRow + 1, ref subLight.color, false);
                if (!Equals(color, subLight.color) || isUpdate)
                {
                    subLight.light.color = subLight.color;
                }
                var rotation = subLight.rotation;
                guiMgr.SetRotationSlider(baseRow + 4, ref subLight.rotation, Vector3.zero);
                if (rotation != subLight.rotation || isUpdate)
                {
                    subLight.light.transform.rotation = Quaternion.Euler(subLight.rotation);
                }

                var value = subLight.shadowStrength;
                value = guiMgr.SetOneLineSlider("影濃度", baseRow + 7, value, 0f, 1f, MyConst.LIGHT_SHADOW_STRENGTH, MyConst.GUI_ONE_SLIDER_SMALL);
                if (value != subLight.shadowStrength)
                {
                    subLight.light.shadowStrength = value;
                    subLight.shadowStrength = value;
                }

                value = subLight.intensity;
                value = guiMgr.SetOneLineSlider("輝度", baseRow + 8, value, 0f, 10f, MyConst.LIGHT_INTENSITY, MyConst.GUI_ONE_SLIDER_SMALL);
                if (value != subLight.intensity)
                {
                    subLight.light.intensity = value;
                    subLight.intensity = value;
                }

                lightMgr.SubLight = subLight;
            }
        }

        private void SetLightAreaSpot(List<Maid> maids)
        {
            SetLightAreaExtra(maids, LightType.Spot, ref spotLightIndex, ref spotLightGroupIndex);
        }

        private void SetLightAreaPoint(List<Maid> maids)
        {
            SetLightAreaExtra(maids, LightType.Point, ref pointLightIndex, ref pointLightGroupIndex);
        }

        private void SetLightAreaExtra(List<Maid> maids, LightType type, ref int lightIndex, ref int lightGroupIndex)
        {
            int baseRow = 3;
            if (!lightMgr.LightData.ContainsKey(type))
            {
                lightMgr.LightData[type] = new List<FreeLightSet>();
            }
            var lightData = lightMgr.LightData[type];

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            if (MyHelper.CheckNull(lightData))
            {
                rect.width *= 3;
                GUI.Label(rect, "ライトを追加してください", guiStyle.gsLabel);
            }
            else
            {
                var lable = Enum.GetName(typeof(LightType), type) + lightIndex;
                GUI.Label(rect, "対象ライト", guiStyle.gsLabel);
                guiMgr.SetIndexChangedButton(ref rect, lightData.Count(), ref lightIndex);
                guiMgr.SetIndexChangedLabel(rect, lable);
            }

            if (lightGroupDic.ContainsKey(type))
            {
                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 1;
                if (MyHelper.CheckNull(lightGroupDic[type]))
                {
                    rect.width *= 3;
                    GUI.Label(rect, "グループがありません", guiStyle.gsLabel);
                }
                else
                {
                    GUI.Label(rect, "グループ", guiStyle.gsLabel);
                    guiMgr.SetIndexChangedButton(ref rect, lightGroupDic[type].Count(), ref lightGroupIndex);
                    guiMgr.SetIndexChangedLabel(rect, lightGroupDic[type][lightGroupIndex]);
                }
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            if (!MyHelper.CheckNull(lightData))
            {
                if (GUI.Button(rect, "削除", guiStyle.gsButton))
                {
                    lightMgr.DestroyLight(lightData[lightIndex].light);
                    lightData.RemoveAt(lightIndex);
                    lightIndex = 0;
                }
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "追加", guiStyle.gsButton))
            {
                lightMgr.CreateExtraLight(type, lightSetting[type]);
                lightData = lightMgr.LightData[type];
                lightIndex = lightData.Count() - 1;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "一括追加", guiStyle.gsButton))
            {
                var data = ReadLightData(type, lightGroupIndex);
                foreach (var d in data)
                {
                    lightMgr.CreateExtraLight(type, d);
                }
                lightData = lightMgr.LightData[type];
                lightIndex = lightData.Count() - 1;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton) || !lightGroupDic.ContainsKey(type))
            {
                GetLightGroup(type);
                lightGroupIndex = 0;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 3;
            if (!MyHelper.CheckNull(lightData))
            {
                var data = lightData[lightIndex];
                var compare = data.position;
                guiMgr.SetPositionSlider(baseRow + 3, ref data.position, Vector3.zero);
                if (compare != data.position)
                {
                    data.light.transform.position = data.position;
                }

                if (type == LightType.Spot)
                {
                    compare = data.rotation;
                    guiMgr.SetRotationSlider(baseRow + 6, ref data.rotation, Vector3.zero);
                    if (compare != data.rotation)
                    {
                        data.light.transform.rotation = Quaternion.Euler(data.rotation);
                    }
                }

                var colorCompare = data.color;
                guiMgr.SetColorSlider(baseRow + 9, ref data.color, false);
                if (!Equals(colorCompare, data.color))
                {
                    data.light.color = data.color;
                }

                var value = data.intensity;
                value = guiMgr.SetOneLineSlider("輝度", baseRow + 12, value, 0f, 10f, MyConst.LIGHT_INTENSITY, MyConst.GUI_ONE_SLIDER_SMALL);
                if (value != data.intensity)
                {
                    data.light.intensity = value;
                    data.intensity = value;
                }

                value = data.range;
                value = guiMgr.SetOneLineSlider("範囲", baseRow + 13, value, 0f, 100f, MyConst.LIGHT_RANGE, MyConst.GUI_ONE_SLIDER_NORMAL);
                {
                    data.light.range = value;
                    data.range = value;
                }

                if (type == LightType.Spot)
                {
                    value = data.spotAngle;
                    value = guiMgr.SetOneLineSlider("角度", baseRow + 14, value, 0f, 100f, MyConst.LIGHT_SPOTANGLE, MyConst.GUI_ONE_SLIDER_NORMAL);
                    {
                        data.light.spotAngle = value;
                        data.spotAngle = value;
                    }
                }

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 15;
                rect.width *= 2;
                data.isFollowing = GUI.Toggle(rect, data.isFollowing, "メイド追従ON", guiStyle.gsToggle);

                if (MyHelper.CheckNull(maids))
                {
                    SetMenuAreaNoMaid(baseRow + 16);
                }
                else
                {
                    data.maidIndex =
                        guiMgr.SetSelectedMaidButton(baseRow + 16, maids, data.maidIndex, maidMgr);
                }
                lightData[lightIndex] = data;
            }
            lightMgr.LightData[type] = lightData;
        }

        #endregion

        #region GuiAutoCamera
        private void SetAutoCameraArea(List<Maid> maids)
        {
            var data = cameraMgr.AutoCamera;
            int baseRow = 2;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            data.maidIndex = guiMgr.SetSelectedMaidButton(baseRow, maids, data.maidIndex, maidMgr);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            rect.width *= 2;
            data.isRandomMaid = GUI.Toggle(rect, data.isRandomMaid, "ランダムメイド", guiStyle.gsToggle);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            GUI.Label(rect, "有効アングル", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 3;
            var count = MyConst.LOOK_AT_AUTO_LABEL.Count();
            rect.width = rect.width * 4 / count;
            for (int i = 0; i < count; i++)
            {
                data.each[i].isAngleEnabled = GUI.Toggle(rect, data.each[i].isAngleEnabled, MyConst.LOOK_AT_AUTO_LABEL[i], guiStyle.gsToggle);
                rect.x += rect.width;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 4;
            GUI.Label(rect, "対象アングル", guiStyle.gsLabel);
            guiMgr.SetIndexChangedButton(ref rect, count, ref data.guiAngleIndex);
            guiMgr.SetIndexChangedLabel(rect, MyConst.LOOK_AT_AUTO_LABEL[data.guiAngleIndex]);
            var index = data.guiAngleIndex;

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 5;
            GUI.Label(rect, "移動量", guiStyle.gsLabel);
            rect.x += rect.width;
            GUI.Label(rect, "　x", guiStyle.gsLabel);
            rect.x += rect.width;
            GUI.Label(rect, "　y", guiStyle.gsLabel);
            rect.x += rect.width;
            GUI.Label(rect, "　z", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 6;
            GUI.Label(rect, "　最小値", guiStyle.gsLabel);
            rect.x += rect.width;
            var pos = data.each[index].positionMin;
            guiMgr.SetNumberField(rect, 0f, ref pos.x);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref pos.y);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref pos.z);
            pos.x = Mathf.Max(pos.x, 0f);
            pos.y = Mathf.Max(pos.y, 0f);
            pos.z = Mathf.Max(pos.z, MyConst.LOOK_AT_AUTO_MIN_Z);
            data.each[index].positionMin = pos;

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 7;
            GUI.Label(rect, "　最小大", guiStyle.gsLabel);
            rect.x += rect.width;
            pos = data.each[index].positionMax;
            guiMgr.SetNumberField(rect, 0f, ref pos.x);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref pos.y);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref pos.z);
            pos.x = Mathf.Max(pos.x, 0f);
            pos.y = Mathf.Max(pos.y, 0f);
            pos.z = Mathf.Max(pos.z, MyConst.LOOK_AT_AUTO_MIN_Z);
            data.each[index].positionMax = pos;

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 8;
            GUI.Label(rect, "切替タイム範囲", guiStyle.gsLabel);
            rect.x += rect.width;
            var time = data.each[index].autoTime;
            guiMgr.SetNumberField(rect, 0f, ref time.x);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref time.y);
            rect.x += rect.width;
            if (time.y < time.x)
            {
                time.y = time.x;
            }
            data.each[index].autoTime = time;

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 9;
            rect.width *= 2;
            data.each[index].isBackEnabled = GUI.Toggle(rect, data.each[index].isBackEnabled, "背面位置有効", guiStyle.gsToggle);
            rect.x += rect.width;
            data.each[index].isInfrequent = GUI.Toggle(rect, data.each[index].isInfrequent, "ランダム頻度低", guiStyle.gsToggle);

            cameraMgr.AutoCamera = data;
        }

        private void SetAutoCameraAreaList()
        {
            int baseRow = 15;
            var text = guiMgr.AutoCameraLabel;
            var isClick = guiMgr.SetSaveField(baseRow - 2, ref text);
            guiMgr.AutoCameraLabel = text;
            if (isClick && !string.IsNullOrEmpty(text))
            {
                new FileWriter().WriteAutoCameraList(text, cameraMgr.AutoCamera);
                cameraMgr.ReadAutoCameraLabel();
            }
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            GUI.Label(rect, "オートリスト", guiStyle.gsLabel);
            rect.x += rect.width * 3;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton) || MyHelper.CheckNull(cameraMgr.AutoCameraList))
            {
                cameraMgr.ReadAutoCameraLabel();
            }

            var index = guiMgr.SetSelectionGrid(baseRow, cameraMgr.AutoCameraList,
                                         MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow),
                                         ref scrollAutoCamera);
            if (index != cameraMgr.AutoCameraList.Count() - 1)
            {
                cameraMgr.ReadAutoCameraData(cameraMgr.AutoCameraList[index], false);
            }
        }

        #endregion

        #region GuiCamera
        private void SetCameraAreaComboList()
        {
            int baseRow = 2;
            if (MyHelper.CheckNull(cameraList))
            {
                GetCameraLists();
            }
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "モーション", guiStyle.gsLabel);
            if (!MyHelper.CheckNull(cameraList))
            {
                rect.x += rect.width;
                rect.width *= 3;
                if (GUI.Button(rect, Path.GetFileName(cameraList[this.cameraListIndex]), guiStyle.gsCombo) && cameraList.Count() > 1)
                {
                    isCameraComboOn = !isCameraComboOn;
                }

                if (isCameraComboOn && !isCamera && cameraList.Count() > 1)
                {
                    var index = guiMgr.SetCommboList(baseRow, new List<string>(cameraList.Select(d => Path.GetFileName(d))),
                                                         ref scrollCameraList, ref isCameraComboOn);
                    if (!isCameraComboOn)
                    {
                        cameraListIndex = index;
                    }
                }
            }
        }

        private void SetCameraAreaPlay()
        {
            int baseRow = 3;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.x += rect.width;
            if (GUI.Button(rect, (isCamera) ? "停止" : "再生", guiStyle.gsButton))
            {
                if (!isCamera)
                {
                    freeMotion = new DanceCameraMotionSet();
                    freeMotion.motionName = cameraList[cameraListIndex];
                    freeMotion.subFolder = MyConst.FOLDER_CAMERA;
                    freeMotion.isCustomMotion = isDanceCameraCustom;
                    freeMotion = ReadMotionData(freeMotion);
                    if (!MyHelper.CheckNull(freeMotion.motionData))
                    {
                        freeMotion.camera = MyHelper.GetCameraMain();
                        freeMotion.isMotionOn = true;
                        freeMotion.cameraMgr = new CameraManager();
                        freeMotion.cameraMgr.IncrementIndex(freeMotion.motionData, cameraTest.stTime);
                        cameraTest.deltaTime = cameraTest.stTime;
                        isCamera = true;
                    }
                }
                else
                {
                    freeMotion.camera = null;
                    freeMotion = new DanceCameraMotionSet();
                    isCamera = false;
                    isCameraStoped = false;
                }
            }
            rect.x += rect.width;
            if (isCamera)
            {
                if (GUI.Button(rect, (isCameraStoped) ? "再開" : "一時停止", guiStyle.gsButton))
                {
                    isCameraStoped = !isCameraStoped;
                }
            }
            else
            {
                if (GUI.Button(rect, "リセット", guiStyle.gsButton))
                {
                    cameraMgr.ResetMainCamera();
                }
            }

            rect.x += rect.width;
            if (GUI.Button(rect, (isDance || isCamera) ? "データ読込" : "リスト取得", guiStyle.gsButton))
            {
                if (isDance || isCamera)
                {
                    freeMotion.subFolder = MyConst.FOLDER_CAMERA;
                    freeMotion = ReadMotionData(freeMotion);
                }
                else
                {
                    GetCameraLists();
                }
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            rect.x += rect.width;
            rect.width *= 2;
            isDanceCameraOn = GUI.Toggle(rect, isDanceCameraOn, "公式ダンス再生ON", guiStyle.gsToggle);
            rect.x += rect.width;
            rect.width /= 2;
            isDanceCameraCustom = GUI.Toggle(rect, isDanceCameraCustom, "カスタム", guiStyle.gsToggle);
        }

        private void SetCameraAreaTime()
        {
            int baseRow = 5;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "カメラタイム", guiStyle.gsLabel);
            rect.x += rect.width;
            GUI.Label(rect, "　開始", guiStyle.gsLabel);
            rect.x += rect.width;
            GUI.Label(rect, "　終了", guiStyle.gsLabel);
            rect.x += rect.width;
            GUI.Label(rect, "　現在", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "(リピート)", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref cameraTest.stTime);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref cameraTest.edTime);
            if (isCamera)
            {
                rect.x += rect.width;
                GUI.Label(rect, cameraTest.deltaTime.ToString("F2"), guiStyle.gsLabel);
            }
        }

        private void SetCameraAreaFunction()
        {
            int baseRow = 16;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            myGui.isGuiAutoOff = GUI.Toggle(rect, myGui.isGuiAutoOff, "GUI自動非表示", guiStyle.gsToggle);
            rect.x += rect.width;
            isWasdOn = GUI.Toggle(rect, isWasdOn, "WASD移動＋マウス操作", guiStyle.gsToggle);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            rect.width *= 2;
            rect.x += rect.width;
            var isMute = GUI.Toggle(rect, soundMgr.IsMuteBgm(), "BGMミュート", guiStyle.gsToggle);
            if (isMute != soundMgr.IsMuteBgm())
            {
                soundMgr.MuteBgm(isMute);
            }

            guiMgr.SetZoomSlider(baseRow + 2, ref cameraMgr);
        }

        #endregion

        #region GuiSwitcher
        private void SetSwitcherAreaTransform()
        {
            int baseRow = 2;
            var pos = cameraMgr.CurrentPosition;
            var rot = cameraMgr.CurrentRotation;
            guiMgr.SetPositionSlider(baseRow, ref pos, cameraMgr.GetPositionResetValue());
            guiMgr.SetRotationSlider(baseRow + 3, ref rot, cameraMgr.GetRotationResetValue());
            cameraMgr.SetMainCameraTransform(pos, rot);
        }

        private void SetSwitcherAreaXml()
        {
            int baseRow = 8;
            var pos = cameraMgr.CurrentPosition;
            var rot = cameraMgr.CurrentRotation;

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "貼付用座標", guiStyle.gsLabel);
            rect.x += MyConst.GUI_WIDTH;
            rect.width = MyConst.GUI_WIDTH * 3;
            var labelFormat = "{0:0.00},{1:0.00},{2:0.00},{3:0.00},{4:0.00},{5:0.00}";
            var sample = string.Format(labelFormat,
                                        pos.x, pos.y, pos.z,
                                        rot.x, rot.y, rot.z);
            guiMgr.SetTextField(rect, sample);

            var text = guiMgr.SwicherLabel;
            var isClick = guiMgr.SetSaveField(baseRow + 2, ref text);
            guiMgr.SwicherLabel = text;
            if (isClick && !string.IsNullOrEmpty(text) &&
                (pos != Vector3.zero || rot != Vector3.zero))
            {
                new FileWriter().WriteSwitcherList(pos, rot, text);
                ReadSwitcherData();
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 3;
            GUI.Label(rect, "座標リスト", guiStyle.gsLabel);
            rect.x += rect.width * 3;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton) || MyHelper.CheckNull(switcherData))
            {
                ReadSwitcherData();
            }
            rect.x += rect.width;
        }

        private void SetSwitcherAreaXmlData()
        {
            int baseRow = 12;
            if (!MyHelper.CheckNull(switcherData))
            {
                var labelList = new List<string>();
                foreach (var data in switcherData)
                {
                    labelList.Add(data.label);
                }

                var index = guiMgr.SetSelectionGrid(baseRow, labelList,
                                             MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow),
                                             ref scrollSwitcherXmlData);

                if (index != labelList.Count() - 1)
                {
                    var tm = switcherData[index].transform;
                    cameraMgr.SetMainCameraTransform(tm.stPos, tm.stRot);
                }
            }
        }
        #endregion

        #region GuiExtra
        private void SetExtraAreaTop(List<Maid> maids, int maidIndex, bool isList)
        {
            int baseRow = 2;
            maidMgr.GuiMaidIndex =
                    guiMgr.SetSelectedMaidButton(baseRow, maids, maidMgr.GuiMaidIndex, maidMgr);

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            guiMgr.IsExtraAll = GUI.Toggle(rect, guiMgr.IsExtraAll, "メイド一括", guiStyle.gsToggle);
            rect.x += rect.width * 2;
            if (!isList && GUI.Button(rect, "拭く", guiStyle.gsButton))
            {
                if (guiMgr.IsExtraAll)
                {
                    foreach (var m in maids)
                    {
                        extraMgr.RemoveBukkake(m);
                    }
                }
                else
                {
                    extraMgr.RemoveBukkake(maids[maidIndex]);
                }
            }
            rect.x += rect.width;
            if (!isList && GUI.Button(rect, "ぶっかけ", guiStyle.gsButton))
            {
                extraMgr.SetBukkake(maids, maidIndex, extraMgr.BukkakeSet, guiMgr.IsExtraAll);
            }
        }

        private void SetExtraAreaBukkakeTop()
        {
            var data = extraMgr.BukkakeSet;
            var count = data.slotNo.Count();

            int baseRow = 4;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "部位選択", guiStyle.gsLabel);
            rect.x += rect.width;
            if (GUI.Button(rect, "全選択", guiStyle.gsButton))
            {
                for (int i = 0; i < count; i++)
                {
                    data.slotNo[i] = true;
                }
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "全解除", guiStyle.gsButton))
            {
                for (int i = 0; i < count; i++)
                {
                    data.slotNo[i] = false;
                }
            }
            rect.x += rect.width;
            rect.width /= 2;
            GUI.Label(rect, "　回数", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, MyConst.BUKKAKE_REPEAT_MIN, ref data.repeat);
            if(data.repeat < MyConst.BUKKAKE_REPEAT_MIN)
            {
                data.repeat = MyConst.BUKKAKE_REPEAT_MIN;
            }
            extraMgr.BukkakeSet = data;
        }

        private void SetExtraAreaBukkakeParts()
        {
            int baseRow = 5;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            var cnt = Mathf.CeilToInt(MyConst.BUKKAKE_TAG.Count() / (float)MyConst.MAX_COLUMN);
            rect.height = cnt * rect.height;
            rect.width *= 4;
            var viewRect = rect;
            viewRect.height = MyConst.GUI_HEIGHT * 6;
            scrollBukkakeParts = GUI.BeginScrollView(viewRect, scrollBukkakeParts, rect, false, true);
            var data = extraMgr.BukkakeSet;
            int index = 0;
            rect.width /= 4;
            rect.height = MyConst.DEFAULT_RECT.height;
            var slot = MyConst.BUKKAKE_TAG.Keys.ToList();
            for (int i = 0; i < data.slotNo.Count(); i++)
            {
                data.slotNo[i] = GUI.Toggle(rect, data.slotNo[i], MyConst.BUKKAKE_TAG[slot[i]], guiStyle.gsToggle);
                index++;
                if (index % MyConst.MAX_COLUMN == 0)
                {
                    rect.x = MyConst.DEFAULT_RECT.x;
                    rect.y += MyConst.GUI_HEIGHT;
                }
                else
                {
                    rect.x += rect.width;
                }
            }
            GUI.EndScrollView();
            extraMgr.BukkakeSet = data;
        }

        private void SetExtraAreaBukkake()
        {
            var data = extraMgr.BukkakeSet;
            int baseRow = 11;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            GUI.Label(rect, "座標X(min,max)", guiStyle.gsLabel);
            rect.width /= 2;
            rect.x += rect.width;
            data.isAutoFit = GUI.Toggle(rect, data.isAutoFit, "自動調整", guiStyle.gsToggle);
            if (!data.isAutoFit)
            {
                var min = (int)data.min.x;
                var max = (int)data.max.x;
                rect.x += rect.width;
                guiMgr.SetNumberField(rect, 0, ref min);
                rect.x += rect.width;
                guiMgr.SetNumberField(rect, 0, ref max);
                data.min.x = min;
                data.max.x = max;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            rect.width *= 2;
            GUI.Label(rect, "座標Y(min,max)", guiStyle.gsLabel);
            if (!data.isAutoFit)
            {
                var min = (int)data.min.y;
                var max = (int)data.max.y;
                rect.x += rect.width;
                rect.width /= 2;
                guiMgr.SetNumberField(rect, 0, ref min);
                rect.x += rect.width;
                guiMgr.SetNumberField(rect, 0, ref max);
                data.min.y = min;
                data.max.y = max;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            rect.width *= 2;
            GUI.Label(rect, "回転(min,max)", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width /= 2;
            guiMgr.SetNumberField(rect, 0f, ref data.min.z);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.max.z);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 3;
            rect.width *= 2;
            GUI.Label(rect, "サイズ(min,max)", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width /= 2;
            guiMgr.SetNumberField(rect, 0f, ref data.min.w);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.max.w);

            var count = data.fileNo.GetLength(1);
            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 4;
            GUI.Label(rect, "白濁液選択", guiStyle.gsLabel);
            rect.x += rect.width;
            if (GUI.Button(rect, "順向全選択", guiStyle.gsButton))
            {
                for (int i = 0; i < count; i++)
                {
                    data.fileNo[0, i] = true;
                }
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "逆向全選択", guiStyle.gsButton))
            {
                for (int i = 0; i < count; i++)
                {
                    data.fileNo[1, i] = true;
                }
            }
            rect.x += rect.width;
            if(GUI.Button(rect, "全解除", guiStyle.gsButton))
            {
                for (int h = 0; h < data.fileNo.GetLength(0); h++)
                {
                    for (int i = 0; i < count; i++)
                    {
                        data.fileNo[h, i] = false;
                    }
                }
            }

            for (int h = 0; h < data.fileNo.GetLength(0); h++)
            {
                for (int i = 0; i < count; i++)
                {
                    if(i == 0 || i == count / 2)
                    {
                        rect = MyConst.DEFAULT_RECT;
                        rect.y *= baseRow + 5 + h * 2 + (i == 0 ? 0 : 1);
                        rect.width /= 2;
                        if(i == 0)
                        {
                            var label = h == 0 ? "順向" : "逆向";
                            GUI.Label(rect, label, guiStyle.gsLabel);
                        }
                        rect.x += rect.width;
                    }
                    data.fileNo[h, i] = GUI.Toggle(rect, data.fileNo[h, i], (i + 1).ToString("00"), guiStyle.gsToggle);
                    rect.x += rect.width;
                }
            }
            extraMgr.BukkakeSet = data;
        }

        private void SetExtraAreaBukkakeList(List<Maid> maids, int maidIndex)
        {
            int baseRow = 5;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            GUI.Label(rect, "ぶっかけリスト", guiStyle.gsLabel);
            rect.x += rect.width * 2;
            if (GUI.Button(rect, "サンプル出力", guiStyle.gsButton))
            {
                extraMgr.ExportBukkakeSample();
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "リスト取得", guiStyle.gsButton) || MyHelper.CheckNull(extraMgr.BukkakeMenuList))
            {
                extraMgr.GetBukkakeMenuList();
            }

            var data = extraMgr.BukkakeMenuList;
            var index = guiMgr.SetSelectionGrid(baseRow, data,
                                         MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow),
                                         ref scrollBukkakeList);

            if (index != data.Count() - 1)
            {
                extraMgr.SetListBukkakeMenu(maids, maidIndex, data[index], guiMgr.IsExtraAll);
            }
        }

        private void SetExtraAreaEnema(List<Maid> maids, int maidIndex)
        {
            int baseRow = 5;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "浣腸", guiStyle.gsLabel);
            rect.x += rect.width;
            if (GUI.Button(rect, "放出", guiStyle.gsButton))
            {
                if (guiMgr.IsExtraAll)
                {
                    foreach (var maid in maids)
                    {
                        extraMgr.PlayEnema(maidMgr.GetActiveSlotNo(maid));
                    }
                }
                else
                {
                    extraMgr.PlayEnema(maidMgr.GetActiveSlotNo(maids[maidIndex]));
                }
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "停止", guiStyle.gsButton))
            {
                extraMgr.RemoveEnemaAll();
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "読込", guiStyle.gsButton))
            {
                var fReader = new FileReader();
                var path = fReader.GetFilePath(MyConst.FILE_SETTING, "");
                if (!string.IsNullOrEmpty(path))
                {
                    extraMgr.EffectSet = fReader.GetSettingOfDanceExtraEnema(path);
                }
            }

            var data = extraMgr.EffectSet;
            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "　実行時間", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.duration);
            rect.x += rect.width;
            GUI.Label(rect, "　生存時間", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.startLifetime);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            GUI.Label(rect, "　サイズ", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.startSize);
            rect.x += rect.width;
            GUI.Label(rect, "　角度", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.startRotation);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 3;
            GUI.Label(rect, "　重力", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, 0f, ref data.gravityModifier);
            rect.x += rect.width;
            rect.width *= 2;
            data.isShader = GUI.Toggle(rect, data.isShader, "シェーダー変更", guiStyle.gsToggle);

            guiMgr.SetColorSlider(baseRow + 4, ref data.color, true);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 8;
            GUI.Label(rect, "テクスチャー", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 3;
            data.textureName = guiMgr.SetTextField(rect, data.textureName);

            extraMgr.EffectSet = data;
        }

        private void SetExtraAreaPee(List<Maid> maids, int maidIndex)
        {
            int baseRow = 19;
            var isPee = false;
            var isCom3d2 = false;

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            extraMgr.IsPeeSE = GUI.Toggle(rect, extraMgr.IsPeeSE, "SE ON", guiStyle.gsToggle);
            rect.x += rect.width;
            if (GUI.Button(rect, "放尿", guiStyle.gsButton))
            {
                isPee = true;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "尿漏れ", guiStyle.gsButton))
            {
                isPee = true;
                isCom3d2 = true;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "停止", guiStyle.gsButton))
            {
                extraMgr.RemovePeeAll(maids);
            }

            if (isPee)
            {
                if (guiMgr.IsExtraAll)
                {
                    foreach (var maid in maids)
                    {
                        extraMgr.PlayPee(maid, isCom3d2);
                    }
                }
                else
                {
                    extraMgr.PlayPee(maids[maidIndex], isCom3d2);
                }
            }
        }

        #endregion

        #region GetList
        private void GetCameraLists()
        {
            cameraListIndex = 0;
            var folderPath = Path.Combine(MyHelper.RootFolder, MyConst.FOLDER_CAMERA);
            if (System.IO.Directory.Exists(@folderPath))
            {
                cameraList = new FileReader().GetCameraLists(folderPath);
            }
            else
            {
                Console.WriteLine(string.Format("カメラフォルダがありません：{0}", MyConst.FOLDER_CAMERA));
            }
        }

        private void GetDanceList(int type)
        {
            var fReader = new FileReader();
            var path = songMgr.IsSong ? MyConst.FILE_SONG_LIST : MyConst.FILE_DANCE_LIST;
            path = fReader.GetFilePath(path, "");
            if (!string.IsNullOrEmpty(path))
            {
                switch (type)
                {
                    case (int)DanceListType.Title:
                        danceList = fReader.GetFreeDanceLabel(path, songMgr.IsSong);
                        path = fReader.GetFilePath(MyConst.FILE_DANCE_MOVIE, "");
                        if (!string.IsNullOrEmpty(path))
                        {
                            danceMovieData = fReader.ReadDanceMovieData(path);
                        }
                        break;
                    case (int)DanceListType.Motion:
                        for (int i = 0; i < danceMgr.DanceScreenData.Count(); i++)
                        {
                            var data = danceMgr.DanceScreenData[i];
                            if (data.isMotionOn)
                            {
                                if (!string.IsNullOrEmpty(data.motionName))
                                {
                                    data = ReadMotionData(data);
                                }
                                if (MyHelper.CheckNull(data.motionData))
                                {
                                    data.isMotionOn = false;
                                }
                                danceMgr.DanceScreenData[i] = data;
                            }
                        }
                        break;
                    case (int)DanceListType.Data:
                        var title = danceList[danceListIndex];
                        freeDanceData = fReader.GetFreeDanceData(path, title, songMgr.IsSong);
                        if (songMgr.IsSong)
                        {
                            var manData = fReader.GetFreeDanceManData(path, title);
                            if (!MyHelper.CheckNull(manData))
                            {
                                songMgr.GetSongManPoseData(manData);
                                songMgr.SetStartedMan(manData);
                            }
                        }
                        danceMgr.DanceScreenData = fReader.GetDanceCameraMotionData(path, title, songMgr.IsSong);
                        var firstData = freeDanceData[MyConst.DANCE_FIRST_INDEX];
                        var changeFolder = songMgr.IsSong ? songMgr.GetSongFolder(firstData.songSet.folder) : MyConst.FOLDER_GHANGE;

                        var p = firstData.changeItem;
                        if (!string.IsNullOrEmpty(p))
                        {
                            p = fReader.GetFilePath(p, changeFolder);
                            if (!string.IsNullOrEmpty(p))
                            {
                                danceMgr.ItemData = fReader.ReadDanceCahngeItemData(p);
                            }
                        }
                        p = firstData.changeDress;
                        if (!string.IsNullOrEmpty(p))
                        {
                            p = fReader.GetFilePath(p, changeFolder);
                            if (!string.IsNullOrEmpty(p))
                            {
                                dressMgr.DanceDressData = fReader.ReadDanceCahngeDressData(p);
                                if (!MyHelper.CheckNull(dressMgr.DanceDressData))
                                {
                                    dressMgr.SeDanceDressPartsMenuData();
                                }
                            }
                        }
                        p = firstData.changeUndress;
                        if (!string.IsNullOrEmpty(p))
                        {
                            p = fReader.GetFilePath(p, changeFolder);
                            if (!string.IsNullOrEmpty(p))
                            {
                                dressMgr.DanceUndressData = fReader.ReadDanceCahngeUndressData(p);
                            }
                        }
                        p = firstData.changePrefab;
                        if (!string.IsNullOrEmpty(p))
                        {
                            p = fReader.GetFilePath(p, changeFolder);
                            if (!string.IsNullOrEmpty(p))
                            {
                                danceMgr.PrefabData = fReader.ReadDanceCahngePrefabData(p);
                            }
                        }
                        p = firstData.changeMaidPrefab;
                        if (!string.IsNullOrEmpty(p))
                        {
                            p = fReader.GetFilePath(p, changeFolder);
                            if (!string.IsNullOrEmpty(p))
                            {
                                danceMgr.MaidPrefabData = fReader.ReadDanceCahngeMaidPrefabData(p);
                            }
                        }
                        p = firstData.changePrimitive;
                        if (!string.IsNullOrEmpty(p))
                        {
                            p = fReader.GetFilePath(p, changeFolder);
                            if (!string.IsNullOrEmpty(p))
                            {
                                danceMgr.PrimitiveData = fReader.ReadDanceCahngePrimitiveData(p);
                            }
                        }
                        p = firstData.changeParticle;
                        if (!string.IsNullOrEmpty(p))
                        {
                            p = fReader.GetFilePath(p, changeFolder);
                            if (!string.IsNullOrEmpty(p))
                            {
                                danceMgr.DanceParticleData = new List<DanceParticle>();
                                danceMgr.ParticleData = fReader.ReadDanceCahngeParticleData(p);
                                var labels = danceMgr.ParticleData.Select(d => d.label).ToList().Distinct();
                                path = fReader.GetFilePath(MyConst.FILE_SETTING_DANCE_EFFECT, "");
                                if (!string.IsNullOrEmpty(path))
                                {
                                    foreach (var label in labels)
                                    {
                                        var data = fReader.GetSettingOfStageEffectParticle(path, label, true);
                                        if (!string.IsNullOrEmpty(data.label))
                                        {
                                            danceMgr.DanceParticleData.Add(data);
                                        }
                                    }
                                }
                            }
                        }
                        p = firstData.changeLight;
                        if (!string.IsNullOrEmpty(p))
                        {
                            p = fReader.GetFilePath(p, changeFolder);
                            if (!string.IsNullOrEmpty(p))
                            {
                                danceMgr.LightData = fReader.ReadDanceCahngeLightData(p);
                            }
                        }
                        break;
                }
            }
        }

        private void GetDanceListGroup(int type)
        {
            var isSong = songMgr.IsSong;
            var fReader = new FileReader();
            var path = isSong ? MyConst.FILE_SONG_LIST_GROUP : MyConst.FILE_DANCE_LIST_GROUP;
            path = fReader.GetFilePath(path, "");
            if (!string.IsNullOrEmpty(path))
            {
                switch (type)
                {
                    case (int)DanceListType.Title:
                        danceGroupList = fReader.GetFreeDanceGroupLabel(path, isSong);
                        break;
                    case (int)DanceListType.Data:
                        var title = danceGroupList[danceGroupIndex];
                        danceGroup = fReader.GetDanceGroupData(path, title, isSong);
                        break;
                }
            }
        }

        private void GetRandomFaceList()
        {
            try
            {
                var fReader = new FileReader();
                var path = fReader.GetFilePath(MyConst.FILE_MAID_RANDOM_FACE, "");
                if (!string.IsNullOrEmpty(path))
                {
                    randomFaceList = fReader.GetRandomFaceLabel(path);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        private void GetCustomFaceList()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_CUSTOM_FACE, "");
            if (!string.IsNullOrEmpty(path))
            {
                customFaceList = fReader.GetCustomFaceLabel(path);
            }
        }

        private void GetMovingList()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_MOVING, "");
            if (!string.IsNullOrEmpty(path))
            {
                movingList = fReader.GetMovingLabel(path);
            }
        }

        private void GetLightGroup(LightType type)
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_STAGE_LIGHT, "");
            if (!string.IsNullOrEmpty(path))
            {
                switch (type)
                {
                    case LightType.Spot:
                        lightGroupDic[type] = fReader.GetSpotLightLabel(path);
                        break;
                    case LightType.Point:
                        lightGroupDic[type] = fReader.GetPointLightLabel(path);
                        break;
                }
            }
        }
        #endregion

        #region ReadData
        private DanceCameraMotionSet ReadMotionData(DanceCameraMotionSet screenSet)
        {
            if (!string.IsNullOrEmpty(screenSet.motionName))
            {
                var fReader = new FileReader();
                var path = fReader.GetFilePath(screenSet.motionName, screenSet.subFolder);
                if (!string.IsNullOrEmpty(path))
                {
                    if (screenSet.isCustomMotion)
                    {
                        var data = fReader.ReadTimelineCameraFileData(path);
                        if (!MyHelper.CheckNull(data))
                        {
                            screenSet.motionData = mCameraMgr.ConvertDanceCameraData(data);
                        }
                    }
                    else
                    {
                        screenSet.motionData = fReader.ReadCameraMotionData(path, guiMgr.LimitY, guiMgr.IsLimitY);
                    }
                }
            }
            return screenSet;
        }

        private void ReadSwitcherData()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_SWITCER, "");
            if (!string.IsNullOrEmpty(path))
            {
                switcherData = fReader.ReadSwitcherData(path);
            }
            else
            {
                switcherData = new List<SwitcherTransformSet>();
                var d = new SwitcherTransformSet();
                d.label = "データがありません";
                switcherData.Add(d);
            }
        }

        private bool ReadMaidTransformData()
        {
            var isRead = false;
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_TRANSFORM, "");
            if (!string.IsNullOrEmpty(path))
            {
                maidTransformData = fReader.ReadMaidTransformData(path);
                isRead = true;
            }
            else
            {
                maidTransformData = new List<MaidTransformSet>();
                var d = new MaidTransformSet();
                d.label = "データがありません";
                maidTransformData.Add(d);
            }
            return isRead;
        }

        private List<FreeLightSet> ReadLightData(LightType type, int lightGroupIndex)
        {
            var lightData = new List<FreeLightSet>();
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_STAGE_LIGHT, "");
            if (!string.IsNullOrEmpty(path))
            {
                switch (type)
                {
                    case LightType.Directional:
                        var light = fReader.ReadSubLightData(path);
                        light.light = lightMgr.SubLight.light;
                        lightMgr.SubLight = light;
                        break;

                    case LightType.Spot:
                        var data = fReader.ReadSpotLightData(path, lightGroupDic[type][lightGroupIndex]);
                        foreach (var d in data)
                        {
                            lightData.Add(d);
                        }
                        break;

                    case LightType.Point:
                        data = fReader.ReadPointLightData(path, lightGroupDic[type][lightGroupIndex]);
                        foreach (var d in data)
                        {
                            lightData.Add(d);
                        }
                        break;
                }
            }
            return lightData;
        }

        /// <summary>
        /// 注視・分割設定データ読込
        /// </summary>
        private void ReadLookAtSettingData()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_LOOK_AT, "");
            if (!string.IsNullOrEmpty(path))
            {
                var data = fReader.ReadLookAtData(path, maidLookAt.settingIndex);
                if (data.divisionSet != null)
                {
                    maidLookAt = data;

                }
            }
        }

        #endregion

        #region FreeDanceEnd
        private void EndFreeDance(bool bgmStops)
        {
            try
            {
                var maids = maidMgr.GetActiveMaids();
                if (!MyHelper.CheckNull(maids))
                {
                    ResetFreeDanceMaid(maids);
                    if (bgmStops)
                    {
                        if (songMgr.IsSong && songMgr.SongType == SongType.Song)
                        {
                            songMgr.AudioMgr.StopAudioClip();
                            songMgr.ClearMyPoseData(maids);
                        }
                        else
                        {
                            soundMgr.StopBgm(1f);
                        }
                        soundMgr.PlayBGM(soundMgr.GetRandomBgmName());
                    }
                }
                if (maidMgr.IsCM3D2Dance || songMgr.IsSong && songMgr.SongType == SongType.Song)
                {
                    soundMgr.SetVolumeDance(danceVolumeBackup, false);
                }
                if (songMgr.IsSong)
                {
                    songMgr.SetEndedMan();
                }

                tlPlaySet.fromFrame = 0;
                tlPlaySet.isLoop = false;
                bgMgr.DeleteDanceBg();
                if (MyHelper.GetCameraMain().backgroundColor != bgMgr.SavedBackgroundColor)
                {
                    cameraMgr.SetBackgroundColor(bgMgr.SavedBackgroundColor);
                }
                lightMgr.ResetPixelLightCount();
                maidMgr.IsCM3D2Dance = false;
                maidMgr.InitializeDanceFacialSet();
                isFreeMotionOn = false;
                cameraMgr.IsCustome = false;
                dressMgr.IsFreeDance = false;
                danceMgr.DestroyObject();
                if (!guiMgr.IsChangingLightOff &&
                    (!MyHelper.CheckNull(danceMgr.LightData) || !MyHelper.CheckNull(danceMgr.DanceLight)))
                {
                    lightMgr.SetMainLight(true);
                }
                isMainLightOff = false;
                MyHelper.ClearList(freeDanceData);
                MyHelper.ClearList(dressMgr.DanceDressData);
                if (!dressMgr.IsUndressRandomOn)
                {
                    MyHelper.ClearList(dressMgr.DanceUndressData);
                }
                if (bgmStops && !dressMgr.IsFreeDance)
                {
                    cameraMgr.FadeIn(myGui.isFadeOn ? myGui.fadeInTime : 0f);
                }
                if (!guiMgr.IsFreeMotionOff)
                {
                    cameraMgr.ResetMainCamera();
                }
                if (myGui.isUiAutoOff)
                {
                    guiMgr.HideOfficialUi(false);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                cameraMgr.FadeIn(0f);
            }
            finally
            {
                GC.Collect();
            }
        }

        private void ResetFreeDanceMaid(List<Maid> maids)
        {
            foreach (var maid in maids)
            {
                maidMgr.ResetAnimation(maid, MyConst.ANIMATION_NO_FADE_TIME);
                maidMgr.UpdateFaceAnime(maid, MyConst.DEFAULT_FACE);
                maid.FaceBlend(MyConst.DEFAULT_BLEND);
                maid.boMabataki = true;
                if (songMgr.IsSong)
                {
                    songMgr.ResetSongKuchipaku(maid);
                    maidMgr.RemoveAnimationClip(maid);
                    maidMgr.SetVertexMorphFromProcItem(maid, MyConst.BODY_TAG_KUPA, 0f);
                    maidMgr.SetVertexMorphFromProcItem(maid, MyConst.BODY_TAG_ANALKUPA, 0f);
                }
                else
                {
                    maid.StopKuchipakuPattern();
                }

                if (maid.transform.localScale == MyHelper.GetVector3(MyConst.SCALE_INVISIBLE_MAID))
                {
                    maid.transform.localScale = MyHelper.GetVector3(MyConst.SCALE_DEFAULT);
                }

                maidMgr.SetWaitPosition(maid);

                if (dressMgr.IsUndressRandomOn || !MyHelper.CheckNull(dressMgr.DanceUndressData))
                {
                    foreach (var key in MyConst.UNDRESS_SLOT.Keys)
                    {
                        if (key >= 0)
                        {
                            if (!maid.body0.GetSlotVisible(key))
                            {
                                maid.body0.SetMask(key, true);
                            }
                        }
                    }
                }
                if (!MyHelper.CheckNull(danceMgr.ItemData))
                {
                    foreach (var data in danceMgr.ItemData)
                    {
                        var slotNo = maidMgr.GetDanceSlotNo(maid);
                        if (data.activeSlotNo == slotNo && data.tag.ToLower() == MyConst.ITEM_HAND)
                        {
                            maid.body0.SetMask(TBody.SlotID.HandItemL, true);
                            maid.body0.SetMask(TBody.SlotID.HandItemR, true);
                            maid.SetProp(MyConst.ITEM_HAND, string.Format(MyConst.ITEM_DEL_MENU, MyConst.ITEM_HAND), 0, true, false);
                            maid.AllProcPropSeqStart();
                        }
                    }
                }
                if (!MyHelper.CheckNull(danceMgr.MaidPrefabData))
                {
                    foreach (var data in danceMgr.MaidPrefabData)
                    {
                        var key = data.name + data.group;
                        maid.DelPrefab(key);
                    }
                }
                if (!MyHelper.CheckNull(danceMgr.PrimitiveData))
                {
                    foreach (var data in danceMgr.PrimitiveData)
                    {
                        if (data.option.ToLower().Contains(MyConst.OBJECT_OPTION_LIFTUP))
                        {
                            var p = maid.transform.position;
                            p.y = 0;
                            maid.SetPos(p);
                        }
                    }
                }
                maid.DelPrefab(MyConst.PERTICLE_BREATH);
                maid.DelPrefab(MyConst.PERTICLE_PEE_CM);
                maid.DelPrefab(MyConst.PERTICLE_PEE_COM);
            }

            if (dressMgr.IsFreeDance)
            {
                dressMgr.ResetDressMenu(maids);
                dressMgr.IsEnding = true;
            }

        }
        #endregion

        #region FreeDanceStart
        private bool StartFreeDance(bool bgmStops)
        {
            var isFree = false;
            try
            {
                danceMgr = new DanceObjectManager();
                if (isFreeGroupOn)
                {
                    ChangeFreeDanceListIndex();
                }
                if (!guiMgr.IsChangeDressOff && dressMgr.IsUndressRandomOn)
                {
                    var u = dressMgr.UndressRandom;
                    u.time = 0f;
                    dressMgr.UndressRandom = u;
                }

                freeSliderCurrent = 0;
                danceBgIndex = 0;
                GetDanceList((int)DanceListType.Data);

                var maids = maidMgr.GetActiveMaids();
                if (MyHelper.CheckNull(maids))
                {
                    Console.WriteLine("メイドが配置されていません");
                    return isFree;
                }
                else if (MyHelper.CheckNull(freeDanceData))
                {
                    return isFree;
                }

                if (isMaidShuffle)
                {
                    maidMgr.ShuffleMaidSlot(maids);
                }
                else
                {
                    if (MyHelper.CheckNull(maidMgr.SlotDic))
                    {
                        maidMgr.ResetMaidSlot(maids);
                    }
                    maidMgr.AdjustMaidSlot();
                }

                if (myGui.isMaidsDanceOn)
                {
                    maidMgr.SetAoutDanceSlot(freeDanceData);
                }

                var firstData = freeDanceData[MyConst.DANCE_FIRST_INDEX];
                var bgmName = firstData.bgmName;
                maidMgr.IsCM3D2Dance = (firstData.type == MyConst.DANCE_TYPE_CM3D2);
                songMgr.SongType = SongType.Song;
                if (firstData.type == MyConst.DANCE_TYPE_COM3D2)
                {
                    songMgr.SongType = SongType.Com3d2;
                }
                else if (maidMgr.IsCM3D2Dance)
                {
                    songMgr.SongType = SongType.Cm3d2;
                }

                var isExist = false;
                if (maidMgr.IsCM3D2Dance)
                {
                    isExist = MyHelper.IsExistingOfficialFileOld(bgmName);
                }
                else
                {
                    if (songMgr.IsSong && songMgr.SongType == SongType.Song)
                    {
                        isExist = songMgr.AudioMgr.LoadAndPlayAudioClip(songMgr.GetSongFolder(firstData.songSet.folder), bgmName);
                    }
                    else
                    {
                        isExist = MyHelper.IsExistingOfficialFile(bgmName);
                    }
                }

                if (!isExist)
                {
                    Console.WriteLine(string.Format("選択されたダンスが導入されていません:{0}", bgmName));
                    return isFree;
                }

                if (myGui.isFadeOn)
                {
                    cameraMgr.FadeOut(0f);
                }

                if (maidMgr.IsCM3D2Dance || songMgr.IsSong && songMgr.SongType == SongType.Song)
                {
                    if (bgmStops)
                    {
                        soundMgr.StopBgm(0f);
                    }
                    danceVolumeBackup = soundMgr.GetVolumeDance();
                    if (songMgr.IsSong && songMgr.SongType == SongType.Song)
                    {
                        songMgr.AudioMgr.PlayAudioClip();
                        songMgr.AudioMgr.SetAudioClipTime(0f);
                        songMgr.AudioMgr.SetVolumeDance(danceVolumeLegacy);
                    }
                    else
                    {
                        soundMgr.PlayBGMCM3D2Dance(bgmName);
                        soundMgr.SetBgmTime(0f);
                        soundMgr.SetVolumeDance(danceVolumeLegacy, true);
                    }
                }
                else
                {
                    soundMgr.PlayDanceBGM(bgmName);
                    soundMgr.SetBgmTime(0f);
                }

                tlWindowMgr.IsEnabled = false;
                tlPlaySet.isEnabledCamera = false;
                tlPlaySet.isLoop = false;
                tlPlaySet.fromFrame = 0;
                tlPlaySet.toFrame = 0;
                freeSliderMax = GetAudioLength() - MyConst.DANCE_END_MARGIN;
                endBgmTime = firstData.endTime > 0 ? firstData.endTime - MyConst.DANCE_END_MARGIN : freeSliderMax;
                additionalBgmTime = freeSliderMax;
                guiMgr.IsFacialEnabled = false;

                SetFreeDanceMaid(maids);
                GetDanceList((int)DanceListType.Motion);

                isFreeMotionOn = danceMgr.IsCameraMotionOn();
                var screen = danceMgr.DanceScreenData[MyConst.CAMERA_MAIN];
                if (screen.isCustomMotion)
                {
                    screen.isCustomMotion = songMgr.GetSongCameraData(screen.subFolder, screen.motionName);
                    screen.cameraMgr.IsCustome = true;
                    danceMgr.DanceScreenData[MyConst.CAMERA_MAIN] = screen;
                    cameraMgr.IsCustome = true;
                }

                var startTime = (cameraFree.stTime > 0) ? cameraFree.stTime : firstData.startTime;
                if (startTime > 0)
                {
                    SetAnimationAndBgmTime(startTime, isFreeStoped);
                    danceMgr.SetCameraMotionData(startTime);
                    danceMgr.SeekVideo(startTime);
                }
                var png = firstData.changePng;
                if (!MyHelper.CheckNull(png))
                {
                    var fReader = new FileReader();
                    danceMgr.PngSpriteRenderer = fReader.GetPngFile(png, spriteSet);
                }
                if (!MyHelper.CheckNull(danceMgr.PrefabData))
                {
                    danceMgr.DuplicatePrefabData(maids, maidMgr);
                    danceMgr.AdjustPrefabData(maids, maidMgr);
                    danceMgr.LoadDancePrefabObject();
                    danceMgr.KeepMaidPositionY(maids, maidMgr);
                }
                if (!MyHelper.CheckNull(danceMgr.PrimitiveData))
                {
                    danceMgr.DuplicatePrimitiveData(maids, maidMgr);
                    danceMgr.AdjustPrimitiveData(maids, maidMgr);
                    danceMgr.CreateDancePrimitive();
                    danceMgr.LoadDancePrimitiveTexture();
                }
                if (!MyHelper.CheckNull(danceMgr.ParticleData))
                {
                    danceMgr.CreateDanceParticle();
                }
                if (!MyHelper.CheckNull(danceMgr.LightData))
                {
                    lightMgr.SetPixelLightCount(maids.Count());
                    danceMgr.DuplicateLightData(maids, maidMgr);
                    danceMgr.CreateDanceLightObject(lightMgr);
                }
                danceMgr.CreateScreen(renderTextureSet);

                bgMgr.SavedBackgroundName = "";
                bgMgr.SavedBackgroundColor = MyHelper.GetCameraMain().backgroundColor;
                if (!guiMgr.IsChangingBgOff)
                {
                    if (!MyHelper.CheckNull(firstData.changeBg))
                    {
                        bgMgr.SavedBackgroundName = bgMgr.GetBackgroundName();
                        var firstBg = firstData.changeBg[0];
                        if (firstBg.bgName.ToLower() == MyConst.BG_DELETE)
                        {
                            bgMgr.DeleteBackground();
                        }
                        else
                        {
                            if (firstData.changeBg.Count() == 1)
                            {
                                FreeBgSet bgSet = new FreeBgSet();
                                bgSet.bgName = firstBg.bgName;
                                bgSet.position = firstBg.transform.stPos;
                                bgSet.rotation = firstBg.transform.stRot;
                                bgSet.scale = MyConst.SCALE_DEFAULT;

                                if (bgMgr.SavedBackgroundName != bgSet.bgName &&
                                    MyHelper.IsExistingArrayKey(MyConst.STAGE_LIVE, bgMgr.SavedBackgroundName) &&
                                    MyHelper.IsExistingArrayKey(MyConst.STAGE_LIVE, bgSet.bgName))
                                {
                                    bgSet.bgName = bgMgr.SavedBackgroundName;
                                }
                                bgMgr.ChangeBackground(bgSet);
                            }
                            else
                            {
                                var dic = new Dictionary<string, string>();
                                foreach (var bg in firstData.changeBg)
                                {
                                    dic[bg.bgName + bg.groupNo] = bg.bgName;
                                }
                                bgMgr.DeleteBackground();
                                bgMgr.LoadDanceBg(dic);
                            }
                        }
                    }
                    else if (isAoutChangingBg)
                    {
                        bgMgr.SavedBackgroundName = bgMgr.GetBackgroundName();
                        bgMgr.ChangeRandomBackground();
                    }
                    if (firstData.changeBgColor != bgMgr.SavedBackgroundColor)
                    {
                        cameraMgr.SetBackgroundColor(firstData.changeBgColor);
                    }
                }
                if (guiMgr.DanceMovieTypeIndex != (int)DanceMovieType.Non)
                {
                    if (songMgr.IsSong && !string.IsNullOrEmpty(firstData.songSet.movieName))
                    {
                        danceMgr.LoadSongMovie(firstData.songSet, guiMgr.IsMovieTransparent);
                    }
                    else if (!MyHelper.CheckNull(danceMovieData) && !string.IsNullOrEmpty(firstData.movieLabel))
                    {
                        danceMgr.LoadDanceMovie(danceMovieData, (DanceMovieType)guiMgr.DanceMovieTypeIndex,
                                            firstData.movieLabel, bgMgr.GetBackgroundName(), guiMgr.IsMovieTransparent);
                    }
                }

                if (isRandomFace)
                {
                    maidMgr.SetStartRandomFace(maids, randomFaceList[randomFaceIndex], guiMgr.IsKuchipakuDisabled);
                }

                if (myGui.isGuiAutoOff)
                {
                    myGui.isGuiOn = false;
                }
                if (myGui.isUiAutoOff)
                {
                    guiMgr.HideOfficialUi(true);
                }

                if (dressMgr.IsStarting)
                {
                    StopFreeDance(true);
                }
                else if (myGui.isFadeOn)
                {
                    cameraMgr.FadeIn(myGui.fadeInTime);
                }

                if (myGui.isDanceCameraAdjustOn)
                {
                    for (int i = 0; i < danceMgr.DanceScreenData.Count(); i++)
                    {
                        var data = danceMgr.DanceScreenData[i];
                        data.adjustPlugin = new DanceCameraAdjustPlugin(cameraAdjust);
                        danceMgr.DanceScreenData[i] = data;
                    }
                }
                isFree = isExist;
                var syncSet = guiMgr.DanceSyncSet;
                syncSet.isFirstSync = true;
                guiMgr.DanceSyncSet = syncSet;
                cameraMgr.ResetAutoCamera();
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                EndFreeDance(true);
                cameraMgr.FadeIn(0f);
            }
            return isFree;
        }

        private void ChangeFreeDanceListIndex()
        {
            if (!MyHelper.CheckNull(danceGroup.danceLabel))
            {
                if (danceGroup.playType == MyConst.DANCE_PLAY_RANDOM)
                {
                    var group = danceGroup.danceLabel.FindAll(d => d != danceList[danceListIndex]);
                    if (MyHelper.CheckNull(group))
                    {
                        return;
                    }
                    danceGroupPlayIndex = MyHelper.GetRandomIndex(group.Count());
                }
                else
                {
                    danceGroupPlayIndex++;
                    if (danceGroupPlayIndex >= danceGroup.danceLabel.Count())
                    {
                        danceGroupPlayIndex = 0;
                    }
                }
                var index = danceList.FindIndex(d => d == danceGroup.danceLabel[danceGroupPlayIndex]);
                if (index > -1)
                {
                    danceListIndex = index;
                }
            }
        }

        private void SetFreeDanceMaid(List<Maid> maids)
        {
            maidMgr.ResetIndex(maids);
            songMgr.ResetIndex(maids, maidMgr, true);
            maidMgr.StockWaitPosition(maids);
            var visibleDic = new Dictionary<int, bool>();
            var dressDic = new Dictionary<int, string>();
            var dressList = new List<string>();
            var indexList = new List<int>();
            var maidTransform = "";

            guiMgr.IsRandomDress = guiMgr.IsRandomDress && dressMgr.DressGroupList.Any();
            if (guiMgr.IsRandomDress)
            {
                dressList = dressMgr.GetDressGroupSpecifiedList(dressMgr.DressGroupList[dressMgr.DressGroupIndex]);
            }

            foreach (var maid in maids)
            {
                foreach (var data in freeDanceData)
                {
                    var activeSlot = maidMgr.GetActiveSlotNo(maid);
                    var danceSlot = maidMgr.GetDanceSlotNo(maid);
                    maidTransform = data.maidTransform;
                    if (data.activeSlotNo == danceSlot && maidMgr.ExistSlotInFaceList(activeSlot))
                    {
                        var anim = data.animation;
                        if (string.IsNullOrEmpty(anim))
                        {
                            anim = MyConst.DEFAULT_ANIME;
                        }
                        var songSet = freeDanceData.FirstOrDefault(d => d.activeSlotNo == danceSlot).songSet;

                        if (songMgr.IsSong && !string.IsNullOrEmpty(data.animation))
                        {
                            if (songSet.isCustomAnm)
                            {
                                maidMgr.CrossFadeMyPose(maid, data.animation, songMgr.GetMyPoseData(songSet.folder, data.animation, songSet.isCustomAnm), false, 0);
                            }
                            else
                            {
                                maidMgr.CrossFadeDance(maid, anim);
                            }
                            if (data.songSet.animationSpeed != MyConst.ANIMATION_SPEED)
                            {
                                var state = maidMgr.GetAnimationState(maid);
                                if (state != null)
                                {
                                    state.speed = data.songSet.animationSpeed;
                                }
                            }
                        }
                        else
                        {
                            maidMgr.CrossFadeDance(maid, anim);
                        }

                        var isMorph = !string.IsNullOrEmpty(data.songSet.morph);
                        if (!data.isMabatakiOn &&
                            (!MyHelper.CheckNull(data.face) || isRandomFace || isMorph))
                        {
                            maidMgr.SetMabatakiOff(maid);
                        }
                        if (songMgr.IsSong && string.IsNullOrEmpty(data.mouth))
                        {
                            if (!string.IsNullOrEmpty(data.songSet.lyrics))
                            {
                                songMgr.SetSongKuchipaku(data.songSet, activeSlot);
                            }
                            if (isMorph)
                            {
                                songMgr.GetSongMorphData(data.songSet.folder, data.songSet.morph, activeSlot);
                            }
                            songMgr.GetSongPoseData(data.songSet, activeSlot);
                        }
                        else
                        {
                            maid.StartKuchipakuPattern(0f, data.mouth, true);
                        }
                        if (!isAnyTransform && !isAutoTransform && string.IsNullOrEmpty(maidTransform))
                        {
                            maid.SetPos(data.transform.stPos);
                            maid.SetRot(data.transform.stRot);
                        }

                        if (!MyHelper.CheckNull(danceMgr.ItemData))
                        {
                            foreach (var item in danceMgr.ItemData)
                            {
                                if (item.activeSlotNo == danceSlot && item.tag.ToLower() == MyConst.ITEM_HAND)
                                {
                                    maid.body0.SetMask(TBody.SlotID.HandItemL, false);
                                    maid.body0.SetMask(TBody.SlotID.HandItemR, false);
                                }
                            }
                        }
                        if (!guiMgr.IsMaidVisibledOff)
                        {
                            visibleDic[maidMgr.GetActiveSlotNo(maid)] = true;
                        }
                        if (!guiMgr.IsFreeEffectOff && !guiMgr.IsChangeDressOff)
                        {
                            if (guiMgr.IsRandomDress && dressList.Any())
                            {
                                if (!indexList.Any())
                                {
                                    for (int i = 0; i < dressList.Count(); i++)
                                    {
                                        indexList.Add(i);
                                    }
                                }
                                var index = MyHelper.GetRandomIndex(indexList.Count());
                                dressDic[activeSlot] = dressList[index];
                                indexList.Remove(index);
                            }
                            else if (!MyHelper.CheckNull(dressMgr.DanceDressData))
                            {
                                for (int i = 0; i < dressMgr.DanceDressData.Count(); i++)
                                {
                                    var d = dressMgr.DanceDressData[i];
                                    if (d.time <= data.startTime && d.slotNo == danceSlot)
                                    {
                                        dressDic[activeSlot] = d.label;
                                        d.isChanged = true;
                                        dressMgr.DanceDressData[i] = d;
                                    }
                                }
                            }
                        }
                        break;
                    }
                }
                if (myGui.isMaidsEyesOn)
                {
                    maidMgr.SetEyeToCamera(maid, Maid.EyeMoveType.目だけ向ける);
                }
                if (extraMgr.IsBreath)
                {
                    extraMgr.SetBreath(maid, true);
                }
            }

            if (dressDic.Any())
            {
                dressMgr.SetDanceDress(maids, dressDic, false);
            }
            else
            {
                swingMgr.SetAutoDance(maids, myGui.isMaidsSwingMuneOn, myGui.isMaidsSwingHairOn, myGui.isMaidsSwingDressOn, maidMgr.IsMultipleMaids);
            }

            var isRead = true;
            if (MyHelper.CheckNull(maidTransformData))
            {
                isRead = ReadMaidTransformData();
            }

            var isZeroTransform = false;
            if (isRead && !isAnyTransform)
            {
                MaidTransformSet mdData = new MaidTransformSet();
                if (!string.IsNullOrEmpty(maidTransform))
                {
                    mdData = maidTransformData.Find(d => d.label == maidTransform);
                }
                else if(isAutoTransform)
                {
                    mdData = maidTransformData.Find(d => d.auto == freeDanceData.Count());
                }
                if (!string.IsNullOrEmpty(mdData.label))
                {
                    maidMgr.SetMaidPosition(maids, mdData);
                }
                else if (isAutoTransform || !string.IsNullOrEmpty(maidTransform))
                {
                    isZeroTransform = true;
                }
            }
            maidMgr.StockDancePositiona(maids);

            if (!isAnyTransform && (isAutoTransform || !string.IsNullOrEmpty(maidTransform)))
            {
                foreach (var data in freeDanceData)
                {
                    var ms = maids.Where(m => maidMgr.GetDanceSlotNo(m) == data.activeSlotNo);
                    if (ms != null && ms.Any())
                    {
                        foreach (var m in ms)
                        {
                            var pos = Vector3.zero;
                            var rot = Vector3.zero;
                            if (!isZeroTransform)
                            {
                                pos = m.transform.position;
                                rot = m.transform.eulerAngles;
                            }
                            m.SetPos(pos + data.transform.stPos);
                            m.SetRot(rot + data.transform.stRot);
                        }
                    }
                }
            }
            if (songMgr.IsSong)
            {
                maidMgr.StockDancePositiona(maids);
            }

            if (!MyHelper.CheckNull(visibleDic))
            {
                foreach (Maid maid in maids)
                {
                    if (!visibleDic.ContainsKey(maidMgr.GetActiveSlotNo(maid)))
                    {
                        maid.transform.localScale = MyHelper.GetVector3(MyConst.SCALE_INVISIBLE_MAID);
                    }
                }
            }
        }
        #endregion

        #region FreeDanceStop
        private void StopFreeDance(bool isFreeStoped)
        {
            try
            {
                var maids = maidMgr.GetActiveMaids();
                if (!MyHelper.CheckNull(maids))
                {
                    var bgmTime = GetBgmTime();
                    SetFreeDanceIndex(maids, isFreeStoped, bgmTime);
                    if (!isFreeStoped)
                    {
                        if (!MyHelper.CheckNull(danceMgr.DanceScreenData))
                        {
                            for (int i = 0; i < danceMgr.DanceScreenData.Count(); i++)
                            {
                                if (danceMgr.DanceScreenData[i].isMotionOn)
                                {
                                    var screen = danceMgr.DanceScreenData[i];
                                    screen.cameraMgr.Initialize();
                                    screen.cameraMgr.IncrementIndex(screen.motionData, bgmTime);
                                    danceMgr.DanceScreenData[i] = screen;
                                }
                            }
                        }
                        danceBgIndex = 0;
                    }
                    else
                    {
                        if (!MyHelper.CheckNull(danceMgr.MaidPrefabData))
                        {
                            foreach (var maid in maids)
                            {
                                foreach (var data in danceMgr.MaidPrefabData)
                                {
                                    var key = data.name + data.group;
                                    maid.DelPrefab(key);
                                }
                            }
                        }
                    }
                }
                if (isFreeStoped)
                {
                    if (songMgr.IsSong && songMgr.SongType == SongType.Song)
                    {
                        songMgr.AudioMgr.PauseAudioClip();
                    }
                    else
                    {
                        soundMgr.PauseBgm();
                    }
                    danceMgr.PauseVideo(true);
                    songMgr.SetStopedMan(true);
                }
                else
                {
                    if (songMgr.IsSong && songMgr.SongType == SongType.Song)
                    {
                        songMgr.AudioMgr.UnPauseAudioClip();
                    }
                    else
                    {
                        soundMgr.UnPauseBgm();
                    }
                    danceMgr.PauseVideo(false);
                    songMgr.SetStopedMan(false);
                }

                if (!MyHelper.CheckNull(danceMgr.PrefabData))
                {
                    foreach (var data in danceMgr.PrefabData)
                    {
                        var key = data.name + data.group;
                        if (danceMgr.DancePrefab.ContainsKey(key))
                        {
                            if (data.option.ToLower().Contains(MyConst.OBJECT_OPTION_NOTDEACTIVE))
                            {
                                danceMgr.DancePrefab[key].SetActive(false);
                            }
                        }
                    }
                }
                if (!MyHelper.CheckNull(danceMgr.LightData))
                {
                    lightMgr.SetMainLight(true);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        private void SetFreeDanceIndex(List<Maid> maids, bool isFreeStoped, float bgmTime)
        {
            maidMgr.ResetIndex(maids);
            songMgr.ResetIndex(maids, maidMgr, false);
            foreach (var maid in maids)
            {
                var activeSlot = maidMgr.GetActiveSlotNo(maid);
                var danceSlot = maidMgr.GetDanceSlotNo(maid);
                var dance = new FreeDanceSet();
                dance.activeSlotNo = MyConst.PRE_INDEX;
                foreach (var data in freeDanceData)
                {
                    if (data.activeSlotNo == danceSlot)
                    {
                        dance = data;
                        break;
                    }
                }

                if (isFreeStoped)
                {
                    if (songMgr.IsSong)
                    {
                        songMgr.ResetSongKuchipaku(maid);
                    }
                    if (!string.IsNullOrEmpty(dance.mouth))
                    {
                        maid.StopKuchipakuPattern();
                    }
                }
                else
                {
                    if (cameraFree.stTime > 0)
                    {
                        SetAnimationAndBgmTime(cameraFree.stTime, isFreeStoped);
                    }
                    if (songMgr.IsSong && songMgr.ExistSlotInFaceList(activeSlot))
                    {
                        songMgr.SetRestartIndex(maidMgr.GetActiveSlotNo(maid), bgmTime);
                    }
                    if (maidMgr.ExistSlotInFaceList(activeSlot))
                    {
                        maidMgr.UpdateFaceListIndex(dance, bgmTime, activeSlot, maid);
                    }
                    if (!string.IsNullOrEmpty(dance.mouth))
                    {
                        maid.StartKuchipakuPattern(0f, dance.mouth, true);
                    }
                    if (dance.activeSlotNo != MyConst.PRE_INDEX)
                    {
                        maidMgr.UpdateAnimationListIndex(dance, bgmTime, activeSlot, maid);
                    }
                }
                songMgr.SetRestartIndexMan(bgmTime);

                var state = maidMgr.GetAnimationState(maid);
                if (state != null)
                {
                    var speed = MyConst.ANIMATION_SPEED;
                    if (songMgr.IsSong && songMgr.SongType == SongType.Song)
                    {
                        speed = dance.songSet.animationSpeed;
                    }
                    state.speed = isFreeStoped ? 0f : speed;
                }
            }
        }
        #endregion

        #region SetMethod
        private void SetAnimationAndBgmTime(float bgmTime, bool isFreeStoped)
        {
            var maids = maidMgr.GetActiveMaids();
            bgmTime = (bgmTime > freeSliderMax) ? 0f : bgmTime;
            if (songMgr.IsSong && songMgr.SongType == SongType.Song)
            {
                songMgr.AudioMgr.SetAudioClipTime(bgmTime);

                if (!MyHelper.CheckNull(maids))
                {
                    foreach (var maid in maids)
                    {
                        foreach (var data in freeDanceData)
                        {
                            var slotNo = maidMgr.GetDanceSlotNo(maid);
                            if (data.activeSlotNo == slotNo && (!string.IsNullOrEmpty(data.animation)))
                            {
                                maidMgr.SetAnimationTime(maid, bgmTime, isFreeStoped, data.songSet.animationSpeed);
                                break;
                            }
                        }
                    }
                }
            }
            else
            {
                
                if (!MyHelper.CheckNull(maids))
                {
                    foreach (var maid in maids)
                    {
                        maidMgr.SetAnimationTime(maid, bgmTime, isFreeStoped);
                    }
                }
                soundMgr.SetBgmTime(bgmTime);
            }
            danceMgr.SeekVideo(bgmTime);
        }

        private void SetScreenCameraMotion(List<Maid> maids)
        {
            for (int i = 0; i < danceMgr.DanceScreenData.Count(); i++)
            {
                var screenData = danceMgr.DanceScreenData[i];
                if (screenData.isMotionOn)
                {
                    var isScreenOnOff = guiMgr.DanceMovieTypeIndex != (int)DanceMovieType.Non && !guiMgr.IsFreeEffectOff;
                    var bgmTime = GetBgmTime();
                    screenData.cameraMgr.ZoomSlider = cameraMgr.ZoomSlider;
                    screenData.cameraMgr.TransformMotionCamera(screenData, bgmTime, adjustmentPosition, isScreenOnOff);
                    if (myGui.isDanceCameraAdjustOn)
                    {
                        screenData.adjustPlugin.AdjustCamera(maids, screenData.camera.transform);
                    }
                    if (cameraFree.edTime != 0 && cameraFree.edTime > cameraFree.stTime && bgmTime >= cameraFree.edTime)
                    {
                        SetAnimationAndBgmTime(cameraFree.stTime, isFreeStoped);
                        screenData.cameraMgr.Initialize();
                        screenData.cameraMgr.IncrementIndex(screenData.motionData, cameraFree.stTime);
                        if (myGui.isDanceCameraAdjustOn)
                        {
                            screenData.adjustPlugin = new DanceCameraAdjustPlugin(cameraAdjust);
                        }
                        danceMgr.DanceScreenData[i] = screenData;
                    }
                }
            }
        }

        private void SetLookAtCameraAwake()
        {
            maidLookAt.dividedIndex = MyConst.PRE_INDEX;
            maidLookAt.chasingSpeed = MyConst.LOOK_AT_CHASING_SPEED;

            maidLookAt.divisionSet = new MaidLookAtEachSet[MyConst.LOOK_AT_DIVISION];
            for (int i = 0; i < maidLookAt.divisionSet.Count(); i++)
            {
                maidLookAt.divisionSet[i].offsetX = 0f;
                maidLookAt.divisionSet[i].fixedPosY = MyConst.LOOK_AT_FIXED_POS_Y;
                maidLookAt.divisionSet[i].fixedRotX = MyConst.LOOK_AT_FIXED_ROT_X;
                maidLookAt.divisionSet[i].fixedRotY = MyConst.LOOK_AT_FIXED_ROT_Y;
            }
            maidLookAt.subSet = new MaidLookAtEachSet[MyConst.LOOK_AT_SUB];
            for (int i = 0; i < maidLookAt.subSet.Count(); i++)
            {
                maidLookAt.subSet[i].offsetX = 0f;
                maidLookAt.subSet[i].fixedPosY = MyConst.LOOK_AT_FIXED_POS_Y;
                maidLookAt.subSet[i].fixedRotX = MyConst.LOOK_AT_FIXED_ROT_X;
                maidLookAt.subSet[i].fixedRotY = MyConst.LOOK_AT_FIXED_ROT_Y;
            }
            maidLookAt.lockSet = new MaidLookAtEachSet[MyConst.LOOK_AT_LOCK_ON];
            for (int i = 0; i < maidLookAt.lockSet.Count(); i++)
            {
                maidLookAt.lockSet[i].offsetX = 0f;
                maidLookAt.lockSet[i].fixedPosY = MyConst.LOOK_AT_FIXED_POS_Y;
                maidLookAt.lockSet[i].fixedRotX = MyConst.LOOK_AT_FIXED_ROT_X;
                maidLookAt.lockSet[i].fixedRotY = MyConst.LOOK_AT_FIXED_ROT_Y;
            }
        }

        private void SetLookAtCamera(LookAtCameraManager lookAtMgr)
        {
            var eachSets = new MaidLookAtEachSet[0];
            switch (maidLookAt.lookAtIndex)
            {
                case (int)LookAtCameraType.Horizon:
                case (int)LookAtCameraType.Vertical:
                    eachSets = maidLookAt.divisionSet;
                    break;
                case (int)LookAtCameraType.SubCamera:
                    eachSets = maidLookAt.subSet;
                    break;
                case (int)LookAtCameraType.LockOn:
                    eachSets = maidLookAt.lockSet;
                    break;
            }
            var isUpdate = false;
            var maids = maidMgr.GetVisibleMaids();
            if (!MyHelper.CheckNull(maids))
            {
                var IsChanging = lookAtMgr.IsChangingTime(maidLookAt.randomTime);
                List<int> maidList = null;
                for (int i = eachSets.GetLength(0) - 1; i >= 0; i--)
                {
                    var eachSet = eachSets[i];
                    if (eachSet.isRandomMaid)
                    {
                        if (IsChanging)
                        {
                            if (MyHelper.CheckNull(maidList))
                            {
                                maidList = Enumerable.Range(0, maids.Count()).ToList();
                            }
                            if (eachSet.isLookAt)
                            {
                                eachSet.maidIndex = lookAtMgr.SetRandomMaid(eachSet.maidIndex, maidList);
                                maidList.Remove(eachSet.maidIndex);
                                eachSets[i] = eachSet;
                            }
                        }
                        isUpdate = true;
                    }
                }

                switch (maidLookAt.lookAtIndex)
                {
                    case (int)LookAtCameraType.Horizon:
                    case (int)LookAtCameraType.Vertical:
                        lookAtMgr.DividedCamera(maidLookAt.dividedIndex, maidLookAt.lookAtIndex == (int)LookAtCameraType.Vertical);
                        break;
                    case (int)LookAtCameraType.SubCamera:
                        lookAtMgr.SetSubScreen(eachSets);
                        break;
                    case (int)LookAtCameraType.LockOn:
                        lookAtMgr.LockOn();
                        break;
                }

                for (int i = 0; i < eachSets.Count(); i++)
                {
                    if (i == 0 && maidLookAt.isMotionOn)
                    {
                        lookAtMgr.SetCameraMotion();
                    }
                    else
                    {
                        var eachSet = eachSets[i];
                        if (eachSet.isLookAt)
                        {
                            if (eachSet.isRandomPoint)
                            {
                                if (IsChanging)
                                {
                                    eachSet.pointIndex = lookAtMgr.SetRandomPoint(eachSet.pointIndex);
                                }
                                isUpdate = true;
                            }
                            if (maids.Count() <= eachSet.maidIndex)
                            {
                                eachSet.maidIndex = 0;
                            }
                            eachSet = lookAtMgr.SetLookAtMaid(eachSet, lookAtSet, i, maids[eachSet.maidIndex], maidLookAt);
                            eachSets[i] = eachSet;
                        }
                    }
                }
                if (maidLookAt.isMaidEye)
                {
                    var index = eachSets[0].maidIndex;
                    for (int i = 0; i < maids.Count(); i++)
                    {
                        var type = i == index ? Maid.EyeMoveType.目と顔を向ける : Maid.EyeMoveType.無し;
                        maidMgr.SetEyeToCamera(maids[i], type);
                    }
                }

                if (IsChanging)
                {
                    lookAtMgr.InitializeRandomTime();
                }
                else if (isUpdate)
                {
                    lookAtMgr.UpdateRandomTime();
                }

                switch (maidLookAt.lookAtIndex)
                {
                    case (int)LookAtCameraType.Horizon:
                    case (int)LookAtCameraType.Vertical:
                        maidLookAt.divisionSet = eachSets;
                        break;
                    case (int)LookAtCameraType.SubCamera:
                        maidLookAt.subSet = eachSets;
                        break;
                    case (int)LookAtCameraType.LockOn:
                        maidLookAt.lockSet = eachSets;
                        break;
                }
            }
        }

        private void SetGearMenu()
        {
            try
            {
                if (myGui.gear == null && myGui.isGearOn)
                {
                    var reader = new FileReader();
                    var path = reader.GetFilePath(MyConst.FILE_GEAR, MyConst.FOLDER_PNG);
                    if (!string.IsNullOrEmpty(path))
                    {
                        var pngData = reader.ReadBinary(path);
                        myGui.gear = GearMenu.Buttons.Add(MyConst.PLUGIN_NAME, pngData, ClickGearButton);
                        GearMenu.Buttons.SetFrameColor(myGui.gear, Color.black);
                    }
                    else
                    {
                        myGui.isGearOn = false;
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                myGui.isGearOn = false;
            }
        }

        #endregion

        #region GetMethod
        private float GetBgmTime()
        {
            float bgmTime;
            if (songMgr.IsSong && songMgr.SongType == SongType.Song)
            {
                bgmTime = songMgr.AudioMgr.GetAudioClipTime();
            }
            else
            {
                bgmTime = soundMgr.GetBgmTime();
            }

            if (!isDance && freeSliderMax != endBgmTime && (freeSliderMax < bgmTime || freeSliderMax != additionalBgmTime))
            {
                if (freeSliderMax == additionalBgmTime)
                {
                    additionalBgmTime = bgmTime;
                }
                bgmTime = additionalBgmTime;
            }
            return bgmTime;
        }

        private float GetAudioLength()
        {
            float length;
            if (songMgr.IsSong && songMgr.SongType == SongType.Song)
            {
                length = songMgr.AudioMgr.GetAudioClipLength();
            }
            else
            {
                length = soundMgr.GetClipLength();
            }
            return length;
        }

        private void GetSetting()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_SETTING, "");
            if (!string.IsNullOrEmpty(path))
            {
                myGui = fReader.GetSettingOfGui(path, myGui);
                windowMgr = fReader.GetSettingOfGameWindow(path);
                isAutoTransform = myGui.isMaidsDanceOn;
                if (myGui.isBackgroundEnabled)
                {
                    guiMgr.MakeGuiBackgroundTexture(myGui.backgroundColor);
                }
                myKey = fReader.GetSettingOfKey(path);
                spriteSet = fReader.GetSettingOfSprite(path);
                lookAtSet = fReader.GetSettingOfLookAt(path);
                moveSpeed = fReader.GetSettingOfMoveSpeed(path);
                guiMgr.TransformSlider = fReader.GetSettingOfTransformSlider(path);
                cameraDelta = fReader.GetSettingOfCameraMotionDelta(path);
                maidMotion = fReader.GetSettingOfMaidMotion(path);
                cameraAdjust = fReader.GetSettingOfDanceCameraAdjust(path);
                renderTextureSet = fReader.GetSettingOfRenderTexture(path);

                dressMgr.UndressRandom = fReader.GetSettingOfRandomUndress(path);
                maidMgr.RandomFaceData = fReader.GetSettingOfRandomFace(path);
                lightSetting = new Dictionary<LightType, FreeLightSet>();
                lightSetting[LightType.Spot] = fReader.GetSettingOfSpotLight(path);
                lightSetting[LightType.Point] = fReader.GetSettingOfPointLight(path);

                GetRandomFaceList();
                dressMgr.GetDressGroupList();
                stageMgr.ReadCyalumeData();
                stageMgr.CrowdSet = fReader.GetSettingOfCrowd(path, stageMgr.CrowdSet);

                var f = new FreeForegroundSet[0];
                var m = new Dictionary<int, FreeMaidMaskSet>();
                fReader.GetSettingOfForeground(path, ref f, ref m);
                bgMgr.ForegroundSet = f;
                bgMgr.MaidMaskDic = m;
                danceVolumeLegacy = fReader.GetSettingOfDanceBGMVolue(path);
                isDanceAutoEnd = fReader.GetSettingOfDanceAutoEnd(path);
                guiMgr.DanceSyncSet = fReader.GetSettingOfDanceSync(path);
                extraMgr.EffectSet = fReader.GetSettingOfDanceExtraEnema(path);
                songMgr.SetKupa(fReader.GetSettingOfBodyKupa(path));
            }
            stageMgr.ReadSettingXml();
        }

        #endregion

        #region Other
        private void ClickGearButton(GameObject goButton)
        {
            myGui.isGuiOn = !myGui.isGuiOn;
        }

        private void ReleaseLookAt()
        {
            if (maidLookAt.lookAtIndex != (int)LookAtCameraType.Vertical &&
                    maidLookAt.lookAtIndex != (int)LookAtCameraType.Horizon)
            {
                if (lookAtMgrDiv != null)
                {
                    lookAtMgrDiv.DestroyCamera(0, maidLookAt.divisionSet.Count());
                    lookAtMgrDiv = null;
                }
                maidLookAt.dividedIndex = MyConst.PRE_INDEX;
            }

            if (maidLookAt.lookAtIndex != (int)LookAtCameraType.SubCamera)
            {
                if (lookAtMgrSub != null)
                {
                    lookAtMgrSub.DestroyCamera(0, maidLookAt.subSet.Count());
                    lookAtMgrSub = null;
                }
            }

            if (maidLookAt.lookAtIndex != (int)LookAtCameraType.LockOn)
            {
                if (lookAtMgrLock != null)
                {
                    lookAtMgrLock.DestroyCamera(0, maidLookAt.lockSet.Count());
                    lookAtMgrLock = null;
                }
            }
        }

        /// <summary>
        /// タイムライン初期化
        /// </summary>
        private void InitializeTimeLine(bool isOfficialDance)
        {
            tlPlaySet = new TimeLinePlaySet();
            tlPlaySet.isOfficialDance = isOfficialDance;
            tlPlaySet.isEnabledCamera = true;
            tlPlaySet.isViewAngle = true;
            boneMgr = new TimelineBoneManager(false);
            morphMgr = new TimelineMorphManager(false);
            mCameraMgr = new TimelineCameraManager(false);
        }

        #endregion

    }
    #endregion


    /// <summary>
    /// メイド処理管理
    /// </summary>
    public class MaidManager
    {
        public Dictionary<string, float> DanceFaicalDic { get; set; }
        public Dictionary<int, MaidFacialSet> FaicalDic { get; set; }
        public Dictionary<int, MaidSlotSet> SlotDic { get; set; }
        public MaidRandomFaceSet RandomFaceData { get; set; }
        public MaidAutoKupaSet AutoKupaData { get; set; }
        public Maid.EyeMoveType EyeMoveIndex { get; set; }
        public int GuiMaidIndex { get; set; }
        public bool IsCM3D2Dance { get; set; }
        public bool IsMultipleMaids { get; set; }
       
        private Dictionary<int, int> multipleSlotDic;
        private Dictionary<int, Vector3> fixPositionDic;
        private Dictionary<int, MyTransform> positionDic;
        private Dictionary<int, int> faceListIndex;
        private Dictionary<int, int> anmListIndex;
        private int changeMaidIndex = 0;

        /// <summary>
        /// コンストラクト
        /// </summary>
        public MaidManager(bool dummy)
        {
            FaicalDic = new Dictionary<int, MaidFacialSet>();
            var data = new MaidAutoKupaSet();
            data.maxSize = MyConst.BODY_MAX;
            data.interval = MyConst.BODY_INTERVAL;
            AutoKupaData = data;
            InitializeDanceFacialSet();
        }

        public MaidManager()
        {
        }

        /// <summary>
        /// リストインデックス初期化
        /// </summary>
        public void ResetIndex(List<Maid> maids)
        {
            faceListIndex = new Dictionary<int, int>();
            anmListIndex = new Dictionary<int, int>();
            foreach (var maid in maids)
            {
                var slot = GetActiveSlotNo(maid);
                faceListIndex[slot] = 0;
                anmListIndex[slot] = 0;
            }
            changeMaidIndex = 0;
        }

        /// <summary>
        /// faceリストインデックス有無確判定
        /// </summary
        public bool ExistSlotInFaceList(int slotNo)
        {
            var check = false;
            if (!MyHelper.CheckNull(faceListIndex))
            {
                check = faceListIndex.ContainsKey(slotNo);
            }
            return check;
        }

        /// <summary>
        /// faceリストインデックス更新
        /// </summary
        public void UpdateFaceListIndex(FreeDanceSet data, float bgmTime, int slotNo, Maid maid)
        {
            if (MyHelper.CheckNull(data.face))
            {
                return;
            }
            faceListIndex[slotNo] = 0;
            for (int i = 0; i < faceListIndex.Count(); i++)
            {
                if (bgmTime < data.face[i].time)
                {
                    break;
                }
                faceListIndex[slotNo]++;
            }
            var face = data.face[faceListIndex[slotNo] - 1].face;
            if(maid.ActiveFace != face)
            {
                UpdateFaceAnime(maid, face);
            }
        }

        /// <summary>
        /// アクティブメイド取得（複数メイドプラグイン対応）
        /// </summary>
        public List<Maid> GetActiveMaids()
        {
            try
            {
                List<Maid> maids = GameMain.Instance.CharacterMgr.GetStockMaidList();
                if (!MyHelper.CheckNull(maids))
                {
                    if (IsMultipleMaids)
                    {
                        var targetMaids = maids.FindAll(d => d.body0.isLoadedBody && d.Visible);
                        if (!MyHelper.CheckNull(targetMaids))
                        {
                            var slotNo = 0;
                            if (!MyHelper.CheckNull(multipleSlotDic))
                            {
                                if (targetMaids.Count() < multipleSlotDic.Count())
                                {
                                    MyHelper.ClearDictionary(multipleSlotDic);
                                }
                                else if (multipleSlotDic.Count() < targetMaids.Count())
                                {
                                    slotNo = multipleSlotDic.Count();
                                }
                            }

                            var isInitialize = false;
                            if (MyHelper.CheckNull(multipleSlotDic))
                            {
                                multipleSlotDic = new Dictionary<int, int>();
                                isInitialize = true;
                            }

                            foreach (var maid in targetMaids)
                            {
                                for (int i = 0; i < maids.Count(); i++)
                                {
                                    if (maids[i] == maid)
                                    {

                                        if (isInitialize || !multipleSlotDic.ContainsKey(i))
                                        {
                                            multipleSlotDic[i] = slotNo;
                                            slotNo++;
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                        maids = targetMaids;
                    }
                    else
                    {
                        maids = maids.FindAll(d => d.ActiveSlotNo >= 0 && d.Visible);
                        if (!MyHelper.CheckNull(multipleSlotDic))
                        {
                            MyHelper.ClearDictionary(multipleSlotDic);
                        }
                    }

                    if (!maids.Any())
                    {
                        maids = null;
                    }
                    else if (!MyHelper.CheckNull(maids) &&
                             !MyHelper.CheckNull(SlotDic) && SlotDic.Count() != maids.Count())
                    {
                        ResetMaidSlot(maids);
                    }
                }
                return maids;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// 処理中判定
        /// </summary>
        public bool IsBusyMaid()
        {
            var maids = GetActiveMaids();
            foreach (var maid in maids)
            {
                if (maid.IsBusy)
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// アニメーション状態取得
        /// </summary>
        public AnimationState GetAnimationState(Maid maid)
        {
            Animation anime = maid.GetAnimation();
            if (anime != null)
            {
                foreach (AnimationState state in anime)
                {
                    if (state.enabled)
                    {
                        return state;
                    }
                }
            }
            return null;
        }

        /// <summary>
        /// アニメーション停止
        /// </summary>
        public void StopAnimation(Maid maid)
        {
            maid.body0.m_Bones.GetComponent<Animation>().Stop();
        }

        /// <summary>
        /// まばたき停止
        /// </summary>
        public void SetMabatakiOff(Maid maid)
        {
            maid.boMabataki = false;
            maid.body0.Face.morph.EyeMabataki = 0f;
        }

        /// <summary>
        /// 表示メイド取得(未縮小)
        /// </summary>
        public List<Maid> GetVisibleMaids()
        {
            var maids = GetActiveMaids();
            if (!MyHelper.CheckNull(maids))
            {
                maids = maids.FindAll(m => m.transform.localScale != MyHelper.GetVector3(MyConst.SCALE_INVISIBLE_MAID));
            }
            return maids;
        }

        /// <summary>
        /// ダンス実行
        /// </summary>
        public void CrossFadeDance(Maid maid, string animation)
        {
            CrossFadeAnimation(maid, animation, false, IsCM3D2Dance, MyConst.ANIMATION_NO_FADE_TIME);
        }

        /// <summary>
        /// アニメーション変更
        /// </summary>
        public void CrossFadeAnimation(Maid maid, string animation, bool isLoop, bool isCM3D2D, float val)
        {
            if (isCM3D2D)
            {
                CrossFadeAnimationCM3D2(maid, animation, isLoop, val);
            }
            else if (MyHelper.IsExistingOfficialFile(animation))
            {
                maid.CrossFade(animation, false, isLoop, false, val, 1f);
            }
            else
            {
                Console.WriteLine("アニメーションファイルがありません：" + animation);
            }
        }

        /// <summary>
        /// アニメーション変更
        /// </summary>
        private void CrossFadeAnimationCM3D2(Maid maid, string animation, bool isLoop, float val)
        {
            if (MyHelper.IsExistingOfficialFileOld(animation))
            {
                maid.CrossFade(animation, GameUty.FileSystemOld, false, isLoop, false, val, 1f);
            }
            else
            {
                Console.WriteLine("アニメーションファイルがありません：" + animation);
            }
        }

        /// <summary>
        /// マイポーズ変更（マイポーズ）
        /// </summary>
        public void CrossFadeMyPose(Maid maid, string tag, byte[] poseData, bool isLoop, float val)
        {
            if(0 < poseData.Count())
            {
                maid.body0.CrossFade(tag, poseData, false, isLoop, false, val, 1f);
            }
        }

        /// <summary>
        /// アニメーションリセット
        /// </summary>
        public void ResetAnimation(Maid maid, float fadeTime)
        {
            CrossFadeAnimation(maid, MyConst.DEFAULT_ANIME, true, false, fadeTime);
            SetEyeToCamera(maid, Maid.EyeMoveType.目と顔を向ける);
        }

        /// <summary>
        /// フリーダンスメイド更新
        /// </summary>
        public void UpdateFreeDanceMaid(List<FreeDanceSet> freeDanceData, float bgmTime, bool isFreeStoped, bool isRandomFace, SongManager songMgr,
                                        bool isSyncAnimation, bool isKuchipakuDisabled, bool isMaidVisibledOff, TimeLinePlaySet tlPlaySet)
        {
            var maids = GetActiveMaids();
            if (MyHelper.CheckNull(maids) || MyHelper.CheckNull(freeDanceData))
            {
                return;
            }
            var isIncrement = false;
            foreach (var maid in maids)
            {
                var activeSlotNo = GetActiveSlotNo(maid);
                if (songMgr.IsSong && tlPlaySet.fromFrame != 0)
                {
                    songMgr.SetSongBoneData(maid, activeSlotNo);
                    songMgr.SetSongMorphData(maid, activeSlotNo);
                }

                var danceSlotNo = GetDanceSlotNo(maid);
                var dance = new FreeDanceSet();
                dance.activeSlotNo = MyConst.PRE_INDEX;
                foreach (var data in freeDanceData)
                {
                    if (data.activeSlotNo == danceSlotNo)
                    {
                        dance = data;
                        break;
                    }
                }
                var speed = MyConst.ANIMATION_SPEED;
                if (songMgr.IsSong && dance.activeSlotNo != MyConst.PRE_INDEX)
                {
                    speed = dance.songSet.animationSpeed;
                }

                if (dance.activeSlotNo != MyConst.PRE_INDEX)
                {
                    if (songMgr.IsSong && string.IsNullOrEmpty(dance.animation))
                    {
                        if (!isFreeStoped)
                        {
                            songMgr.CrossFadeSongePose(maid, bgmTime, this, tlPlaySet);
                        }
                    }
                    else if (songMgr.IsSong && dance.songSet.isCustomAnm)
                    {
                        if (!isFreeStoped)
                        {
                            songMgr.ChangeSongBoneData(bgmTime, maid, GetActiveSlotNo(maid), tlPlaySet);
                        }
                    }
                    else
                    {
                        var maidSlotNo = GetActiveSlotNo(maid);
                        if (anmListIndex.ContainsKey(maidSlotNo) && !MyHelper.CheckNull(dance.animationList))
                        {
                            ChangeListAnimation(dance, bgmTime, maid, maidSlotNo, isFreeStoped);
                        }
                        else if (!isFreeStoped && isSyncAnimation)
                        {
                            SyncAnimationTime(maid, bgmTime);
                        }
                    }

                    if (isRandomFace && !MyHelper.CheckNull(RandomFaceData.morphData))
                    {
                        UpdateRandomFace(maid);
                    }
                    else if (!MyHelper.CheckNull(dance.face))
                    {
                        UpdateFace(dance, bgmTime, maid, isFreeStoped, MyConst.FACE_FADE_TIME / speed);
                    }
                    else if (songMgr.IsSong && !string.IsNullOrEmpty(dance.songSet.morph))
                    {
                        songMgr.ChangeSongMorphData(bgmTime, maid, activeSlotNo, tlPlaySet);
                    }

                    if (!isMaidVisibledOff)
                    {
                        isIncrement = ChangeDanceMaid(dance, bgmTime, maid, danceSlotNo, isFreeStoped);
                    }
                }

                if (!isKuchipakuDisabled)
                {
                    if (songMgr.IsSong)
                    {
                        if (!isFreeStoped)
                        {
                            songMgr.PlaySongKuchipaku(maid, bgmTime, GetActiveSlotNo(maid));
                        }
                    }
                    if (!string.IsNullOrEmpty(dance.mouth))
                    {
                        maid.FoceKuchipakuUpdate(bgmTime * speed);
                    }
                }
                else
                {
                    maid.FoceKuchipakuUpdate(0f);
                }
            }
            if (isIncrement)
            {
                changeMaidIndex++;
            }
        }

        /// <summary>
        /// アクティブスロット番号取得（複数メイドプラグイン対応）
        /// </summary>
        public int GetActiveSlotNo(Maid maid)
        {
            var activeSlotNo = maid.ActiveSlotNo;
            if (IsMultipleMaids)
            {
                List<Maid> maids = GameMain.Instance.CharacterMgr.GetStockMaidList();
                if (!MyHelper.CheckNull(maids))
                {
                    for (int i = 0; i < maids.Count(); i++)
                    {
                        if (maids[i] == maid)
                        {
                            if (!MyHelper.CheckNull(multipleSlotDic))
                            {
                                if (multipleSlotDic.ContainsKey(i))
                                {
                                    activeSlotNo = multipleSlotDic[i];
                                }
                            }
                            break;
                        }
                    }
                }
            }
            return activeSlotNo;
        }

        /// <summary>
        /// ダンススロット取得
        /// </summary>
        public int GetDanceSlotNo(Maid maid)
        {
            return GetSlotNo(maid, true);
        }

        /// <summary>
        /// カスタムスロット取得
        /// </summary>
        public int GetCustomSlotNo(Maid maid)
        {
            return GetSlotNo(maid, false);
        }

        private int GetSlotNo(Maid maid, bool isDance)
        {
            var slotNo = GetActiveSlotNo(maid);
            if (!MyHelper.CheckNull(SlotDic))
            {
                if (SlotDic.ContainsKey(slotNo))
                {
                    slotNo = isDance ? SlotDic[slotNo].danceSlotNo : SlotDic[slotNo].coustomeSlotNo;
                }
            }
            return slotNo;
        }

        /// <summary>
        /// 自動ダンススロット設定
        /// </summary>
        public void SetAoutDanceSlot(List<FreeDanceSet> freeDanceData)
        {
            var list = SlotDic.Values.ToList().OrderBy(d => d.coustomeSlotNo);
            var count = freeDanceData.Count();
            var index = 0;
            foreach (var l in list)
            {
                var data = SlotDic[l.activeSlotNo];
                data.danceSlotNo = freeDanceData[index].activeSlotNo;
                SlotDic[l.activeSlotNo] = data;
                index++;
                if (count <= index)
                {
                    index = 0;
                }
            }
        }

        /// <summary>
        /// ダンススロットシャッフル
        /// </summary>
        public void ShuffleMaidSlot(List<Maid> maids)
        {
            SlotDic = new Dictionary<int, MaidSlotSet>();
            var coustomeSlotNo = Enumerable.Range(0, maids.Count()).ToList();
            foreach (var maid in maids)
            {
                var index = MyHelper.GetRandomIndex(coustomeSlotNo.Count());
                var activeSlotNo = GetActiveSlotNo(maid);
                var data = new MaidSlotSet();
                data.activeSlotNo = activeSlotNo;
                data.coustomeSlotNo = coustomeSlotNo[index];
                data.danceSlotNo = coustomeSlotNo[index];
                SlotDic[activeSlotNo] = data;
                coustomeSlotNo.RemoveAt(index);
            }
        }

        /// <summary>
        /// メイドカスタムスロット調整
        /// </summary>
        public void AdjustMaidSlot()
        {
            var list = SlotDic.Values.ToList().OrderBy(d => d.coustomeSlotNo);
            var coustomeSlotNo = 0;
            foreach (var l in list)
            {
                var data = SlotDic[l.activeSlotNo];
                data.coustomeSlotNo = coustomeSlotNo;
                data.danceSlotNo = coustomeSlotNo;
                SlotDic[l.activeSlotNo] = data;
                coustomeSlotNo++;
            }
        }

        /// <summary>
        /// メイドスロットリセット
        /// </summary>
        public void ResetMaidSlot(List<Maid> maids)
        {
            SlotDic = new Dictionary<int, MaidSlotSet>();
            var ms = maids.OrderBy(m => GetActiveSlotNo(m));
            var coustomeSlotNo = 0;
            foreach (var maid in ms)
            {
                var data = new MaidSlotSet();
                data.activeSlotNo = GetActiveSlotNo(maid);
                data.coustomeSlotNo = coustomeSlotNo;
                data.danceSlotNo = coustomeSlotNo;
                SlotDic[data.activeSlotNo] = data;
                coustomeSlotNo++;
            }
        }

        /// <summary>
        /// メイドスロット設定
        /// </summary>
        public MaidSlotSet SetMaidSlot(int activeSlotNo, int coustomeSlotNo)
        {
            var data = new MaidSlotSet();
            data.activeSlotNo = activeSlotNo;
            data.coustomeSlotNo = coustomeSlotNo;
            data.danceSlotNo = coustomeSlotNo;
            return data;
        }

        /// <summary>
        /// ランダム表情初期設定
        /// </summary>
        public void SetStartRandomFace(List<Maid> maids, string label, bool isKuchipakuDisabled)
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_RANDOM_FACE, "");
            if (!string.IsNullOrEmpty(path))
            {
                var data = RandomFaceData;
                var names = fReader.ReadMaidRandomFaceData(path, label);
                path = fReader.GetFilePath(MyConst.FILE_MAID_CUSTOM_FACE, "");
                if (!string.IsNullOrEmpty(path))
                {
                    data.morphData = new List<Dictionary<string, float>>();
                    foreach(var name in names)
                    {
                        var morph = fReader.ReadMaidCustomFaceData(path, name);
                        if (!isKuchipakuDisabled)
                        {
                            foreach (var key in MyConst.MOUTH_MORPH.Keys)
                            {
                                morph.Remove(key);
                            }
                        }
                        data.morphData.Add(morph);
                    }
                }
                data.eachDic = new Dictionary<int, MaidRandomFaceEachSet>();
                RandomFaceData = data;
            }
            foreach (var maid in maids)
            {
                UpdateFaceAnime(maid, MyConst.DANCE_FACE_EYE_CLOSE);
            }
        }

        /// <summary>
        /// カスタム表情取得
        /// </summary>
        public void GetCustomFace(Maid maid, string label)
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_CUSTOM_FACE, "");
            if (!string.IsNullOrEmpty(path))
            {
                var slotNo = GetActiveSlotNo(maid);
                InitializeFacialSet(slotNo);
                var set = FaicalDic[slotNo];
                set.facialMorphDic = fReader.ReadMaidCustomFaceData(path, label);
                FaicalDic[slotNo] = set;
            }
        }

        /// <summary>
        /// 表情値取得
        /// </summary>
        public float GetMorphValue(Maid maid, string key)
        {
            var morph = maid.body0.Face.morph;
            var morphName = CheckMorph(morph, key);
            if (!string.IsNullOrEmpty(morphName))
            {
                var ratio = GetRatio(morph, key);
                return morph.GetBlendValues((int)morph.hash[morphName]) / ratio;
            }
            return 0f;
        }

        /// <summary>
        /// 表情変化設定(LateUpdateから呼び出さないと反映されない)
        /// </summary>
        public void SetMorphValue(Maid maid, Dictionary<string, float> dicMorph)
        {
            if (MyHelper.CheckNull(dicMorph)) return;
            var morph = maid.body0.Face.morph;
            foreach (var key in dicMorph.Keys)
            {
                SetBlendValues(morph, key, dicMorph[key]);
            }
            AdjustClosedEye(maid, morph);
            morph.FixBlendValues_Face();
        }

        /// <summary>
        /// 表情値設定
        /// </summary>
        private void SetBlendValues(TMorph morph, string key, float value)
        {
            var morphName = CheckMorph(morph, key);
            if (!string.IsNullOrEmpty(morphName))
            {
                value *= GetRatio(morph, key);
                morph.SetBlendValues((int)morph.hash[morphName], value);
            }
        }

        /// <summary>
        /// 目閉じ値調整
        /// </summary>
        private void AdjustClosedEye(Maid maid, TMorph morph)
        {
            var isChanged = false;
            var close = GetMorhpValue(maid, morph, MyConst.FACE_EYE_CLOSE);
            var smile = GetMorhpValue(maid, morph, MyConst.FACE_EYE_SMILE);
            var close5 = GetMorhpValue(maid, morph, MyConst.FACE_EYE_CLOSE_5);
            var close6 = GetMorhpValue(maid, morph, MyConst.FACE_EYE_CLOSE_6);
            var close7 = GetMorhpValue(maid, morph, MyConst.FACE_EYE_CLOSE_7);
            var close8 = GetMorhpValue(maid, morph, MyConst.FACE_EYE_CLOSE_8);

            if (1 < close5 + close6)
            {
                if (close5 < close6)
                {
                    close5 = GetLimitValue(close6);
                }
                else
                {
                    close6 = GetLimitValue(close5);
                }
                isChanged = true;
            }

            if (1 < close7 + close8)
            {
                if (close7 < close8)
                {
                    close7 = GetLimitValue(close8);
                }
                else
                {
                    close8 = GetLimitValue(close7);
                }
                isChanged = true;
            }
            var closeLR = close5 + close6 < close7 + close8 ? close7 + close8 : close5 + close6;

            if (1 < close + smile + closeLR)
            {
                var sum = close + smile;
                closeLR = 1 - closeLR;
                close = closeLR * close / sum;
                smile = closeLR * smile / sum;
                isChanged = true;
            }

            if (isChanged)
            {
                SetBlendValues(morph, MyConst.FACE_EYE_CLOSE, close);
                SetBlendValues(morph, MyConst.FACE_EYE_SMILE, smile);
                SetBlendValues(morph, MyConst.FACE_EYE_CLOSE_5, close5);
                SetBlendValues(morph, MyConst.FACE_EYE_CLOSE_6, close6);
                SetBlendValues(morph, MyConst.FACE_EYE_CLOSE_7, close7);
                SetBlendValues(morph, MyConst.FACE_EYE_CLOSE_8, close8);
            }
        }

        /// <summary>
        /// 表情値取得
        /// </summary>
        private float GetMorhpValue(Maid maid, TMorph morph, string key)
        {
            var morphName = CheckMorph(morph, MyConst.FACE_EYE_CLOSE_5);
            if (!string.IsNullOrEmpty(morphName))
            {
                return GetMorphValue(maid, key) * GetRatio(morph, key);
            }
            return 0f;
        }

        /// <summary>
        /// 上限値取得
        /// </summary>
        private float GetLimitValue(float value)
        {
            value = 1 - value;
            value = value < 0f ? 0f : value;
            return value;
        }

        /// <summary>
        /// フェイス設定有無判定
        /// </summary>
        private string CheckMorph(TMorph morph, string morphName)
        {
            if (!morph.hash.ContainsKey(morphName))
            {
                if (IsFBFace(morph))
                {
                    morphName = CheckMorphFB(morph, morphName);
                }
                else
                {
                    morphName = "";
                }
            }
            return morphName;
        }

        /// <summary>
        /// フェイス設定有無判定（FBフェイス）
        /// </summary>
        private string CheckMorphFB(TMorph morph, string morphName)
        {
            var index = (int)morph.GetFaceTypeGP01FB();
            index = Mathf.Min(index, 2);
            if (morphName == MyConst.FACE_EYE_CLOSE)
            {
                morphName = MyConst.FACE_EYE_CLOSE_FB;
            }
            morphName += TMorph.crcFaceTypesStr[index];
            if (!morph.hash.ContainsKey(morphName))
            {
                morphName = "";
            }
            return morphName;
        }

        /// <summary>
        /// FBフェイス判定
        /// </summary>
        private bool IsFBFace(TMorph morph)
        {
            return MyConst.FB_FACE_VERSION <= morph.bodyskin.PartsVersion;
        }

        /// <summary>
        /// スライダー調整値取得
        /// </summary>
        private float GetRatio(TMorph morph, string key)
        {
            return IsFBFace(morph) && key == MyConst.FACE_EYE_CLOSE_3 ? 3f : 1f;
        }

        /// <summary>
        /// 表情セット初期化
        /// </summary>
        public void InitializeFacialSet(int maidSlotNo)
        {
            if (!FaicalDic.ContainsKey(maidSlotNo))
            {
                MaidFacialSet set;
                set.bodyMorphDic = new Dictionary<string, float>();
                foreach (var key in MyConst.BODY_MORPH.Keys)
                {
                    set.bodyMorphDic[key] = 0f;
                }
                set.facialMorphDic = new Dictionary<string, float>();
                foreach (var key in MyConst.FACE_MORPH.Keys)
                {
                    set.facialMorphDic[key] = 0f;
                }
                foreach (var key in MyConst.FACE_OPTION_MORPH.Keys)
                {
                    set.facialMorphDic[key] = 0f;
                }
                foreach (var key in MyConst.MOUTH_MORPH.Keys)
                {
                    set.facialMorphDic[key] = 0f;
                }
                FaicalDic[maidSlotNo] = set;
            }
        }

        /// <summary>
        /// 表情セット現在値設定(COM3D2)
        /// </summary>
        public void SetCurrentFacialValue(Maid maid)
        {
            var morph = maid.body0.Face.morph;
            MaidFacialSet set;
            set.bodyMorphDic = new Dictionary<string, float>();
            foreach (var key in MyConst.BODY_MORPH.Keys)
            {
                set.bodyMorphDic[key] = 0f;
            }
            set.facialMorphDic = new Dictionary<string, float>();
            foreach (var key in MyConst.FACE_MORPH.Keys)
            {
                set.facialMorphDic[key] = morph.GetBlendValues((int)morph.hash[key]);
            }
            foreach (var key in MyConst.FACE_OPTION_MORPH.Keys)
            {
                set.facialMorphDic[key] = morph.GetBlendValues((int)morph.hash[key]);
            }
            foreach (var key in MyConst.MOUTH_MORPH.Keys)
            {
                set.facialMorphDic[key] = morph.GetBlendValues((int)morph.hash[key]);
            }
            FaicalDic[GetActiveSlotNo(maid)] = set;
        }

        /// <summary>
        /// ダンス表情セット初期化(COM3D2)
        /// </summary>
        public void InitializeDanceFacialSet()
        {
            DanceFaicalDic = new Dictionary<string, float>();
            foreach (var key in MyConst.FACE_OPTION_MORPH.Keys)
            {
                DanceFaicalDic[key] = 0f;
            }
        }

        /// <summary>
        /// 表情セットコピー(COM3D2)
        /// </summary>
        public void CopyFacialSet(int maidIndex)
        {
            var maids = GetActiveMaids();
            var maidSlotNo = GetActiveSlotNo(maids[maidIndex]);
            if (FaicalDic.ContainsKey(maidSlotNo))
            {
                var set = FaicalDic[maidSlotNo];
                foreach (var maid in maids)
                {
                    maidSlotNo = GetActiveSlotNo(maid);
                    FaicalDic[maidSlotNo] = set;
                }
            }
        }

        /// <summary>
        /// 公式表情更新
        /// </summary>
        public void UpdateFaceAnime(Maid maid, string face)
        {
            UpdateFaceAnime(maid, face, MyConst.FACE_FADE_TIME);
        }

        public void UpdateFaceAnime(Maid maid, string face, float fadeTime)
        {
            maid.FaceAnime(face, fadeTime, 0);
        }

        /// <summary>
        /// メイドアニメーション更新
        /// </summary>
        public void UpdateAnimationListIndex(FreeDanceSet data, float bgmTime, int slotNo, Maid maid)
        {
            if (!anmListIndex.ContainsKey(slotNo) || MyHelper.CheckNull(data.animationList))
            {
                return;
            }
            anmListIndex[slotNo] = 0;
            for (int i = 0; i < anmListIndex.Count(); i++)
            {
                if (bgmTime < data.animationList[i].time)
                {
                    break;
                }
                anmListIndex[slotNo]++;
            }
            var state = GetAnimationState(maid);
            if (state != null)
            {
                var index = anmListIndex[slotNo] - 1;
                if (state.name != data.animationList[index].animation)
                {
                    CrossFadeAnimation(maid, data.animationList[index].animation, true, IsCM3D2Dance, MyConst.ANIMATION_FADE_TIME);
                }
            }
        }

        /// <summary>
        /// メイドアニメーションリスト変更
        /// </summary>
        private void ChangeListAnimation(FreeDanceSet data, float bgmTime, Maid maid, int slotNo, bool isFreeStoped)
        {
            var index = anmListIndex[slotNo];
            if (index < data.animationList.Count())
            {
                if (data.animationList[index].time <= bgmTime)
                {
                    var isChange = false;
                    if (data.animationList.Count() - 1 == index)
                    {
                        isChange = true;
                    }
                    else if (index < data.animationList.Count() && bgmTime < data.animationList[index + 1].time)
                    {
                        isChange = true;
                    }
                    if (isChange)
                    {
                        CrossFadeAnimation(maid, data.animationList[index].animation, true, IsCM3D2Dance, MyConst.ANIMATION_NO_FADE_TIME);
                        //maid.StartKuchipakuPattern(0f, data.mouth, true);
                    }
                    anmListIndex[slotNo]++;
                }
                else if (!isFreeStoped)
                {
                    index--;
                    var state = GetAnimationState(maid);
                    if (state != null)
                    {
                        if (state != null && data.animationList[index].time < bgmTime)
                        {
                            bgmTime -= data.animationList[index].time;
                            if (MyConst.ANIMATION_DELTA_TIME <= Mathf.Abs(bgmTime - state.time))
                            {
                                SyncAnimationTime(maid, bgmTime);
                            }
                        }
                    }
                }
            }

        }

        /// <summary>
        /// メイド表情更新
        /// </summary>
        private void UpdateFace(FreeDanceSet data, float bgmTime, Maid maid, bool isFreeStoped, float fadeTime)
        {
            var slotNo = GetActiveSlotNo(maid);
            if (ExistSlotInFaceList(slotNo) && !MyHelper.CheckNull(data.face))
            {
                var index = faceListIndex[slotNo];
                if (index < data.face.Count())
                {
                    if (data.face[index].time <= bgmTime)
                    {
                        var isChange = false;
                        if (data.face.Count() - 1 == index)
                        {
                            isChange = true;
                        }
                        else if (bgmTime < data.face[index + 1].time)
                        {
                            isChange = true;
                        }

                        if (isChange && !isFreeStoped)
                        {
                            UpdateFaceAnime(maid, data.face[index].face, fadeTime);
                            SetMorphValue(maid, data.face[index].faceOpMorph);
                            if(data.face[index].eyeMoveType != (Maid.EyeMoveType)MyConst.PRE_INDEX)
                            {
                                SetEyeToCamera(maid, data.face[index].eyeMoveType);
                            }
                        }
                        faceListIndex[slotNo]++;
                    }
                    else
                    {
                        index -= (index == 0) ? 0 : 1;
                        SetMorphValue(maid, data.face[index].faceOpMorph);
                    }
                }
                else
                {
                    if (!maid.boFaceAnime)
                    {
                        index -= (index == 0) ? 0 : 1;
                        UpdateFaceAnime(maid, data.face[index].face, fadeTime);
                    }
                    SetMorphValue(maid, data.face[data.face.Count() - 1].faceOpMorph);
                }
            }
        }

        /// <summary>
        /// メイド表情ランダム更新
        /// </summary>
        private void UpdateRandomFace(Maid maid)
        {
            var slotNo = GetActiveSlotNo(maid);
            var data = new MaidRandomFaceEachSet();
            var morph = new Dictionary<string, float>();

            if (RandomFaceData.eachDic.ContainsKey(slotNo))
            {
                data = RandomFaceData.eachDic[slotNo];
                morph = RandomFaceData.morphData[data.morphIndex];
            }
            else
            {
                data.morphIndex = MyConst.PRE_INDEX;
            }
            if (data.morphIndex == MyConst.PRE_INDEX ||
                (RandomFaceData.maxTime <= data.deltaTime ||
                 RandomFaceData.minTime <= data.deltaTime &&
                 MyHelper.GetRandomFloat(0f, RandomFaceData.maxTime * MyConst.FACE_FRAME) == 0f))
            {
                data.preMorphIndex = data.morphIndex;
                data.deltaTime = 0f;
                data.fadeTime = 0f;
                if(data.morphIndex == MyConst.PRE_INDEX)
                {
                    data.fadeTime = RandomFaceData.fadeTime;
                }
                while (true)
                {
                    var index = MyHelper.GetRandomIndex(RandomFaceData.morphData.Count());
                    if (data.morphIndex != index)
                    {
                        data.morphIndex = index;
                        break;
                    }
                }
            }
            else if (data.fadeTime < RandomFaceData.fadeTime)
            {
                data.fadeTime += Time.deltaTime;
                var m = new Dictionary<string, float>();
                foreach (var pair in morph)
                {
                    var preValue = RandomFaceData.morphData[data.preMorphIndex][pair.Key];
                    var fadeTime = data.fadeTime;
                    if (MyConst.FACE_OPTION_MORPH.ContainsKey(pair.Key))
                    {
                        if (fadeTime < RandomFaceData.fadeTime)
                        {
                            fadeTime = 0f;
                        }
                    }
                    m[pair.Key] = Mathf.Lerp(preValue, pair.Value, Mathf.Clamp01(fadeTime / RandomFaceData.fadeTime));
                }
                morph = m;
            }
            else
            {
                data.deltaTime += Time.deltaTime;
            }
            SetMorphValue(maid, morph);
            RandomFaceData.eachDic[slotNo] = data;
        }

        /// <summary>
        /// メイド変更
        /// </summary>
        public bool ChangeDanceMaid(FreeDanceSet data, float bgmTime, Maid maid, int slotNo, bool isFreeStoped)
        {
            var isIncrement = false;
            if (!MyHelper.CheckNull(data.changeMaid))
            {
                if (data.changeMaid.Count() > changeMaidIndex)
                {
                    if (bgmTime >= data.changeMaid[changeMaidIndex].time)
                    {
                        if (!isFreeStoped)
                        {
                            if (data.changeMaid[changeMaidIndex].visible.Count(n => n == slotNo) > 0)
                            {
                                var time = bgmTime;
                                var animation = data.animation;
                                if (!MyHelper.CheckNull(data.animationList))
                                {
                                    var index = anmListIndex[slotNo];
                                    if (index > 0)
                                    {
                                        time -= data.animationList[index - 1].time;
                                        animation = data.animationList[index - 1].animation;
                                        CrossFadeDance(maid, animation);
                                        SetAnimationTime(maid, time, isFreeStoped);
                                    }
                                }
                                if (maid.transform.localScale == MyHelper.GetVector3(MyConst.SCALE_INVISIBLE_MAID))
                                {
                                    maid.transform.localScale = MyHelper.GetVector3(MyConst.SCALE_DEFAULT);
                                }
                            }
                            else if (data.changeMaid[changeMaidIndex].inVisible.Count(n => n == slotNo) > 0)
                            {
                                if (maid.transform.localScale != MyHelper.GetVector3(MyConst.SCALE_INVISIBLE_MAID))
                                {
                                    maid.transform.localScale = MyHelper.GetVector3(MyConst.SCALE_INVISIBLE_MAID);
                                }
                            }
                        }
                        isIncrement = true;
                    }
                }
            }
            return isIncrement;
        }

        /// <summary>
        /// メイド位置設定
        /// </summary>
        public void SetMaidPosition(List<Maid> maids, MaidTransformSet maidPositionData)
        {
            foreach (var maid in maids)
            {
                var slotNo = GetCustomSlotNo(maid);
                if (slotNo < maidPositionData.transform.Count())
                {
                    var data = maidPositionData.transform[slotNo];
                    maid.SetPos(data.stPos);
                    maid.SetRot(data.stRot);
                }
            }
        }

        /// <summary>
        /// ダンス開始前待機位置保持
        /// </summary>
        public void StockWaitPosition(List<Maid> maids)
        {
            positionDic = new Dictionary<int, MyTransform>();
            fixPositionDic = new Dictionary<int, Vector3>();
            foreach (var maid in maids)
            {
                var slotNo = GetActiveSlotNo(maid);
                var t6 = new MyTransform();
                t6.edPos = maid.transform.position;
                t6.edRot = maid.transform.eulerAngles;
                positionDic[slotNo] = t6;
            }
        }

        /// <summary>
        /// ダンス開始位置保持
        /// </summary>
        public void StockDancePositiona(List<Maid> maids)
        {
            foreach (var maid in maids)
            {
                var slotNo = GetActiveSlotNo(maid);
                var t6 = positionDic[slotNo];
                t6.stPos = maid.transform.position;
                t6.stRot = maid.transform.eulerAngles;
                positionDic[slotNo] = t6;

                var pos = maid.body0.Pelvis.position;
                fixPositionDic[slotNo] = new Vector3(pos.x, 0f, pos.z);
            }
        }

        /// <summary>
        /// ダンス位置固定設定
        /// </summary>
        public void FixDancePosition()
        {
            var maids = GetActiveMaids();
            if (!MyHelper.CheckNull(maids))
            {
                foreach (var maid in maids)
                {
                    var pos = maid.body0.Pelvis.position;
                    pos = maid.transform.position + fixPositionDic[GetActiveSlotNo(maid)] - new Vector3(pos.x, 0f, pos.z);
                    maid.SetPos(pos);
                }
            }
        }

        /// <summary>
        /// ソング位置設定
        /// </summary>
        public void SetSongPosition(Maid maid, Vector3 position, Vector3 rotation)
        {
            var slotNo = GetActiveSlotNo(maid);
            maid.SetPos(positionDic[slotNo].stPos + position);
            maid.SetRot(positionDic[slotNo].stRot + rotation);
        }

        /// <summary>
        /// ダンス開始前待機位置復帰
        /// </summary
        public void SetWaitPosition(Maid maid)
        {
            var slotNo = GetActiveSlotNo(maid);
            maid.SetPos(positionDic[slotNo].edPos);
            maid.SetRot(positionDic[slotNo].edRot);
        }

        /// <summary>
        /// 保持ダンス位置取得
        /// </summary
        public Vector3 GetStockDancePosition(Maid maid)
        {
            var slotNo = GetActiveSlotNo(maid);
            return positionDic[slotNo].stPos;
        }

        /// <summary>
        /// 保持ダンス回転取得
        /// </summary
        public Vector3 GetStockDanceRotation(Maid maid)
        {
            var slotNo = GetActiveSlotNo(maid);
            return positionDic[slotNo].stRot;
        }

        /// <summary>
        /// アニメーションタイム設定
        /// </summary>
        public float SetAnimationTime(Maid maid, float bgmTime, bool isStoped)
        {
            return SetAnimationTime(maid, bgmTime, isStoped, MyConst.ANIMATION_SPEED);
        }

        public float SetAnimationTime(Maid maid, float bgmTime, bool isStoped, float speed)
        {
            var state = GetAnimationState(maid);
            if (state != null)
            {
                var length = state.length - MyConst.DANCE_END_MARGIN;
                state.speed = isStoped ? 0f : speed;
                speed = isStoped ? MyConst.ANIMATION_SPEED : speed;
                state.time = Mathf.Clamp(bgmTime * speed, 0f, length);
                bgmTime = length < bgmTime ? length : bgmTime;
            }
            return bgmTime;
        }


        /// <summary>
        /// アニメーションタイム同期
        /// </summary>
        public float SyncAnimationTime(Maid maid, float bgmTime)
        {
            var state = GetAnimationState(maid);
            if (state != null)
            {
                var length = state.length - MyConst.DANCE_END_MARGIN;
                state.time = Mathf.Clamp(bgmTime * state.speed, 0f, length);
                bgmTime = length < bgmTime ? length : bgmTime;
            }
            return bgmTime;
        }

        /// <summary>
        /// アニメーションクリップ削除
        /// </summary>
        public void RemoveAnimationClip(Maid maid)
        {
            Animation anime = maid.GetAnimation();
            if (anime != null)
            {
                foreach (AnimationState state in anime)
                {
                    if (!state.enabled)
                    {
                        anime.RemoveClip(state.name);
                    }
                }
            }
        }

        /// <summary>
        /// 目線設定
        /// </summary>
        public void SetEyeToCamera(Maid maid, Maid.EyeMoveType type)
        {
            SetEyeToCamera(maid, type, MyConst.FACE_FADE_TIME);
        }

        public void SetEyeToCamera(Maid maid, Maid.EyeMoveType type, float fadeTime)
        {
            maid.EyeToCamera(type, fadeTime);
        }

        /// <summary>
        /// ダンスメイドアイテム設定
        /// </summary>
        public List<DanceItemSet> ChangeDanceMaidItem(List<DanceItemSet> itemData, float bgmTime)
        {
            var maids = GetActiveMaids();
            if (!MyHelper.CheckNull(maids))
            {
                for (int i = 0; i < itemData.Count(); i++)
                {
                    var data = itemData[i];
                    var ms = maids.FindAll(m => GetDanceSlotNo(m) == data.activeSlotNo);
                    if (!MyHelper.CheckNull(ms))
                    {
                        var isSet = false;
                        foreach (var maid in ms)
                        {
                            isSet = data.isSet;
                            if (data.edTime <= bgmTime && isSet)
                            {
                                isSet = false;
                            }
                            else if (data.stTime <= bgmTime && bgmTime < data.edTime && !isSet)
                            {
                                maid.SetProp(data.tag, data.menu, 0, true, false);
                                maid.AllProcPropSeqStart();
                                isSet = true;
                            }

                            if (data.tag.ToLower() == MyConst.ITEM_HAND && isSet != data.isSet)
                            {
                                maid.body0.SetMask(TBody.SlotID.HandItemL, isSet);
                                maid.body0.SetMask(TBody.SlotID.HandItemR, isSet);
                            }

                            if (!data.option.ToLower().Contains(MyConst.OBJECT_OPTION_ALL_MAIDS))
                            {
                                break;
                            }
                        }
                        data.isSet = isSet;
                        itemData[i] = data;
                    }
                }
            }
            return itemData;
        }

        /// <summary>
        /// ダンスメイドPrefab設定
        /// </summary>
        public List<DanceMaidPrefabSet> ChangeFreeDanceMaidPrefab(float bgmTime, List<DanceMaidPrefabSet> prefabData)
        {
            var maids = GetActiveMaids();
            if (!MyHelper.CheckNull(maids))
            {
                List<string> keys = new List<string>();
                foreach (var maid in maids)
                {
                    var dt = prefabData.FindAll(d => d.maidSlotNo == GetDanceSlotNo(maid));
                    foreach (var d in dt)
                    {
                        if (d.stTime <= bgmTime && bgmTime < d.edTime)
                        {
                            keys.Add(d.name + d.group);
                        }
                    }
                }

                for (int i = 0; i < prefabData.Count(); i++)
                {
                    var data = prefabData[i];
                    var ms = maids.FindAll(m => GetDanceSlotNo(m) == data.maidSlotNo);
                    if (!MyHelper.CheckNull(ms))
                    {
                        var isAdded = false;
                        foreach (var maid in ms)
                        {
                            isAdded = data.isAdded;
                            var key = data.name + data.group;
                            if (data.stTime <= bgmTime && bgmTime < data.edTime)
                            {
                                if (!isAdded)
                                {
                                    maid.AddPrefab(data.name, key, data.maidBone, data.transform.stPos, data.transform.stRot);
                                    isAdded = true;
                                }
                            }
                            else if (bgmTime < data.stTime)
                            {
                                isAdded = false;
                            }
                            else if (isAdded && !keys.Contains(key))
                            {
                                maid.DelPrefab(key);
                                isAdded = false;
                            }

                            if (!data.option.ToLower().Contains(MyConst.OBJECT_OPTION_ALL_MAIDS))
                            {
                                break;
                            }
                        }
                        data.isAdded = isAdded;
                        prefabData[i] = data;
                    }
                }
            }
            return prefabData;
        }

        /// <summary>
        /// メイド部位座標取得
        /// </summary
        public Transform GetMiadPatrsTrancform(Maid maid, int index)
        {
            Transform tm = null;
            switch (index)
            {
                case (int)MaidPointType.Head:
                    tm = maid.body0.trsHead;
                    break;
                case (int)MaidPointType.Chest:
                    tm = maid.body0.Spine1a;
                    break;
                case (int)MaidPointType.Crotch:
                    tm = maid.body0.Pelvis;
                    break;
                case (int)MaidPointType.Hip:
                    tm = maid.body0.Hip_R;
                    break;
            }
            return tm;
        }

        /// <summary>
        /// メイド部位位置取得
        /// </summary
        public Vector3 GetMiadPatrsPotision(Maid maid, int index)
        {
            Vector3 vec = Vector3.zero;
            switch (index)
            {
                case (int)MaidPointType.Head:
                    vec = maid.body0.trsHead.position;
                    break;
                case (int)MaidPointType.Chest:
                    vec = maid.body0.Spine1a.position;
                    break;
                case (int)MaidPointType.Crotch:
                    vec = maid.body0.Pelvis.position;
                    break;
                case (int)MaidPointType.Hip:
                    vec = maid.body0.Hip_R.position;
                    break;
                case (int)MaidPointType.Bip:
                    vec = maid.body0.trBip.position;
                    vec = new Vector3(vec.x, 0f, vec.z);
                    break;
            }
            return vec;
        }

        /// <summary>
        /// ボディ変更
        /// </summary
        public void ChangeBodyMenu(string bodyMenu)
        {
            if (MyHelper.IsExistingOfficialFile(bodyMenu) || MyHelper.IsExistingModFile(bodyMenu))
            {
                var mgr = GameMain.Instance.CharacterMgr;
                var cnt = GameMain.Instance.CharacterMgr.GetStockMaidList().Count();
                for (int i = 0; i < cnt; i++)
                {
                    var maid = mgr.Activate(CharacterMgr.ActiveMaidSlotCount - 1, i, false, false);
                    maid.SetProp(MPN.body, bodyMenu, 0, false, false);
                    mgr.DeactivateMaid(maid);
                }
                Console.WriteLine("ボディ変更完了");
            }
            else
            {
                Console.WriteLine(string.Format("メニューファイルがありません：{0}", bodyMenu));
            }
        }

        /// <summary>
        /// くぱ設定
        /// </summary>
        public void SetBodyKupa(List<Maid> maids, int slotNo, string tag, float val, bool isMaidAppearanceAll)
        {
            if (isMaidAppearanceAll)
            {
                foreach (var maid in maids)
                {
                    SetVertexMorphFromProcItem(maid, tag, val);
                }
            }
            else
            {
                SetVertexMorphFromProcItem(maids[GuiMaidIndex], tag, val);
            }
            FaicalDic[slotNo].bodyMorphDic[tag] = val;
        }

        /// <summary>
        /// くぱ設定
        /// </summary>
        public void SetVertexMorphFromProcItem(Maid maid, string tag, float val)
        {
            var hara = MyConst.BODY_MORPH.Keys.ToList()[0];
            if (tag == hara || maid.body0.goSlot[0].morph.hash.ContainsKey(tag))
            {
                maid.body0.VertexMorph_FromProcItem(tag.ToLower(), val / 100);
            }
        }

        /// <summary>
        /// メイド名取得
        /// </summary>
        public string GetMaidFullName(Maid maid)
        {
            return maid.status.lastName + " " + maid.status.firstName;
        }

        /// <summary>
        /// メイド情報コンソール出力
        /// </summary>
        public void WriteMaidInfomationToConsole(string backGroundName)
        {
            Console.WriteLine("背景名　　　　　：" + backGroundName);
            Console.WriteLine("ミュージック名　：" + new SoundManager().GetClipName());
            var maids = GetActiveMaids();
            if (!MyHelper.CheckNull(maids))
            {
                foreach (var maid in maids)
                {
                    Console.WriteLine("メイド名　　　　：" + GetMaidFullName(maid));
                    Console.WriteLine("性格　　　　　　：" + GetMaidPersonal(maid));
                    Console.WriteLine("表情　　　　　　：" + maid.ActiveFace);
                    Console.WriteLine("頬涙　　　　　　：" + maid.FaceName3);
                    var state = GetAnimationState(maid);
                    if (state != null)
                    {
                        Console.WriteLine("アニメーション名：" + state.name);
                    }
                    Console.WriteLine("ボディ　　　　　：" + maid.GetProp(MPN.body).strFileName);
                    Console.WriteLine("バスト(カップ)　：" + maid.status.body.bust + string.Format("({0})", maid.status.body.cup));
                    Console.WriteLine("前髪　　　　　　：" + maid.GetProp(MPN.hairf).strFileName);
                    Console.WriteLine("後髪　　　　　　：" + maid.GetProp(MPN.hairr).strFileName);
                    Console.WriteLine("横髪　　　　　　：" + maid.GetProp(MPN.hairs).strFileName);
                    Console.WriteLine("エクステ髪　　　：" + maid.GetProp(MPN.hairt).strFileName);
                    Console.WriteLine("アホ毛　　　　　：" + maid.GetProp(MPN.hairaho).strFileName);
                }

            }
        }

        /// <summary>
        /// メイド性格取得
        /// </summary>
        private string GetMaidPersonal(Maid maid)
        {
            return maid.status.personal.uniqueName + " [" + maid.status.personal.drawName + "]";
        }

    }

    /// <summary>
    /// メイド付加処理管理
    /// </summary>
    public class MaidExtraManager
    {
        public List<string> BukkakeMenuList { get; set; }
        public MaidBukkakeSet BukkakeSet { get; set; }
        public MaidEnemaSet EffectSet { get; set; }
        public bool IsPeeSE { get; set; }
        public bool IsBreath { get; set; }
        
        private Dictionary<int, GameObject> enema;

        /// <summary>
        /// コンストラクタ
        /// </summary
        public MaidExtraManager()
        {
            BukkakeSet = new MaidBukkakeSet(false);
        }

        //-------------------------------------------------------------------------------------

        /// <summary>
        /// 吐息
        /// </summary>
        public void SetBreath(Maid maid, bool isBreath)
        {
            if (isBreath)
            {
                PlayBreath(maid);
            }
            else
            {
                maid.DelPrefab(MyConst.PERTICLE_BREATH);
            }
        }

        private void PlayBreath(Maid maid)
        {
            var head = MyConst.PERTICLE_BREATH;
            maid.AddPrefab(MyConst.FOLDER_PARTICLE + "/" + head, head, MyConst.BONE_HEAD,
                            new Vector3(0.042f, 0.076f, 0f), new Vector3(-90f, 90f, 0f));
        }

        //-------------------------------------------------------------------------------------

        /// <summary>
        /// ぶっかけリスト取得
        /// </summary>
        public void GetBukkakeMenuList()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_BUKKAKE, "");
            if (!string.IsNullOrEmpty(path))
            {
                BukkakeMenuList = fReader.GetBukkakeMenuLabel(path);
            }
        }
        
        /// <summary>
        /// リストぶっかけ適用
        /// </summary>
        public void SetListBukkakeMenu(List<Maid> maids, int maidIndex, string label, bool isMaidAll)
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_BUKKAKE, "");
            if (!string.IsNullOrEmpty(path))
            {
                var data = fReader.ReadMaidBukkakeMenuData(path, label);
                foreach (var d in data)
                {
                    SetBukkake(maids, maidIndex, d, isMaidAll);
                }
            }
        }

        /// <summary>
        /// ぶっかけリストサンプル出力
        /// </summary>
        public void ExportBukkakeSample()
        {
            new FileWriter().WriteBukkakeSample(BukkakeSet);
        }

        /// <summary>
        /// ぶっかけ設定
        /// </summary>
        public void SetBukkake(List<Maid> maids, int maidIndex, MaidBukkakeSet bukkake, bool isMaidAll)
        {
            if (isMaidAll)
            {
                foreach (var maid in maids)
                {
                    SetBukkake(maid, bukkake);
                }
            }
            else
            {
                SetBukkake(maids[maidIndex], bukkake);
            }
        }

        private void SetBukkake(Maid maid, MaidBukkakeSet bukkake)
        {
            if (maid.IsBusy)
            {
                return;
            }
            var slot = MyConst.BUKKAKE_TAG.Keys.ToList();
            for (int i = 0; i < bukkake.slotNo.Count(); i++)
            {
                if (bukkake.slotNo[i])
                {
                    if (MyConst.DRESS_TAG_SLOT.ContainsKey(slot[i]))
                    {
                        foreach(var slotName in MyConst.DRESS_TAG_SLOT[slot[i]])
                        {
                            SetBukkake(maid, bukkake, slotName, slot[i]);
                        }
                    }
                    else
                    {
                        SetBukkake(maid, bukkake, slot[i], slot[i]);
                    }
                }
            }
        }

        private void SetBukkake(Maid maid, MaidBukkakeSet bukkake, string slotName, string propName)
        {
            var prop = maid.GetProp(propName);
            if (prop.strFileName.EndsWith(MyConst.ITEM_DEL_MENU_END) && 
                string.IsNullOrEmpty(prop.strTempFileName) ||
                prop.strTempFileName.EndsWith(MyConst.ITEM_DEL_MENU_END))
            {
                return;
            }
            var matNoData = new List<int>();
            var propData = new Dictionary<int, List<string>>();
            var ratio = 1f;
            var textSize = MyConst.BUKKAKE_TEXTURE_SIZE;
            if (MyConst.BUKKAKE_TAG_BODY.ContainsKey(slotName))
            {
                var mNo = MyConst.MULTEX_MATNO_COMMON;
                if (slotName == MyConst.BUKKAKE_HEAD)
                {
                    mNo = MyConst.MULTEX_MATNO_HEAD;
                    ratio = 2f;
                }
                if (bukkake.isAutoFit)
                {
                    bukkake.min.x = 0;
                    bukkake.max.x = textSize;
                    bukkake.min.y = 0;
                    bukkake.max.y = textSize;
                }
                matNoData.Add(mNo);
                propData[mNo] = new List<string>();
                propData[mNo].Add(MyConst.PROPNAME_MAINTEX);
                propData[mNo].Add(MyConst.PROPNAME_SHADOWTEX);
            }
            else
            {
                var obj = maid.body0.GetSlot(slotName).obj;
                if (obj == null)
                {
                    return;
                }
                var render = obj.GetComponentInChildren<SkinnedMeshRenderer>(false);
                if (render == null)
                {
                    return;
                }
                if (render.materials == null)
                {
                    return;
                }
                var isFairst = true;
                for (int i = 0; i < render.materials.Count(); i++)
                {
                    propData[i] = new List<string>();
                    var texture = render.materials[i].GetTexture(MyConst.PROPNAME_MAINTEX);
                    if (texture != null)
                    {
                        propData[i].Add(MyConst.PROPNAME_MAINTEX);
                        matNoData.Add(i);
                        if (isFairst)
                        {
                            var width = texture.width;
                            var height = texture.height;
                            if (bukkake.isAutoFit)
                            {
                                bukkake.min.x = 0;
                                bukkake.max.x = width;
                                bukkake.min.y = 0;
                                bukkake.max.y = height;
                            }
                            textSize = width;
                            isFairst = false;
                        }
                    }
                    texture = render.materials[i].GetTexture(MyConst.PROPNAME_SHADOWTEX);
                    if (texture != null)
                    {
                        propData[i].Add(MyConst.PROPNAME_SHADOWTEX);
                    }
                }
                if(MyHelper.CheckNull(matNoData))
                {
                    return;
                }
            }

            for (int i = 0; i < bukkake.fileNo.GetLength(0); i++)
            {
                for (int j = 0; j < bukkake.fileNo.GetLength(1); j++)
                {
                    if(!bukkake.fileNo[i, j])
                    {
                        continue;
                    }
                    for (int k = 0; k < bukkake.repeat; k++)
                    {
                        var x = MyHelper.GetRandomFloat(bukkake.min.x, bukkake.max.x);
                        var y = MyHelper.GetRandomFloat(bukkake.min.y, bukkake.max.y);
                        var r = MyHelper.GetRandomFloat(bukkake.min.z, bukkake.max.z);
                        var s = MyHelper.GetRandomFloat(bukkake.min.w, bukkake.max.w);

                        var file = MyConst.FOLDER_SEIEKI + (j + 1).ToString("000") + (i == 0 ? "" : "r");
                        foreach (var matNo in matNoData)
                        {
                            foreach (var p in propData[matNo])
                            {
                                maid.body0.MulTexSet(
                                    slotName,
                                    matNo,
                                    p,
                                    MyConst.MULTEX_LAYERNO,
                                    file,
                                    GameUty.SystemMaterial.Alpha,
                                    true,
                                    (int)x,
                                    (int)y,
                                    r,
                                    s * ratio,
                                    false,
                                    null,
                                    1f,
                                    textSize);
                            }
                        }
                    }
                }
            }
            maid.body0.MulTexProc(slotName);
        }

        /// <summary>
        /// 拭く
        /// </summary>
        public void RemoveBukkake(Maid maid)
        {
            var slot = MyConst.BUKKAKE_TAG.Keys.ToList();
            for (int i = 0; i < BukkakeSet.slotNo.Count(); i++)
            {
                if (BukkakeSet.slotNo[i])
                {
                    RemoveBukkake(maid, slot[i]);
                }
            }
            maid.AllProcPropSeqStart();
        }
        
        private void RemoveBukkake(Maid maid, string slotName)
        {
            if (!MyConst.DRESS_TAG_COMMON.ContainsKey(slotName))
            {
                var matNo = slotName == MyConst.BUKKAKE_HEAD ? MyConst.MULTEX_MATNO_HEAD : MyConst.MULTEX_MATNO_COMMON;
                foreach (var p in new string[] { MyConst.PROPNAME_MAINTEX, MyConst.PROPNAME_SHADOWTEX })
                {
                    for (int i = 10; i <= 20; i++)
                    {
                        maid.body0.MulTexRemove(slotName, matNo, p, i);
                    }
                }
                maid.body0.MulTexProc(slotName);
            }
            if (!MyConst.BUKKAKE_TAG_BODY.ContainsKey(slotName))
            {
                var prop = maid.GetProp(slotName);
                var menu = prop.strTempFileName;
                var delMenu = string.Format(MyConst.ITEM_DEL_MENU, slotName);
                if (!string.IsNullOrEmpty(menu) &&
                    (MyHelper.IsExistingOfficialFile(menu) || MyHelper.IsExistingModFile(menu)))
                {
                    maid.SetProp(slotName, delMenu, 0, true, false);
                    maid.SetProp(slotName, menu, 0, true, false);
                }
                else
                {
                    maid.ResetProp(slotName, true);
                }
            }
        }

        //-------------------------------------------------------------------------------------

        /// <summary>
        /// おもらし
        /// </summary>
        public void PlayPee(Maid maid, bool isCOM3D2)
        {
            var pee = (isCOM3D2) ? MyConst.PERTICLE_PEE_COM : MyConst.PERTICLE_PEE_CM;
            maid.AddPrefab(MyConst.FOLDER_PARTICLE + "/" + pee, pee, MyConst.IK_VAGINA,
                            new Vector3(0f, -0.047f, 0.011f), new Vector3(20.0f, -180.0f, 180.0f));
            if (IsPeeSE && !isCOM3D2)
            {
                new SoundManager().PlaySe(MyConst.SE_PEE);
            }
        }

        public void RemovePeeAll(List<Maid> maids)
        {
            foreach (var maid in maids)
            {
                maid.DelPrefab(MyConst.PERTICLE_PEE_COM);
                maid.DelPrefab(MyConst.PERTICLE_PEE_CM);
            }
        }

        //-------------------------------------------------------------------------------------

        /// <summary>
        /// 浣腸
        /// </summary>
        public void PlayEnema(int slotNo)
        {
            if (enema == null)
            {
                enema = new Dictionary<int, GameObject>();
            }
            else
            {
                RemoveEnema(slotNo);
            }

            var path = MyConst.FOLDER_PREFAB + MyConst.FOLDER_PARTICLE + "/" + MyConst.PERTICLE_PEE_CM;
            enema[slotNo] = GameObject.Instantiate(Resources.Load(path)) as GameObject;
            var particle = enema[slotNo].GetComponent<ParticleSystem>();
            PlayEnemaParticle(particle);
            foreach (var p in particle.GetComponentsInChildren<ParticleSystem>())
            {
                PlayEnemaParticle(p);
            }
            particle.Play();
        }

        public void SetTransform(Maid maid, int slotNo)
        {
            if (enema.ContainsKey(slotNo))
            {
                Vector3 pos;
                Quaternion rot;
                Vector3 sca;
                maid.body0.GetAttachPointWorld(TBody.SlotID.body, MyConst.ATTACH_POINT_ANAL, out pos, out rot, out sca);
                var particle = enema[slotNo].GetComponent<ParticleSystem>();
                particle.transform.position = pos;
                particle.transform.rotation = rot;
                particle.transform.localScale = sca;
            }
        }

        public void RemoveEnemaAll()
        {
            if (IsEnema())
            {
                foreach (var key in enema.Keys.ToList())
                {
                    RemoveEnema(key);
                }
                MyHelper.ClearDictionary(enema);
            }
        }

        public bool IsEnema()
        {
            return !MyHelper.CheckNull(enema);
        }

        private void PlayEnemaParticle(ParticleSystem particle)
        {
            if (!particle.name.Contains(MyConst.PERTICLE_PEE_STEAM))
            {
                var data = EffectSet;
                var material = particle.GetComponent<Renderer>().material;
                material.color = data.color;
                if (data.isShader)
                {
                    material.shader = Shader.Find(MyConst.SHADER_LIGHTED_TRANS);
                }
                var main = particle.main;
                main.startColor = (Color)data.color;
                if (particle.name.Contains(MyConst.PERTICLE_PEE_CM) || particle.name.Contains(MyConst.PERTICLE_PEE_HIMATU))
                {
                    main.duration = data.duration;
                    main.gravityModifier = data.gravityModifier;
                    if (particle.name.Contains(MyConst.PERTICLE_PEE_CM))
                    {
                        main.startLifetime = data.startLifetime;
                        main.startRotation = data.startRotation;
                        main.startSize = data.startSize;
                        if (!string.IsNullOrEmpty(data.textureName))
                        {
                            var reader = new FileReader();
                            var path = reader.GetFilePath(data.textureName, MyConst.FOLDER_PNG);
                            if (!string.IsNullOrEmpty(path))
                            {
                                material.mainTexture = reader.ReadPngTexture(path);
                            }
                        }
                    }
                    else
                    {
                        main.startSize = data.startSize;
                    }
                }
                particle.GetComponent<Renderer>().material = material;

                var emitter = particle.subEmitters;
                for (int i = 0; i < emitter.subEmittersCount; i++)
                {
                    PlayEnemaParticle(emitter.GetSubEmitterSystem(i));
                }
            }
        }

        private void RemoveEnema(int slotNo)
        {
            if (enema.ContainsKey(slotNo))
            {
                GameObject.Destroy(enema[slotNo]);
                enema.Remove(slotNo);
            }
        }
    }

    /// <summary>
    /// 衣装管理処理管理
    /// </summary>
    public class DressManager
    {
        public Dictionary<string, MaidBindSet> BindDic { get; set; }
        public Dictionary<int, string> BindSlotDic { get; set; }
        public Dictionary<string, string> DressDic { get; set; }
        public Dictionary<TBody.SlotID, bool> UndressDic { get; set; }
        public List<DanceDressSet> DanceDressData { get; set; }
        public List<DanceUndressSet> DanceUndressData { get; set; }
        public DanceUndressSet UndressRandom { get; set; }
        public MaidDressMenuSet MenuData { get; set; }
        public List<string> DressList { get; set; }
        public List<string> DressGroupList { get; set; }
        public List<string> DressMenuList { get; set; }
        public bool IsUndressRandomOn { get; set; }
        public bool IsUndressRandomBlushOn { get; set; }
        public bool IsFreeDance { get; set; }
        public bool IsStarting { get; set; }
        public bool IsEnding { get; set; }
        public bool IsMaidAll { get; set; }
        public bool IsBind { get; set; }
        public int DressTypeIndex { get; set; }
        public int DressGroupIndex { get; set; }
        public int DressMenuIndex { get; set; }

        /// <summary>
        /// コンストラクタ
        /// </summary
        public DressManager()
        {
            ClearDressDicFileName();
            BindDic = new Dictionary<string, MaidBindSet>();
            BindSlotDic = new Dictionary<int, string>();
        }

        /// <summary>
        /// 全メイド脱衣設定
        /// </summary
        public void UnderessAllMaid(Maid maid, TBody.SlotID slotID, bool isVisible)
        {
            maid.body0.SetMask(slotID, isVisible);
        }

        /// <summary>
        /// 全メイドめくれ・ずらし設定
        /// </summary
        public void ShiftDeress(Maid maid, int slotId, bool isShifted)
        {
            switch (slotId)
            {
                case MyConst.UNDRESS_FRONT:
                    if (isShifted)
                    {
                        maid.ItemChangeTemp("skirt", "めくれスカート");
                        maid.ItemChangeTemp("onepiece", "めくれスカート");
                    }
                    else
                    {
                        maid.ResetProp("skirt", false);
                        maid.ResetProp("onepiece", false);
                    }
                    break;
                case MyConst.UNDRESS_BACK:
                    if (isShifted)
                    {
                        maid.ItemChangeTemp("skirt", "めくれスカート後ろ");
                        maid.ItemChangeTemp("onepiece", "めくれスカート後ろ");
                    }
                    else
                    {
                        maid.ResetProp("skirt", false);
                        maid.ResetProp("onepiece", false);
                    }
                    break;
                case MyConst.UNDRESS_SHIFT:
                    if (isShifted)
                    {
                        maid.ItemChangeTemp("panz", "パンツずらし");
                        maid.ItemChangeTemp("mizugi", "パンツずらし");
                    }
                    else
                    {
                        maid.ResetProp("panz", false);
                        maid.ResetProp("mizugi", false);
                    }
                    break;
            }
            maid.AllProcPropSeqStart();
        }

        /// <summary>
        /// ダンスメイド自動脱衣設定
        /// </summary>
        public void UnderessDanceMaidAuto(float bgmTime, MaidManager maidMgr)
        {
            var maids = maidMgr.GetActiveMaids();
            if (!MyHelper.CheckNull(maids))
            {
                var dic = new Dictionary<int, bool>();
                for (int i = 0; i < DanceUndressData.Count(); i++)
                {
                    var data = DanceUndressData[i];
                    foreach (var maid in maids)
                    {
                        if (data.slotNo == maidMgr.GetDanceSlotNo(maid))
                        {
                            if (data.time <= bgmTime)
                            {
                                if (MyConst.UNDRESS_SLOT.ContainsValue(data.label))
                                {
                                    var key = MyHelper.GetDictionaryKey(MyConst.UNDRESS_SLOT, data.label);
                                    if (data.isMasked)
                                    {
                                        if (key >= 0)
                                        {
                                            maid.body0.SetMask(key, false);
                                            dic[i] = false;
                                        }
                                        else
                                        {
                                            ShiftDeress(maid, (int)key, true);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                if (!MyHelper.CheckNull(dic))
                {
                    foreach (var key in dic.Keys)
                    {
                        var data = DanceUndressData[key];
                        data.isMasked = dic[key];
                        DanceUndressData[key] = data;
                    }
                }
            }
        }

        /// <summary>
        /// ダンスメイドランダム脱衣設定
        /// </summary>
        public void UnderessDanceMaidRandom(float bgmTime, MaidManager maidMgr)
        {
            var undressData = UndressRandom;
            undressData.time += Time.deltaTime;
            if (bgmTime >= undressData.startTime && undressData.time >= undressData.interval)
            {
                undressData.time = 0f;
                var list = new List<TBody.SlotID>();
                foreach (var key in MyConst.UNDRESS_SLOT.Keys)
                {
                    if (key >= 0)
                    {
                        list.Add(key);
                    }
                }
                if (!MyHelper.CheckNull(list))
                {
                    var maids = maidMgr.GetActiveMaids();
                    if (!MyHelper.CheckNull(maids))
                    {
                        foreach (var maid in maids)
                        {
                            var index = MyHelper.GetRandomIndex(list.Count());
                            var slotId = list[index];
                            maid.body0.SetMask(slotId, false);
                        }
                    }
                }
            }
            UndressRandom = undressData;
        }

        /// <summary>
        /// ダンスメイド脱衣羞恥設定
        /// </summary>
        public void SetUndressFaicialOption(MaidManager maidMgr)
        {
            var maids = maidMgr.GetActiveMaids();
            if (!MyHelper.CheckNull(maids))
            {
                foreach (var maid in maids)
                {
                    var isWear = IsMask(maid, TBody.SlotID.wear);
                    var isBra = IsMask(maid, TBody.SlotID.bra);
                    var isSkirt = IsMask(maid, TBody.SlotID.skirt);
                    var isPanz = IsMask(maid, TBody.SlotID.panz);
                    var isOnepiece = IsMask(maid, TBody.SlotID.onepiece);
                    var isMizugi = IsMask(maid, TBody.SlotID.mizugi);
                    var dic = new Dictionary<string, float>();
                    if (!isMizugi)
                    {
                        if (!isOnepiece && (!isWear || !isSkirt) || !isBra || !isPanz)
                        {
                            if (!isOnepiece && (!isWear && !isBra || !isSkirt && !isPanz))
                            {
                                dic[MyConst.FACE_OPTION_TEARS] = MyConst.FACE_BLEND_VALUE;
                            }
                            dic[MyConst.FACE_OPTION_BLUSH] = MyConst.FACE_BLEND_VALUE;
                            maidMgr.SetMorphValue(maid, dic);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// ダンスメイド脱衣羞恥設定
        /// </summary>
        private bool IsMask(Maid maid, TBody.SlotID slotId)
        {
            var isMask = maid.body0.GetMask(slotId);
            if (isMask)
            {
                var slot = Enum.GetName(typeof(TBody.SlotID), slotId);
                var prop = maid.GetProp(slot.ToLower());
                var name = string.IsNullOrEmpty(prop.strTempFileName) ? prop.strFileName : prop.strTempFileName;
                if (name.EndsWith(MyConst.ITEM_DEL_MENU_END))
                {
                    isMask = false;
                }
            }
            return isMask;
        }

        /// <summary>
        /// 全メイドぽろり設定
        /// </summary
        public void PororiAllMaid(Maid maid, string tag, bool isReset)
        {
            var porori = string.Format(MyConst.PORORI_NAME, "");
            var menuName = GetDressFileName(maid, true, tag);
            var menuNameUB = "";
            if (string.IsNullOrEmpty(menuName))
            {
                menuName = GetDressFileName(maid, false, tag);
            }

            if (!(isReset && !menuName.Contains(porori)))
            {
                if (!string.IsNullOrEmpty(menuName) && !menuName.EndsWith(MyConst.ITEM_DEL_MENU_END) && !isReset)
                {
                    menuName = Path.GetFileNameWithoutExtension(menuName);
                    if (menuName.Contains(porori))
                    {
                        var s = menuName.Substring(menuName.Length - 1, 1);
                        int i;
                        if (int.TryParse(s, out i))
                        {
                            menuName = menuName.Substring(0, menuName.Length - 1) + (i + 1);
                        }
                        else
                        {
                            menuName += "2";
                        }
                    }
                    else
                    {
                        menuNameUB = menuName + "_" + porori + MyConst.EXTENSION_MENU;
                        menuName += porori;
                    }
                    menuName += MyConst.EXTENSION_MENU;
                }

                if (isReset || !CheckFile(menuName))
                {
                    if (isReset || !CheckFile(menuNameUB))
                    {
                        var index = menuName.LastIndexOf(porori);
                        if (index > 0)
                        {
                            menuName = menuName.Substring(0, index);
                            menuNameUB = menuName + MyConst.EXTENSION_MENU;
                            if (!CheckFile(menuNameUB))
                            {
                                menuNameUB = menuName.Substring(0, menuName.Length - 1) + MyConst.EXTENSION_MENU;
                            }
                            menuName = menuNameUB;
                        }
                    }
                    else
                    {
                        menuName = menuNameUB;
                    }
                }
                SetTempDress(maid, tag, menuName);
            }
        }

        private bool CheckFile(string menuName)
        {
            return MyHelper.IsExistingOfficialFile(menuName) || MyHelper.IsExistingModFile(menuName);
        }

        /// <summary>
        /// プリセット適用
        /// </summary>
        public void SetWearPreset(CharacterMgr.Preset preseData, bool isMaidPresetSave, Maid maid)
        {
            var mrg = GameMain.Instance.CharacterMgr;
            if (isMaidPresetSave)
            {
                mrg.PresetSave(maid, CharacterMgr.PresetType.Wear);
            }
            mrg.PresetSet(maid, preseData);
        }

        /// <summary>
        /// 衣装一時適用（拘束）
        /// </summary>
        public bool SetBindDress(Maid maid, string tag, string fileName)
        {
            return SetTempDress(maid, tag, fileName);
        }

        /// <summary>
        /// 衣装一時適用
        /// </summary>
        public bool SetTempDress(List<Maid> maids, int maidIndex, string tag, string fileName)
        {
            var isChanged = false;
            if (IsMaidAll)
            {
                foreach (var maid in maids)
                {
                    isChanged = SetTempDress(maid, tag, fileName);
                }
            }
            else
            {
                isChanged = SetTempDress(maids[maidIndex], tag, fileName);
            }
            return isChanged;
        }

        public bool SetTempDress(Maid maid, string tag, string fileName)
        {
            if (string.IsNullOrEmpty(fileName))
            {
                fileName = GetDelMenu(maid, tag);
            }
            var isTemp = false;
            if (MyHelper.IsExistingOfficialFile(fileName) || MyHelper.IsExistingModFile(fileName))
            {
                var isSet = true;
                if (tag == MyConst.DRESS_TAG_ACCKAMISUB)
                {
                    var prop = maid.GetProp(MPN.hairt);
                    isSet = !string.IsNullOrEmpty(prop.strFileName) && !prop.strFileName.EndsWith(MyConst.ITEM_DEL_MENU_END) ||
                            !string.IsNullOrEmpty(prop.strTempFileName) && !prop.strTempFileName.EndsWith(MyConst.ITEM_DEL_MENU_END);
                }
                if (isSet)
                {
                    maid.SetProp(tag, fileName, 0, true, false);
                    maid.AllProcPropSeqStart();
                    isTemp = true;
                }
            }
            else
            {
                Console.WriteLine(string.Format("メニューファイルがありません：{0}", fileName));
            }
            return isTemp;
        }

        /// <summary>
        /// フリーダンス衣装変更
        /// </summary>
        public void ChangeFreeDanceDress(float bgmTime, List<Maid> maids, MaidManager maidMgr)
        {
            for (int i = 0; i < DanceDressData.Count(); i++)
            {
                var data = DanceDressData[i];
                if (data.time < bgmTime && !data.isChanged)
                {
                    foreach (var maid in maids)
                    {
                        if (data.slotNo == maidMgr.GetDanceSlotNo(maid))
                        {
                            foreach (var key in data.dressDic.Keys)
                            {
                                SetTempDress(maid, key, data.dressDic[key]);
                            }
                        }
                    }
                    data.isChanged = true;
                }
                else if (bgmTime <= data.time)
                {
                    data.isChanged = false;
                }
                DanceDressData[i] = data;
            }
        }

        /// <summary>
        /// 衣装ファイル名取得（全部）
        /// </summary>
        public void GetDressAllFileName(Maid maid, bool isTemp)
        {
            foreach (var key in MyConst.DRESS_TAG.Keys)
            {
                DressDic[key] = GetDressFileName(maid, isTemp, key);
            }
        }

        /// <summary>
        /// 衣装ファイル名取得（指定）
        /// </summary>
        public string GetDressFileName(Maid maid, bool isTemp, string tag)
        {
            var prop = maid.GetProp(tag);
            return isTemp ? prop.strTempFileName : prop.strFileName;
        }

        /// <summary>
        /// 衣装ファイル名クリア
        /// </summary>
        public void ClearDressDicFileName()
        {
            DressDic = new Dictionary<string, string>();
            foreach (var key in MyConst.DRESS_TAG.Keys)
            {
                DressDic[key] = "";
            }
        }

        /// <summary>
        /// リスト衣装適用
        /// </summary>
        public void SetListDress(List<Maid> maids, int maidIndex, string label)
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_DRESS, "");
            if (!string.IsNullOrEmpty(path))
            {
                DressDic = fReader.ReadMaidDressData(path, label);
                foreach (var key in MyConst.DRESS_TAG.Keys)
                {
                    if (!string.IsNullOrEmpty(DressDic[key]))
                    {
                        SetTempDress(maids, maidIndex, key, DressDic[key]);
                    }
                }
            }
        }

        /// <summary>
        /// ダンス衣装適用
        /// </summary>
        public void SetDanceDress(List<Maid> maids, Dictionary<int, string> dressDic, bool isGui)
        {
            IsStarting = false;
            IsEnding = false;

            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_DRESS, "");
            if (!string.IsNullOrEmpty(path))
            {
                var dic = fReader.ReadDanceMaidDressData(path, dressDic.Values.ToList());
                if (!MyHelper.CheckNull(dic))
                {
                    foreach (var maid in maids)
                    {
                        var slotNo = new MaidManager().GetActiveSlotNo(maid);
                        if (dressDic.ContainsKey(slotNo))
                        {
                            var label = dressDic[slotNo];
                            if (dic.ContainsKey(label))
                            {
                                var d = dic[label];
                                foreach (var key in MyConst.DRESS_TAG.Keys)
                                {
                                    if (!string.IsNullOrEmpty(d[key]))
                                    {
                                        SetTempDress(maid, key, d[key]);
                                    }
                                }
                            }
                        }
                    }
                    if (!isGui)
                    {
                        IsStarting = true;
                        IsFreeDance = true;
                    }
                }
            }
        }

        /// <summary>
        /// ダンスグループ衣装適用
        /// </summary>
        public void SetDanceGroupDress(List<Maid> maids)
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_DRESS_GROUP, "");
            if (!string.IsNullOrEmpty(path) && !MyHelper.CheckNull(DressGroupList))
            {
                var groupList = fReader.ReadDressGroupMaidData(path, DressGroupList[DressGroupIndex]);
                if (!MyHelper.CheckNull(groupList))
                {
                    var dresses = groupList.Keys.ToList();
                    var dressDic = new Dictionary<int, string>();
                    var maidMgr = new MaidManager();
                    foreach (var maid in maids)
                    {
                        var name = dresses.FirstOrDefault(d => d == maidMgr.GetMaidFullName(maid));
                        if (!string.IsNullOrEmpty(name))
                        {
                            dressDic[maidMgr.GetActiveSlotNo(maid)] = groupList[name];
                        }
                    }
                    if (!MyHelper.CheckNull(dressDic))
                    {
                        SetDanceDress(maids, dressDic, true);
                    }
                }
            }
        }

        /// <summary>
        /// ダンスグループ衣装適用（リスト順）
        /// </summary>
        public void SetDanceOderGroupDress(List<Maid> maids)
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_DRESS_GROUP, "");
            if (!string.IsNullOrEmpty(path) && !MyHelper.CheckNull(DressGroupList))
            {
                var groupList = GetDressGroupSpecifiedList(DressGroupList[DressGroupIndex]);
                if (!MyHelper.CheckNull(groupList))
                {
                    var dressDic = new Dictionary<int, string>();
                    var maidMgr = new MaidManager();
                    var index = 0;
                    foreach (var maid in maids)
                    {
                        dressDic[maidMgr.GetActiveSlotNo(maid)] = groupList[index];
                        index++;
                        if (groupList.Count() <= index)
                        {
                            index = 0;
                        }
                    }
                    if (!MyHelper.CheckNull(dressDic))
                    {
                        SetDanceDress(maids, dressDic, true);
                    }
                }
            }
        }

        /// <summary>
        /// ダンスグループ衣装適用（ランダム）
        /// </summary>
        public void SetDanceRandomGroupDress(List<Maid> maids)
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_DRESS_GROUP, "");
            if (!string.IsNullOrEmpty(path) && !MyHelper.CheckNull(DressGroupList))
            {
                var groupList = GetDressGroupSpecifiedList(DressGroupList[DressGroupIndex]);
                if (!MyHelper.CheckNull(groupList))
                {
                    var dressDic = new Dictionary<int, string>();
                    var maidMgr = new MaidManager();
                    var randomList = new List<int>();
                    foreach (var maid in maids)
                    {
                        if (randomList == null || randomList.Count() == 0)
                        {
                            randomList = Enumerable.Range(0, groupList.Count()).ToList();
                        }
                        var index = MyHelper.GetRandomIndex(randomList.Count());
                        dressDic[maidMgr.GetActiveSlotNo(maid)] = groupList[randomList[index]];
                        randomList.RemoveAt(index);
                    }
                    if (!MyHelper.CheckNull(dressDic))
                    {
                        SetDanceDress(maids, dressDic, true);
                    }
                }
            }
        }

        /// <summary>
        /// ダンス衣装部位メニュー取得
        /// </summary>
        public void SeDanceDressPartsMenuData()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_DRESS, "");
            if (!string.IsNullOrEmpty(path))
            {
                var data = new List<DanceDressSet>();
                foreach (var d in DanceDressData)
                {
                    var dress = d;
                    dress.dressDic = fReader.ReadMaidDressData(path, d.label);
                    if (!MyHelper.CheckNull(dress.dressDic))
                    {
                        data.Add(dress);
                    }
                }
                DanceDressData = data;
                if (!MyHelper.CheckNull(DanceDressData))
                {
                    IsFreeDance = true;
                }
            }
        }

        /// <summary>
        /// リスト衣装メニュー取得
        /// </summary>
        public void GetDressMenuData(string label)
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_DRESS_MENU, "");
            if (!string.IsNullOrEmpty(path))
            {
                MenuData = fReader.ReadDressMenuData(path, label);
                DressMenuIndex = 0;
            }
        }

        /// <summary>
        /// 衣装リスト取得
        /// </summary>
        public void GetDressList()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_DRESS, "");
            if (!string.IsNullOrEmpty(path))
            {
                DressList = fReader.GetDressLabel(path);
            }
        }

        /// <summary>
        /// 衣装グループリスト取得
        /// </summary>
        public void GetDressGroupList()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_DRESS_GROUP, "");
            if (!string.IsNullOrEmpty(path))
            {
                DressGroupList = fReader.GetDressGroupLabel(path);
            }
        }

        /// <summary>
        /// 指定衣装グループリスト取得
        /// </summary>
        public List<string> GetDressGroupSpecifiedList(string label)
        {
            var data = new List<string>();
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_DRESS_GROUP, "");
            if (!string.IsNullOrEmpty(path))
            {
                data = fReader.ReadDressGroupData(path, label);
            }
            return data;
        }

        /// <summary>
        /// 衣装メニューリスト取得
        /// </summary>
        public void GetDressMenuList()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_DRESS_MENU, "");
            if (!string.IsNullOrEmpty(path))
            {
                DressMenuList = fReader.GetDressMenuLabel(path);
            }
        }

        /// <summary>
        /// 衣装リセット
        /// </summary>
        public void ResetDressMenu(List<Maid> maids)
        {
            foreach (var maid in maids)
            {
                ResetDressMenu(maid);
            }
        }

        public void ResetDressMenu(Maid maid)
        {
            foreach (var tag in MyConst.DRESS_TAG.Keys)
            {
                maid.ResetProp(tag, true);
            }
            maid.AllProcPropSeqStart();
        }

        /// <summary>
        /// 削除メニュー取得
        /// </summary>
        private string GetDelMenu(Maid maid, string tag)
        {
            var text = string.Format(MyConst.ITEM_DEL_MENU, tag);
            switch (tag)
            {
                case MyConst.DRESS_TAG_SKIN:
                    text = GetDressFileName(maid, false, tag);
                    break;
                case MyConst.DRESS_TAG_BIND_U:
                    text = MyConst.ITEM_DEL_MENU_BIND_U;
                    break;
                case MyConst.DRESS_TAG_BIND_L:
                    text = MyConst.ITEM_DEL_MENU_BIND_L;
                    break;
            }
            return text;
        }

        //-----------------------------------------------------------------------------------------------------------------

        /// <summary>
        /// 拘束スロットデータクリア
        /// </summary>
        public void ClearBindSlotData()
        {
            MyHelper.ClearDictionary(BindSlotDic);
            BindSlotDic = new Dictionary<int, string>();
        }

        /// <summary>
        /// 拘束ファイルデータ読み込み
        /// </summary>
        public void ReadBindData()
        {
            var reader = new FileReader();
            var path = reader.GetFilePath(MyConst.FILE_MAID_BIND, "");
            BindDic = reader.ReadMaidBindData(path);
        }

        /// <summary>
        /// 拘束データ設定
        /// </summary>
        public void SetBindData(Maid maid, int slotNo, bool isBone)
        {
            if (!BindSlotDic.ContainsKey(slotNo))
            {
                return;
            }
            var label = BindSlotDic[slotNo];
            if (!BindDic.ContainsKey(label))
            {
                return;
            }
            var data = BindDic[label];
            if (isBone)
            {
                foreach (var pair in data.bindDic)
                {
                    try
                    {
                        var bone = maid.body0.GetBone(pair.Key);
                        bone.transform.localEulerAngles = pair.Value;
                    }
                    catch
                    {
                        //
                    }
                }
            }
            else
            {
                foreach (var pair in data.menuDic)
                {
                    SetBindDress(maid, pair.Key, pair.Value);
                }
            }
        }

        /// <summary>
        /// 拘束サンプルデータ出力
        /// </summary>
        public void WriteSample(Maid maid)
        {
            var menu = new Dictionary<string, string>();
            var bind = new Dictionary<string, Vector3>();
            foreach (var tag in MyConst.DRESS_TAG.Keys)
            {
                var fileName = GetDressFileName(maid, false, tag);
                menu[tag] = fileName;
            }
            foreach (var tag in MyConst.BONE_NAME_ALL.Keys)
            {
                var bone = maid.body0.GetBone(tag);
                bind[tag] = bone.transform.localEulerAngles;
            }
            new FileWriter().WriteMaidBindSample(menu, bind);
        }

    }

    /// <summary>
    /// 髪管理処理管理
    /// </summary>
    public class HairManager
    {
        public Dictionary<string, string> HairMenuDic { get; set; }
        public List<string> HairMenuList { get; set; }

        /// <summary>
        /// コンストラクタ
        /// </summary
        public HairManager()
        {
            ClearHairMenuDicFileName();
            HairMenuList = new List<string>();
        }

        /// <summary>
        /// 髪リスト取得
        /// </summary>
        public void GetHairMenuList()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_HAIR_MENU, "");
            if (!string.IsNullOrEmpty(path))
            {
                HairMenuList = fReader.GetHairMenuLabel(path);
            }
        }

        /// <summary>
        /// 髪ファイル名取得（全部）
        /// </summary>
        public void GetHairMenuAllFileName(Maid maid, bool isTemp)
        {
            foreach (var key in MyConst.HAIR_TAG.Keys)
            {
                HairMenuDic[key] = GetHairMenuFileName(maid, isTemp, key);
            }
        }

        /// <summary>
        /// 髪ファイル名取得（指定）
        /// </summary>
        public string GetHairMenuFileName(Maid maid, bool isTemp, string tag)
        {
            var prop = maid.GetProp(tag);
            return isTemp ? prop.strTempFileName : prop.strFileName;
        }

        /// <summary>
        /// 髪ファイル名クリア
        /// </summary>
        public void ClearHairMenuDicFileName()
        {
            HairMenuDic = new Dictionary<string, string>();
            foreach (var key in MyConst.HAIR_TAG.Keys)
            {
                HairMenuDic[key] = "";
            }
        }

        /// <summary>
        /// リスト髪適用
        /// </summary>
        public void SetListHairMenu(List<Maid> maids, int maidIndex, string label, bool isMaidAll)
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_HAIR_MENU, "");
            if (!string.IsNullOrEmpty(path))
            {
                HairMenuDic = fReader.ReadMaidHairMenuData(path, label);
                foreach (var key in MyConst.HAIR_TAG.Keys)
                {
                    if (!string.IsNullOrEmpty(HairMenuDic[key]))
                    {
                        SetTempHairMenu(maids, maidIndex, key, HairMenuDic[key], isMaidAll);
                    }
                }
            }
        }

        /// <summary>
        /// 髪一時適用
        /// </summary>
        public bool SetTempHairMenu(List<Maid> maids, int maidIndex, string tag, string fileName, bool isMaidAll)
        {
            var isChanged = false;
            if (isMaidAll)
            {
                foreach (var maid in maids)
                {
                    isChanged = SetTempHairMenu(maid, tag, fileName);
                }
            }
            else
            {
                isChanged = SetTempHairMenu(maids[maidIndex], tag, fileName);
            }
            return isChanged;
        }

        public bool SetTempHairMenu(Maid maid, string tag, string fileName)
        {
            if (string.IsNullOrEmpty(fileName))
            {
                fileName = string.Format(MyConst.ITEM_DEL_MENU, tag);
            }
            var isTemp = false;
            if (MyHelper.IsExistingOfficialFile(fileName) || MyHelper.IsExistingModFile(fileName))
            {
                maid.SetProp(tag, fileName, 0, true, false);
                maid.AllProcPropSeqStart();
                isTemp = true;
            }
            else
            {
                Console.WriteLine(string.Format("メニューファイルがありません：{0}", fileName));
            }
            return isTemp;
        }

        /// <summary>
        /// 髪リセット
        /// </summary>
        public void ResetHairMenu(List<Maid> maids)
        {
            foreach (var maid in maids)
            {
                ResetHairMenu(maid);
            }
        }

        public void ResetHairMenu(Maid maid)
        {
            foreach (var tag in MyConst.HAIR_TAG.Keys)
            {
                maid.ResetProp(tag, true);
            }
            maid.AllProcPropSeqStart();
        }
    }

    /// <summary>
    /// 揺れ処理管理
    /// </summary>
    public class SwingManager
    {
        public List<MaidMuneSet> EachMuneData { get; set; }
        public List<MaidMuneSet> CommonMuneData { get; set; }
        public List<Dictionary<TBody.SlotID, DynamicBone>> CommonHairData { get; set; }
        public List<Dictionary<TBody.SlotID, DynamicSkirtBone>> CommonSkirtData { get; set; }

        public bool GuiIsTemp { get; set; }
        public bool IsEachSetting { get; set; }
        public bool IsInstant { get; set; }
        public int CommonSaveIndex { get; set; }
        public int MuneSettingIndex { get; set; }
        public int SwingIndex { get; set; }

        /// <summary>
        /// コンストラクト
        /// </summary>
        public SwingManager()
        {
            CommonMuneData = new List<MaidMuneSet>();
            CommonHairData = new List<Dictionary<TBody.SlotID, DynamicBone>>();
            CommonSkirtData = new List<Dictionary<TBody.SlotID, DynamicSkirtBone>>();

            foreach (int i in Enumerable.Range(0, MyConst.SWING_SETTING_COUNT))
            {
                CommonMuneData.Add(GetMuneDefaultValue());
                CommonHairData.Add(GetHairDefaultValue());
                CommonSkirtData.Add(GetSkirtDefaultValue());
            }
        }

        public void SetAutoDance(List<Maid> maids, bool isMune, bool isHair, bool isDress, bool isMultipleMaids)
        {
            if (isMune)
            {
                ReadCommonMuneParameter(maids);
                //ReadEachMuneParameter(maids);
            }
            if (isHair)
            {
                ReadCommonHairParameter(maids);
                ReadEachHairParameter(maids, MyConst.PRE_INDEX);
            }
            if (isDress && !isMultipleMaids)
            {
                ReadCommonSkirtParameter(maids);
                ReadEachSkirtParameter(maids, MyConst.PRE_INDEX);
            }
        }

        //-----------------------------------------------------------------------------------------------------------------

        /// <summary>
        /// 胸設定値リセット
        /// </summary>
        public void ResetMuneParameter(List<Maid> maids)
        {
            var data = GetMuneDefaultValue();
            foreach (var maid in maids)
            {
                SetJiggleBone(maid, data);
            }   
        }

        public void ResetMuneParameter(Maid maid)
        {
            var data = GetMuneDefaultValue();
            SetJiggleBone(maid, data);
        }

        /// <summary>
        /// 胸設定値読込（共通）
        /// </summary>
        public void ReadCommonMuneParameter(List<Maid> maids)
        {
            CommonMuneData = ReadMuneData();
            if (!MyHelper.CheckNull(CommonMuneData))
            {
                if (CommonMuneData.Count() < MyConst.SWING_SETTING_COUNT)
                {
                    CommonMuneData = new List<MaidMuneSet>();
                    foreach (int i in Enumerable.Range(0, MyConst.SWING_SETTING_COUNT))
                    {
                        CommonMuneData.Add(GetMuneDefaultValue());
                    }
                }
                foreach (var maid in maids)
                {
                    SetJiggleBone(maid, CommonMuneData[CommonSaveIndex]);
                }
            }
        }

        /// <summary>
        /// 胸設定値読込（個別）
        /// </summary>
        public void ReadEachMuneParameter(List<Maid> maids)
        {
            EachMuneData = ReadMuneData();
            if (!MyHelper.CheckNull(EachMuneData))
            {
                if (EachMuneData.Count() < MyConst.SWING_SETTING_COUNT)
                {
                    EachMuneData = new List<MaidMuneSet>();
                    foreach (int i in Enumerable.Range(0, MyConst.SWING_SETTING_COUNT))
                    {
                        EachMuneData.Add(GetMuneDefaultValue());
                    }
                }
                foreach (var maid in maids)
                {
                    var size = maid.status.body.bust;
                    var data = EachMuneData.FirstOrDefault(d => d.minSize <= size && size <= d.maxSize);
                    if (!(data.minSize == 0 && data.maxSize == 0))
                    {
                        SetJiggleBone(maid, data);
                    }
                }
            }  
        }

        /// <summary>
        /// 胸設定保存（共通）
        /// </summary>
        public void SaveCommonMuneParameter()
        {
            if (!MyHelper.CheckNull(CommonMuneData))
            {
                new FileWriter().WriteCommonMuneData(CommonMuneData);
            }
        }

        /// <summary>
        /// 胸設定保存（個別）
        /// </summary>
        public void SaveEachMuneParameter()
        {
            if (!MyHelper.CheckNull(EachMuneData))
            {
                new FileWriter().WriteEachMuneData(EachMuneData);
            }
        }

        /// <summary>
        /// 胸設定値取得（共通・個別）
        /// </summary>
        private List<MaidMuneSet> ReadMuneData()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_SETTING_MAID_SWING, "");
            if (!string.IsNullOrEmpty(path))
            {
                if (IsEachSetting)
                {
                    return fReader.GetSettingOfMaidEachMune(path);
                }
                else
                {
                    return fReader.GetSettingOfMaidCommonMune(path);
                }
            }
            return null;
        }

        /// <summary>
        /// 胸設定
        /// </summary>
        private void SetJiggleBone(Maid maid, MaidMuneSet muneData)
        {
            var muneL = maid.body0.jbMuneL;
            var muneR = maid.body0.jbMuneR;

            muneL.bGravity = muneData.gravity;
            muneL.bDamping = muneData.damping;
            muneL.m_fMuneYawaraka = muneData.yawaraka;
            muneL.bStiffnessBRA[0] = muneData.maxStiffnessBra;
            muneL.bStiffnessBRA[1] = muneData.minStiffnessBra;
            muneL.bStiffness[0] = muneData.maxStiffness;
            muneL.bStiffness[1] = muneData.minStiffness;

            muneR.bGravity = muneData.gravity;
            muneR.bDamping = muneData.damping;
            muneR.m_fMuneYawaraka = muneData.yawaraka;
            muneR.bStiffnessBRA[0] = muneData.maxStiffnessBra;
            muneR.bStiffnessBRA[1] = muneData.minStiffnessBra;
            muneR.bStiffness[0] = muneData.maxStiffness;
            muneR.bStiffness[1] = muneData.minStiffness;
        }

        /// <summary>
        /// 胸初期値設定
        /// </summary>
        private MaidMuneSet GetMuneDefaultValue()
        {
            var data = new MaidMuneSet();
            data.gravity = MyConst.MUNE_GRAVITY_DEFAULT;
            data.damping = MyConst.MUNE_DAMPING_DEFAULT;
            data.yawaraka = MyConst.MUNE_YAWARAKA_DEFAULT;
            data.maxStiffness = MyConst.MUNE_MAX_STIFFNESS_DEFAULT;
            data.minStiffness = MyConst.MUNE_MIN_STIFFNESS_DEFAULT;
            data.maxStiffnessBra = MyConst.MUNE_MAX_STIFFNESS_BRA_DEFAULT;
            data.minStiffnessBra = MyConst.MUNE_MIN_STIFFNESS_BRA_DEFAULT;
            return data;
        }

        //-----------------------------------------------------------------------------------------------------------------

        /// <summary>
        /// 髪設定値リセット
        /// </summary>
        public void ResetHairParameter(List<Maid> maids)
        {
            foreach (var maid in maids)
            {
                ResetHairParameter(maid);
            }
        }

        public void ResetHairParameter(Maid maid)
        {
            var hairMgr = new HairManager();
            foreach (var key in MyConst.HAIR_TAG.Keys)
            {
                var name = hairMgr.GetHairMenuFileName(maid, true, key);
                if (string.IsNullOrEmpty(name))
                {
                    name = hairMgr.GetHairMenuFileName(maid, false, key);
                }
                hairMgr.SetTempHairMenu(maid, key, "");
                hairMgr.SetTempHairMenu(maid, key, name);
            }
        }

        /// <summary>
        /// 髪設定値読込（共通）
        /// </summary>
        public void ReadCommonHairParameter(List<Maid> maids)
        {
            CommonHairData = ReadCommonHairData();
            if (!MyHelper.CheckNull(CommonHairData))
            {
                foreach (var maid in maids)
                {
                    var boneDic = GetHairBone(maid);
                    if (!MyHelper.CheckNull(boneDic))
                    {
                        SetHairBoneParameter(boneDic, CommonHairData[CommonSaveIndex]);
                    }
                }
            }
        }

        /// <summary>
        /// 髪設定値読込（個別）
        /// </summary>
        public void ReadEachHairParameter(List<Maid> maids, int maidIndex)
        {
            var data = ReadEachHairData();
            if (!MyHelper.CheckNull(data))
            {
                if (maidIndex == MyConst.PRE_INDEX)
                {
                    foreach (var maid in maids)
                    {
                        SetEachHairBone(maid, data);
                    }
                }
                else
                {
                    SetEachHairBone(maids[maidIndex], data);
                }
            }
        }

        /// <summary>
        /// 髪設定保存（共通）
        /// </summary>
        public void SaveCommonHairParameter()
        {
            if (!MyHelper.CheckNull(CommonHairData))
            {
                new FileWriter().WriteCommonHairData(CommonHairData);
            }
        }

        /// <summary>
        /// 髪設定保存（個別）
        /// </summary>
        public void SaveEachHairParameter(Maid maid)
        {
            var hairDic = new Dictionary<string, DynamicBone>();
            var boneDic = GetHairBone(maid);
            if (!MyHelper.CheckNull(boneDic))
            {
                var menu = new Dictionary<string, string>();
                var menuDic = GetHairMenu(maid);
                if (!MyHelper.CheckNull(menuDic))
                {
                    foreach (var slot in boneDic.Keys)
                    {
                        var key = Enum.GetName(typeof(TBody.SlotID), slot);
                        hairDic[key] = boneDic[slot];
                        menu[key] = menuDic[slot];
                    }
                    if (!MyHelper.CheckNull(hairDic))
                    {
                        new FileWriter().WriteHairList(hairDic, menu);
                    }
                }
            }
        }

        /// <summary>
        /// 髪ボーン取得
        /// </summary>
        public Dictionary<TBody.SlotID, DynamicBone> GetHairBone(Maid maid)
        {
            var boneDic = new Dictionary<TBody.SlotID, DynamicBone>();
            foreach (var key in MyConst.HAIR_SLOT.Keys)
            {
                var obj = maid.body0.GetSlot((int)key).obj;
                if (obj != null)
                {
                    var b = obj.GetComponent<DynamicBone>();
                    if (b != null)
                    {
                        boneDic[key] = b;
                    }
                }
            }
            return boneDic;
        }

        /// <summary>
        /// 髪ボーン揺れ設定（GUI）
        /// </summary>
        public void SetGuiHairBone(DynamicBone bone, float value, int index)
        {
            switch (index)
            {
                case (int)MaidHairParam.Damping:
                    bone.m_Damping = value;
                    break;
                case (int)MaidHairParam.Elasticity:
                    bone.m_Elasticity = value;
                    break;
                case (int)MaidHairParam.Stiffness:
                    bone.m_Stiffness = value;
                    break;
                case (int)MaidHairParam.Inert:
                    bone.m_Inert = value;
                    break;
                case (int)MaidHairParam.Radius:
                    bone.m_Radius = value;
                    break;
            }
            bone.UpdateParameters();
        }

        /// <summary>
        /// 髪ボーン揺れ設定（個別）
        /// </summary>
        private void SetEachHairBone(Maid maid, Dictionary<string, Dictionary<string, DynamicBone>> hairDic)
        {
            var boneDic = GetHairBone(maid);
            if (!MyHelper.CheckNull(boneDic))
            {
                var menuDic = GetHairMenu(maid);
                if (!MyHelper.CheckNull(menuDic))
                {
                    var dic = new Dictionary<TBody.SlotID, DynamicBone>();
                    foreach (var slot in menuDic.Keys)
                    {
                        var key = Enum.GetName(typeof(TBody.SlotID), slot);
                        if (hairDic[key].ContainsKey(menuDic[slot]))
                        {
                            dic[slot] = hairDic[key][menuDic[slot]];
                        }
                    }
                    if (!MyHelper.CheckNull(dic))
                    {
                        SetHairBoneParameter(boneDic, dic);
                    }
                }
            }
        }

        /// <summary>
        /// 髪ボーン揺れ設定
        /// </summary>
        private void SetHairBoneParameter(Dictionary<TBody.SlotID, DynamicBone> boneDic, Dictionary<TBody.SlotID, DynamicBone> hairDic)
        {
            foreach (var slot in boneDic.Keys)
            {
                if (hairDic.ContainsKey(slot))
                {
                    foreach (MaidHairParam param in Enum.GetValues(typeof(MaidHairParam)))
                    {
                        switch (param)
                        {
                            case MaidHairParam.Damping:
                                boneDic[slot].m_Damping = hairDic[slot].m_Damping;
                                break;
                            case MaidHairParam.Elasticity:
                                boneDic[slot].m_Elasticity = hairDic[slot].m_Elasticity;
                                break;
                            case MaidHairParam.Stiffness:
                                boneDic[slot].m_Stiffness = hairDic[slot].m_Stiffness;
                                break;
                            case MaidHairParam.Inert:
                                boneDic[slot].m_Inert = hairDic[slot].m_Inert;
                                break;
                            case MaidHairParam.Radius:
                                boneDic[slot].m_Radius = hairDic[slot].m_Radius;
                                break;
                        }
                    }
                    boneDic[slot].UpdateParameters();
                }
            }
        }

        /// <summary>
        /// 髪設定値取得（共通）
        /// </summary>
        private List<Dictionary<TBody.SlotID, DynamicBone>> ReadCommonHairData()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_SETTING_MAID_SWING, "");
            if (!string.IsNullOrEmpty(path))
            {
                return fReader.GetSettingOfMaidCommonHair(path);
            }
            return null;
        }

        /// <summary>
        /// 髪設定値取得（個別、全部）
        /// </summary>
        private Dictionary<string, Dictionary<string, DynamicBone>> ReadEachHairData()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_HAIR, "");
            if (!string.IsNullOrEmpty(path))
            {
                return fReader.ReadMaidHairDataAll(path);
            }
            return null;
        }

        /// <summary>
        /// 髪初期値設定
        /// </summary>
        private Dictionary<TBody.SlotID, DynamicBone> GetHairDefaultValue()
        {
            var dic = new Dictionary<TBody.SlotID, DynamicBone>();
            foreach (var key in MyConst.HAIR_SLOT.Keys)
            {
                var data = new DynamicBone();
                data.m_Damping = MyConst.HAIR_DAMPING_DEFAULT;
                data.m_Elasticity = MyConst.HAIR_ELASTICITY_DEFAULT;
                data.m_Stiffness = MyConst.HAIR_STIFFNESS_DEFAULT;
                data.m_Inert = MyConst.SWING_COMMON_MIN;
                data.m_Radius = MyConst.HAIR_RADIUS_DEFAULT;
                dic[key] = data;
            }
            return dic;
        }

        /// <summary>
        /// 髪メニュー取得
        /// </summary>
        private Dictionary<TBody.SlotID, string> GetHairMenu(Maid maid)
        {
            var menuDic = new Dictionary<TBody.SlotID, string>();
            foreach (var key in MyConst.HAIR_SLOT.Keys)
            {
                var slot = Enum.GetName(typeof(TBody.SlotID), key);
                var name = maid.GetProp(slot.ToLower()).strFileName;
                if (!name.EndsWith(MyConst.ITEM_DEL_MENU_END))
                {
                    menuDic[key] = name;
                }
            }
            return menuDic;
        }

        //-----------------------------------------------------------------------------------------------------------------

        /// <summary>
        /// スカート設定値リセット
        /// </summary>
        public void ResetSkirtParameter(List<Maid> maids)
        {
            foreach (var maid in maids)
            {
                ResetSkirtParameter(maid);
            }
        }

        public void ResetSkirtParameter(Maid maid)
        {
            var dressMgr = new DressManager();
            foreach (var key in MyConst.HAIR_TAG.Keys)
            {
                var name = dressMgr.GetDressFileName(maid, true, key);
                if (string.IsNullOrEmpty(name))
                {
                    name = dressMgr.GetDressFileName(maid, false, key);
                }
                dressMgr.SetTempDress(maid, key, "");
                dressMgr.SetTempDress(maid, key, name);
            }
        }

        /// <summary>
        /// スカート設定値読込（共通）
        /// </summary>
        public void ReadCommonSkirtParameter(List<Maid> maids)
        {
            var skirtDic = ReadCommonSkirtData();
            if (!MyHelper.CheckNull(skirtDic))
            {
                foreach (var maid in maids)
                {
                    var boneDic = GetSkirtBone(maid);
                    if (!MyHelper.CheckNull(boneDic))
                    {
                        SetSkirtBoneParameter(boneDic, skirtDic[CommonSaveIndex]);
                    }
                }
            }
        }

        /// <summary>
        /// スカート設定値読込（個別）
        /// </summary>
        public void ReadEachSkirtParameter(List<Maid> maids, int maidIndex)
        {
            var data = ReadEachSkirtData();
            if (!MyHelper.CheckNull(data))
            {
                if (maidIndex == MyConst.PRE_INDEX)
                {
                    foreach (var maid in maids)
                    {
                        SetEachSkirtBone(maid, data);
                    }
                }
                else
                {
                    SetEachSkirtBone(maids[maidIndex], data);
                }
            }
        }

        /// <summary>
        /// スカート設定保存（共通）
        /// </summary>
        public void SaveCommonSkirtParameter()
        {
            if (!MyHelper.CheckNull(CommonSkirtData))
            {
                new FileWriter().WriteCommonSkirtData(CommonSkirtData);
            }
        }

        /// <summary>
        /// スカート設定保存（個別）
        /// </summary>
        public void SaveEachSkirtParameter(Maid maid)
        {
            var skirtDic = new Dictionary<string, DynamicSkirtBone>();
            var boneDic = GetSkirtBone(maid);
            if (!MyHelper.CheckNull(boneDic))
            {
                var menu = new Dictionary<string, string>();
                var menuDic = GetSkirtMenu(maid);
                if (!MyHelper.CheckNull(menuDic))
                {
                    foreach (var slot in boneDic.Keys)
                    {
                        var key = Enum.GetName(typeof(TBody.SlotID), slot);
                        skirtDic[key] = boneDic[slot];
                        menu[key] = menuDic[slot];
                    }
                    if (!MyHelper.CheckNull(skirtDic))
                    {
                        new FileWriter().WriteSkirtList(skirtDic, menu);
                    }
                }
            }
        }

        /// <summary>
        /// スカートボーン取得
        /// </summary>
        public Dictionary<TBody.SlotID, DynamicSkirtBone> GetSkirtBone(Maid maid)
        {
            var boneDic = new Dictionary<TBody.SlotID, DynamicSkirtBone>();
            foreach (var key in MyConst.SKIRT_SLOT.Keys)
            {
                var obj = maid.body0.GetSlot((int)key).obj;
                if (obj != null)
                {
                    var b = obj.GetComponent<DynamicSkirtBone>();
                    if (b != null)
                    {
                        boneDic[key] = b;
                    }
                }
            }
            return boneDic;
        }

        /// <summary>
        /// スカートボーン揺れ設定（GUI）
        /// </summary>
        public void SetGuiSkirtBone(DynamicSkirtBone bone, float value, int index)
        {
            switch (index)
            {
                case (int)MaidSkirtParam.Radius:
                    bone.m_fPanierRadius = value;
                    break;
                case (int)MaidSkirtParam.Velocity:
                    bone.m_fVelocityForceRate = value;
                    break;
                case (int)MaidSkirtParam.Force:
                    bone.m_fPanierForce = value;
                    break;
                case (int)MaidSkirtParam.RegRadius:
                    bone.m_fRegDefaultRadius = value;
                    break;
                case (int)MaidSkirtParam.Stiffness:
                    bone.m_fPanierStiffnessRate = value;
                    break;
                case (int)MaidSkirtParam.Stress:
                    bone.m_fPanierStressForce = value;
                    break;
                case (int)MaidSkirtParam.Threshold:
                    bone.m_fPanierForceDistanceThreshold = value;
                    break;
            }
            bone.UpdateParameters();
        }

        /// <summary>
        /// スカートボーン揺れ設定（個別）
        /// </summary>
        private void SetEachSkirtBone(Maid maid, Dictionary<string, Dictionary<string, DynamicSkirtBone>> skirtDic)
        {
            var boneDic = GetSkirtBone(maid);
            if (!MyHelper.CheckNull(boneDic))
            {
                var menuDic = GetSkirtMenu(maid);
                if (!MyHelper.CheckNull(menuDic))
                {
                    var dic = new Dictionary<TBody.SlotID, DynamicSkirtBone>();
                    foreach (var slot in menuDic.Keys)
                    {
                        var key = Enum.GetName(typeof(TBody.SlotID), slot);
                        if (skirtDic[key].ContainsKey(menuDic[slot]))
                        {
                            dic[slot] = skirtDic[key][menuDic[slot]];
                        }
                    }
                    if (!MyHelper.CheckNull(dic))
                    {
                        SetSkirtBoneParameter(boneDic, dic);
                    }
                }
            }
        }

        /// <summary>
        /// スカートボーン揺れ設定
        /// </summary>
        private void SetSkirtBoneParameter(Dictionary<TBody.SlotID, DynamicSkirtBone> boneDic, Dictionary<TBody.SlotID, DynamicSkirtBone> skirtDic)
        {
            foreach (var slot in boneDic.Keys)
            {
                if (skirtDic.ContainsKey(slot))
                {
                    foreach (MaidSkirtParam param in Enum.GetValues(typeof(MaidSkirtParam)))
                    {
                        switch (param)
                        {
                            case MaidSkirtParam.Radius:
                                boneDic[slot].m_fPanierRadius = skirtDic[slot].m_fPanierRadius;
                                break;
                            case MaidSkirtParam.Velocity:
                                boneDic[slot].m_fVelocityForceRate = skirtDic[slot].m_fVelocityForceRate;
                                break;
                            case MaidSkirtParam.Force:
                                boneDic[slot].m_fPanierForce = skirtDic[slot].m_fPanierForce;
                                break;
                            case MaidSkirtParam.RegRadius:
                                boneDic[slot].m_fRegDefaultRadius = skirtDic[slot].m_fRegDefaultRadius;
                                break;
                            case MaidSkirtParam.Stiffness:
                                boneDic[slot].m_fPanierStiffnessRate = skirtDic[slot].m_fPanierStiffnessRate;
                                break;
                            case MaidSkirtParam.Stress:
                                boneDic[slot].m_fPanierStressForce = skirtDic[slot].m_fPanierStressForce;
                                break;
                            case MaidSkirtParam.Threshold:
                                boneDic[slot].m_fPanierForceDistanceThreshold = skirtDic[slot].m_fPanierForceDistanceThreshold;
                                break;
                        }
                    }
                    boneDic[slot].UpdateParameters();
                }
            }
        }

        /// <summary>
        /// スカート設定値取得（共通）
        /// </summary>
        private List<Dictionary<TBody.SlotID, DynamicSkirtBone>> ReadCommonSkirtData()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_SETTING_MAID_SWING, "");
            if (!string.IsNullOrEmpty(path))
            {
                return fReader.GetSettingOfMaidCommonSkirt(path);
            }
            return null;
        }

        /// <summary>
        /// スカート設定値取得（個別、全部）
        /// </summary>
        private Dictionary<string, Dictionary<string, DynamicSkirtBone>> ReadEachSkirtData()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_SKIRT, "");
            if (!string.IsNullOrEmpty(path))
            {
                return fReader.ReadMaidSkirtDataAll(path);
            }
            return null;
        }

        /// <summary>
        /// スカート初期値設定
        /// </summary>
        private Dictionary<TBody.SlotID, DynamicSkirtBone> GetSkirtDefaultValue()
        {
            var dic = new Dictionary<TBody.SlotID, DynamicSkirtBone>();
            foreach (var key in MyConst.SKIRT_SLOT.Keys)
            {
                var data = new DynamicSkirtBone();
                data.m_fPanierRadius = MyConst.SKIRT_RADIUS_DEFAULT;
                data.m_fVelocityForceRate = MyConst.SKIRT_VELOCITY_DEFAULT;
                data.m_fPanierForce = MyConst.SKIRT_FORCE_DEFAULT;
                data.m_fRegDefaultRadius = MyConst.SKIRT_REG_RADIUS_DEFAULT;
                data.m_fPanierStiffnessRate = MyConst.SKIRT_STIFFNESS_DEFAULT;
                data.m_fPanierStressForce = MyConst.SKIRT_STRESS_DEFAULT;
                data.m_fPanierForceDistanceThreshold = MyConst.SKIRT_THRESHOLD_DEFAULT;
                dic[key] = data;
            }
            return dic;
        }

        /// <summary>
        /// スカートメニュー取得
        /// </summary>
        private Dictionary<TBody.SlotID, string> GetSkirtMenu(Maid maid)
        {
            var menuDic = new Dictionary<TBody.SlotID, string>();
            foreach (var key in MyConst.SKIRT_SLOT.Keys)
            {
                var slot = Enum.GetName(typeof(TBody.SlotID), key);
                var prop = maid.GetProp(slot.ToLower());
                var name = GuiIsTemp ? prop.strTempFileName : prop.strFileName;
                if (!string.IsNullOrEmpty(name) &&
                    !name.EndsWith(MyConst.ITEM_DEL_MENU_END))
                {
                    menuDic[key] = name;
                }
            }
            return menuDic;
        }
    }

    /// <summary>
    /// 歌モード処理管理
    /// </summary>
    public class SongManager
    {
        public AudioManager AudioMgr { get; set; }
        public SongType SongType { get; set; }
        public bool IsSong { get; set; }
        public bool IsKuchipakuInfo { get; set; }

        private Dictionary<int, List<SongCustomFacialSet>> facialDic;
        private Dictionary<int, List<SongPoseSet>> poseDic;
        private Dictionary<int, List<SongPoseSet>> manPoseDic;
        private Dictionary<int, List<SongMouthSet>> mouthDic;
        private Dictionary<string, byte[]> myPoseData;
        private Dictionary<int, int> poseIndex;
        private Dictionary<int, int> manPoseIndex;
        private Dictionary<int, int> mouthIndex;
        private Dictionary<int, int> facialIndex;
        private Dictionary<int, float> mouthLerpTime;
        private TimelineBoneManager boneMgr;
        private TimelineMorphManager morphMgr;
        private TimelineCameraManager cameraMgr;
        private MaidSongKupaSet kupaSet;

        /// <summary>
        /// コンストラクタ
        /// </summary
        public SongManager()
        {
            AudioMgr = new AudioManager();
        }

        /// <summary>
        /// 歌フォルダパス取得
        /// </summary
        public String GetSongFolder(string folderName)
        {
            return Path.Combine(MyConst.FOLDER_SONG, folderName);
        }

        /// <summary>
        /// くぱ設定
        /// </summary
        public void SetKupa(MaidSongKupaSet kupaSet)
        {
            this.kupaSet = kupaSet;
        }

        /// <summary>
        /// リストインデックス初期化
        /// </summary
        public void ResetIndex(List<Maid> maids, MaidManager maidMgr, bool isAll)
        {
            poseIndex = new Dictionary<int, int>();
            manPoseIndex = new Dictionary<int, int>();
            mouthIndex = new Dictionary<int, int>();
            facialIndex = new Dictionary<int, int>();
            mouthLerpTime = new Dictionary<int, float>();
            foreach (var maid in maids)
            {
                var slot = maidMgr.GetActiveSlotNo(maid);
                poseIndex[slot] = 0;
                mouthIndex[slot] = 0;
                facialIndex[slot] = 0;
                mouthLerpTime[slot] = 0f;
            }
            if (isAll)
            {
                mouthDic = new Dictionary<int, List<SongMouthSet>>();
                facialDic = new Dictionary<int, List<SongCustomFacialSet>>();
                poseDic = new Dictionary<int, List<SongPoseSet>>();
                ClearMyPoseData(maids);
                boneMgr = new TimelineBoneManager(true);
                morphMgr = new TimelineMorphManager(true);
                cameraMgr = new TimelineCameraManager(true);
            }
            if (!MyHelper.CheckNull(manPoseDic))
            {
                var count = GameMain.Instance.CharacterMgr.GetStockManCount();
                for (int i = 0; i < count; i++)
                {
                    manPoseIndex[i] = 0;
                }
            }
        }

        /// <summary>
        /// リストインデックス再設定
        /// </summary>
        public void SetRestartIndex(int slotNo, float bgmTime)
        {
            var index = 0;
            if (!MyHelper.CheckNull(poseDic) && poseDic.ContainsKey(slotNo))
            {
                foreach (var data in poseDic[slotNo])
                {
                    if (data.time <= bgmTime)
                    {
                        index++;
                    }
                    else
                    {
                        break;
                    }
                }
                poseIndex[slotNo] = index == 0 ? index : index - 1;
            }

            index = 0;
            if (!MyHelper.CheckNull(mouthDic) && mouthDic.ContainsKey(slotNo))
            {
                foreach (var data in mouthDic[slotNo])
                {
                    if (data.stTime + data.deltaTime <= bgmTime)
                    {
                        index++;
                    }
                    else
                    {
                        break;
                    }
                }
                mouthIndex[slotNo] = index == 0 ? index : index - 1;
                mouthLerpTime[slotNo] = 0;
            }

            index = 0;
            if (!MyHelper.CheckNull(facialDic) && facialDic.ContainsKey(slotNo))
            {
                foreach (var data in facialDic[slotNo])
                {
                    if (data.time <= bgmTime)
                    {
                        index++;
                    }
                    else
                    {
                        break;
                    }
                }
                facialIndex[slotNo] = index == 0 ? index : index - 1;
            }
        }

        /// <summary>
        /// リストインデックス有無確判定
        /// </summary
        public bool ExistSlotInFaceList(int slotNo)
        {
            var check = false;
            if (!MyHelper.CheckNull(facialIndex))
            {
                check = facialIndex.ContainsKey(slotNo);
            }
            return check;
        }

        /// <summary>
        /// ポーズ変更
        /// </summary>
        public void CrossFadeSongePose(Maid maid, float bgmTime, MaidManager maidMgr, TimeLinePlaySet tlPlaySet)
        {
            var isChanged = false;
            var slotNo = maidMgr.GetActiveSlotNo(maid);
            if (MyHelper.CheckNull(poseDic)) return;
            if (!poseDic.ContainsKey(slotNo)) return;
            var poseData = poseDic[slotNo];
            var index = poseIndex[slotNo];
            var isLastIndex = false;
            if (poseData.Count() <= poseIndex[slotNo])
            {
                isLastIndex = true;
                index--;
            }
            var data = poseData[index];

            if (data.time <= bgmTime && !isLastIndex)
            {
                isChanged = true;
                data.loopIndex = MyConst.PRE_INDEX;
                data.isFadeTime = data.poseType == (int)SongPoseType.TimeLineMotionLoop && 0 < data.fadeTime;
                tlPlaySet.isLoop = data.poseType == (int)SongPoseType.TimeLineMotionLoop;
                var extraMgr = new MaidExtraManager();
                if (!string.IsNullOrEmpty(data.option))
                {
                    if (data.option.Contains(MyConst.SONG_OPTION_BREATH_ON))
                    {
                        extraMgr.SetBreath(maid, true);
                    }
                    else if (data.option.Contains(MyConst.SONG_OPTION_BREATH_OFF))
                    {
                        extraMgr.SetBreath(maid, false);
                    }
                    if (data.option.Contains(MyConst.SONG_OPTION_KUPA_ON))
                    {
                        maidMgr.SetVertexMorphFromProcItem(maid, MyConst.BODY_TAG_KUPA, kupaSet.kupaSize);
                    }
                    else if (data.option.Contains(MyConst.SONG_OPTION_KUPA_OFF))
                    {
                        maidMgr.SetVertexMorphFromProcItem(maid, MyConst.BODY_TAG_KUPA, 0f);
                    }
                    if (data.option.Contains(MyConst.SONG_OPTION_ANALKUPA_ON))
                    {
                        maidMgr.SetVertexMorphFromProcItem(maid, MyConst.BODY_TAG_ANALKUPA, kupaSet.analkupaSize);
                    }
                    else if (data.option.Contains(MyConst.SONG_OPTION_ANALKUPA_OFF))
                    {
                        maidMgr.SetVertexMorphFromProcItem(maid, MyConst.BODY_TAG_ANALKUPA, 0f);
                    }
                }
                if (data.poseType == (int)SongPoseType.TimeLineMotion)
                {
                    maidMgr.StopAnimation(maid);
                }
                poseIndex[slotNo]++;
            }
            else if (index != 0 && !isLastIndex)
            {
                index--;
                data = poseData[index];
                if (data.isFadeTime && data.time + data.fadeTime <= bgmTime)
                {
                    isChanged = true;
                    data.isFadeTime = false;
                }
            }

            var poseType = data.poseType;
            var animation = data.animation;
            var fadeTime = data.fadeTime;
            var pos = data.position;
            var rot = data.rotation;
            if (data.poseType == (int)SongPoseType.MyPoseLoop && !MyHelper.CheckNull(data.loopData))
            {
                if (data.loopIndex == MyConst.PRE_INDEX ||
                    data.loopData[data.loopIndex].fadeTime <= data.loopTime)
                {
                    data.loopTime = 0f;
                    data.loopIndex++;
                    if (data.loopData.Count() <= data.loopIndex)
                    {
                        data.loopIndex = 0;
                    }
                    isChanged = true;
                    animation = data.loopData[data.loopIndex].animation;
                    fadeTime = data.loopData[data.loopIndex].fadeTime;
                    pos = data.loopData[data.loopIndex].position;
                    rot = data.loopData[data.loopIndex].rotation;
                }
                else
                {
                    data.loopTime += Time.deltaTime;
                }
            }

            if (poseType == (int)SongPoseType.TimeLineMotion)
            {
                ChangeSongBoneData(bgmTime, maid, slotNo, tlPlaySet);
            }
            else if (isChanged)
            {
                switch (poseType)
                {
                    case (int)SongPoseType.MyPose:
                    case (int)SongPoseType.MyPoseLoop:
                        maidMgr.CrossFadeMyPose(maid, animation, myPoseData[animation], poseType == (int)SongPoseType.MyPoseLoop, fadeTime);
                        break;
                    case (int)SongPoseType.TimeLineMotionLoop:
                        maidMgr.StopAnimation(maid);
                        if (data.isFadeTime)
                        {
                            boneMgr.SetSongFadeData(maid, slotNo, animation, fadeTime);
                        }
                        else
                        {
                            boneMgr.ChangeSongData(slotNo, animation, data.speed);
                        }
                        break;
                    default:
                        var isLoop = true;
                        var isCM3D2D = false;
                        var isCrossFade = true;
                        if (index > 0)
                        {
                            AnimationState state = maidMgr.GetAnimationState(maid);
                            if (state != null)
                            {
                                isCrossFade = animation != state.name;
                            }
                        }
                        if (isCrossFade)
                        {
                            if (poseType == (int)SongPoseType.AnimationNoLoop || poseType == (int)SongPoseType.OldAnimationNoLoop ||
                                poseType == (int)SongPoseType.DanceAnimationTime || poseType == (int)SongPoseType.OldDanceAnimationTime)
                            {
                                isLoop = false;
                            }
                            if (poseType == (int)SongPoseType.OldAnimation || poseType == (int)SongPoseType.OldAnimationNoLoop ||
                                poseType == (int)SongPoseType.OldDanceAnimationTime)
                            {
                                isCM3D2D = true;
                            }
                            maidMgr.CrossFadeAnimation(maid, animation, isLoop, isCM3D2D, fadeTime);
                        }
                        break;
                }
                maidMgr.SetSongPosition(maid, pos, rot);
                if ((int)data.eyeMoveType >= 0)
                {
                    maidMgr.SetEyeToCamera(maid, data.eyeMoveType);
                }
            }
            else if (poseType == (int)SongPoseType.TimeLineMotionLoop)
            {
                tlPlaySet.isLoop = !data.isFadeTime;
                tlPlaySet.fromFrame = MyConst.PRE_INDEX;
                ChangeSongBoneData(bgmTime, maid, slotNo, tlPlaySet);
            }

            if (poseType != (int)SongPoseType.TimeLineMotionLoop && 
                poseType != (int)SongPoseType.TimeLineMotion &&
                poseType != (int)SongPoseType.Combination)
            {
                AnimationState state = maidMgr.GetAnimationState(maid);
                if (state != null)
                {
                    if (state.speed != data.speed)
                    {
                        state.speed = data.speed;
                    }
                    if (0 < data.startTime &&
                       (poseType == (int)SongPoseType.DanceAnimationTime || poseType == (int)SongPoseType.OldDanceAnimationTime ||
                        poseType == (int)SongPoseType.MyPose || poseType == (int)SongPoseType.MyPoseLoop))
                    {
                        var adjustmentTime = 0 < bgmTime - data.time ? bgmTime - data.time : 0f;
                        adjustmentTime = data.startTime + adjustmentTime * data.speed;
                        if (MyConst.ADJUST_DANCE_TIME <= Mathf.Abs(adjustmentTime - state.time))
                        {
                            state.time = adjustmentTime;
                        }
                    }
                }
            }

            poseData[index] = data;
            poseDic[slotNo] = poseData;
        }

        /// <summary>
        /// 蓄積ポースクリア
        /// </summary>
        public void ClearMyPoseData(List<Maid> maids)
        {
            var maidMgr = new MaidManager();
            foreach (var maid in maids)
            {
                maidMgr.RemoveAnimationClip(maid);
            }
            MyHelper.ClearDictionary(myPoseData);
            myPoseData = new Dictionary<string, byte[]>();
        }

        /// <summary>
        /// ポーズデータ取得
        /// </summary>
        public void GetSongPoseData(FreeSongSet songSet, int slotNo)
        {
            var fReader = new FileReader();
            var path = "";
            var poseData = new List<SongPoseSet>();
            var loopData = new List<SongLoopPoseSet>();

            if (songSet.isTlBone)
            {
                for (int i = 0; i < 2; i++)
                {
                    var p = new SongPoseSet();
                    p.time = i * 999;
                    p.poseType = (int)(songSet.isCustomAnm ? SongPoseType.Combination : SongPoseType.TimeLineMotion);
                    p.animation = songSet.pose;
                    p.speed = MyConst.ANIMATION_SPEED;
                    p.eyeMoveType = (Maid.EyeMoveType)MyConst.ENUM_EX_VALUE;
                    p.option = "";
                    p.loopIndex = MyConst.PRE_INDEX;
                    p.loopData = new List<SongLoopPoseSet>();
                    poseData.Add(p);
                }
            }
            else
            {
                path = fReader.GetFilePath(songSet.pose, GetSongFolder(songSet.folder));
                if (string.IsNullOrEmpty(path))
                {
                    return;
                }
                poseData = fReader.ReadSongPoseData(path);
                if (MyHelper.CheckNull(poseData))
                {
                    return;
                }
                path = fReader.GetFilePath(songSet.poseLoop, GetSongFolder(songSet.folder));
                if (!string.IsNullOrEmpty(path))
                {
                    loopData = fReader.ReadSongLoopPoseData(path);
                }
            }

            for (int i = 0; i < poseData.Count(); i++)
            {
                var data = poseData[i];
                if (data.poseType == (int)SongPoseType.MyPoseLoop)
                {
                    if (!MyHelper.CheckNull(loopData))
                    {
                        foreach (var d in loopData.Where(d => d.loopName == data.animation).OrderBy(d => d.loopNo))
                        {
                            data.loopData.Add(d);
                        }
                        poseData[i] = data;
                        foreach (var d in data.loopData)
                        {
                            ReadMyPoseData(songSet.folder, d.animation, false);
                        }
                    }
                    else
                    {
                        ReadMyPoseData(songSet.folder, data.animation, false);
                    }
                }
                else if (data.poseType == (int)SongPoseType.MyPose)
                {
                    ReadMyPoseData(songSet.folder, data.animation, false);
                }
                else if (data.poseType == (int)SongPoseType.TimeLineMotionLoop ||
                         data.poseType == (int)SongPoseType.TimeLineMotion ||
                         data.poseType == (int)SongPoseType.Combination)
                {
                    var folder = songSet.folder;
                    if (songSet.isCommonPose)
                    {
                        folder = MyConst.FOLDER_TIMELINE_COMMON;
                    }
                    boneMgr.SetSongData(folder, data.animation, slotNo);
                }
            }
            poseDic[slotNo] = poseData;
        }

        /// <summary>
        /// 歌口パク設定
        /// </summary
        public void SetSongKuchipaku(FreeSongSet songSet, int slotNo)
        {
            var mouthData = new List<SongMouthSet>();
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_MOUTH, "");
            var songPath = fReader.GetFilePath(songSet.lyrics, GetSongFolder(songSet.folder));
            if (!string.IsNullOrEmpty(path) && !string.IsNullOrEmpty(songPath))
            {
                var dic = fReader.ReadSongMouthMorphData(path);
                var data = fReader.ReadSongMouthData(songPath);
                foreach (var d in data)
                {
                    var isFirst = true;
                    foreach (var c in d.character)
                    {
                        var key = c.ToString();
                        var mouth = new SongMouthSet();
                        var isKey = dic.ContainsKey(key);
                        var deltaTime = 60f / songSet.metronome * (MyConst.BASE_NOTE / (float)songSet.baseNote);

                        if (!isFirst && isKey)
                        {
                            var m = mouthData[mouthData.Count() - 1];
                            mouth.character = key;
                            mouth.stTime = m.stTime + m.deltaTime;
                            mouth.deltaTime = deltaTime * 0.2f;
                            mouth.stMouth = m.edMouth;
                            mouth.edMouth = dic[key].stMouth;
                            mouth.mouthMorph = dic[key].mouthMorph;
                            mouthData.Add(mouth);
                            mouth = new SongMouthSet();
                        }

                        if (isFirst)
                        {
                            mouth.stTime = d.stTime + deltaTime * 0.2f;
                            mouth.deltaTime = deltaTime * 0.8f;
                            if (isKey)
                            {
                                mouth.edMouth = dic[key].edMouth;
                                mouth.mouthMorph = dic[key].mouthMorph;
                            }
                            isFirst = false;
                        }
                        else
                        {
                            var m = mouthData[mouthData.Count() - 1];
                            mouth.stTime = m.stTime + m.deltaTime;
                            if (isKey)
                            {
                                mouth.deltaTime = deltaTime * 0.8f;
                                mouth.stMouth = dic[key].stMouth;
                                mouth.edMouth = dic[key].edMouth;
                                mouth.mouthMorph = dic[key].mouthMorph;
                            }
                            else
                            {
                                mouth.deltaTime = deltaTime;
                                mouth.stMouth = m.edMouth;
                                mouth.edMouth = mouth.stMouth;
                                mouth.mouthMorph = m.mouthMorph;
                            }
                        }
                        mouth.character = key;
                        mouthData.Add(mouth);
                    }
                }
            }
            mouthDic[slotNo] = mouthData;
        }

        /// <summary>
        /// 歌口パク実行
        /// </summary
        public void PlaySongKuchipaku(Maid maid, float bgmTime, int slotNo)
        {
            if (MyHelper.CheckNull(mouthDic))
            {
                return;
            }
            if (mouthDic.ContainsKey(slotNo))
            {
                var morph = maid.body0.Face.morph;
                if (mouthIndex[slotNo] < mouthDic[slotNo].Count())
                {
                    var data = mouthDic[slotNo][mouthIndex[slotNo]];
                    if (data.stTime + data.deltaTime <= bgmTime ||
                        mouthIndex[slotNo] + 1 < mouthDic[slotNo].Count() &&
                        mouthDic[slotNo][mouthIndex[slotNo] + 1].stTime <= bgmTime)
                    {
                        mouthLerpTime[slotNo] = 0f;
                        mouthIndex[slotNo]++;

                        if (IsKuchipakuInfo &&
                            mouthIndex[slotNo] < mouthDic[slotNo].Count())
                        {
                            var c1 = mouthDic[slotNo][mouthIndex[slotNo] - 1].character;
                            var c2 = mouthDic[slotNo][mouthIndex[slotNo]].character;
                            if (c1 != c2)
                            {
                                Console.WriteLine(bgmTime + " / " + c2);
                            }
                        }
                    }
                }

                if (mouthIndex[slotNo] < mouthDic[slotNo].Count())
                {
                    var data = mouthDic[slotNo][mouthIndex[slotNo]];
                    if (data.stTime <= bgmTime && bgmTime < data.stTime + data.deltaTime && !MyHelper.CheckNull(data.mouthMorph))
                    {
                        mouthLerpTime[slotNo] += Mathf.Clamp01(1 / data.deltaTime * Time.deltaTime);
                        var pos = Vector3.Lerp(data.stMouth, data.edMouth, mouthLerpTime[slotNo]);
                        foreach (var key in MyConst.MOUTH_MORPH.Keys)
                        {
                            switch (key)
                            {
                                case "moutha":
                                    data.mouthMorph[key] = pos.x;
                                    break;
                                case "mouthi":
                                    data.mouthMorph[key] = pos.y;
                                    break;
                                case "mouthc":
                                    data.mouthMorph[key] = pos.z;
                                    break;
                            }
                            morph.SetBlendValues((int)morph.hash[key], data.mouthMorph[key]);
                            //morph.BlendValues[(int)morph.hash[val]] = data.mouthMorph[val] + fValue;
                        }
                    }
                    else
                    {
                        foreach (var key in MyConst.MOUTH_MORPH.Keys)
                        {
                            morph.SetBlendValues((int)morph.hash[key], 0f);
                        }
                    }
                    morph.FixBlendValues_Face();
                }
                else
                {
                    ResetSongKuchipaku(maid);
                }
            }
        }

        /// <summary>
        /// 歌口パクリセット
        /// </summary
        public void ResetSongKuchipaku(Maid maid)
        {
            var morph = maid.body0.Face.morph;
            foreach (var key in MyConst.MOUTH_MORPH.Keys)
            {
                morph.SetBlendValues((int)morph.hash[key], 0f);
            }
            morph.FixBlendValues_Face();
        }

        /// <summary>
        /// マイポーズデータ読み込み
        /// </summary
        public byte[] GetMyPoseData(string folder, string key, bool isCustomAnm)
        {
            ReadMyPoseData(folder, key, isCustomAnm);
            return myPoseData[key];
        }

        /// <summary>
        /// マイポーズデータ読み込み
        /// </summary
        private bool ReadMyPoseData(string folder, string key, bool isCustomAnm)
        {
            if (!myPoseData.ContainsKey(key))
            {
                folder = Path.Combine(isCustomAnm ? MyConst.FOLDER_SONG : MyConst.FOLDER_MYPOSE, folder);
                var path = new FileReader().GetFilePath(key, folder);
                if (string.IsNullOrEmpty(path) || !File.Exists(path))
                {
                    Console.WriteLine("マイポーズファイルがありません：" + path);
                }
                else
                {
                    myPoseData[key] = new FileReader().ReadBinary(path);
                    return true;
                }
            }
            return false;
        }

        /// --------------------------------------------------------------------------------

        /// <summary>
        /// タイムラインボーン更新(スライダー)
        /// </summary
        public void SetSongBoneData(Maid maid, int slotNo)
        {
            boneMgr.SetPlayingBone(maid, slotNo, true);
        }

        /// <summary>
        /// タイムラインボーン更新
        /// </summary
        public void ChangeSongBoneData(float bgmTime, Maid maid, int slotNo, TimeLinePlaySet tlPlaySet)
        {
            if (tlPlaySet.fromFrame == 0)
            {
                boneMgr.SetSongPlatyTime(slotNo, bgmTime);
            }
            boneMgr.UpdatePlayBone(maid, slotNo, tlPlaySet);
        }

        /// <summary>
        /// タイムライン表情データ取得
        /// </summary
        public void GetSongMorphData(string folder, string fileName, int slotNo)
        {
            morphMgr.ReadMorphData(slotNo, Path.Combine(folder, fileName));
        }

        /// <summary>
        /// タイムライン表情変更(スライダー)
        /// </summary
        public void SetSongMorphData(Maid maid, int slotNo)
        {
            morphMgr.SetPlayingMorph(maid, slotNo, true);
        }

        /// <summary>
        /// タイムライン表情変更
        /// </summary
        public void ChangeSongMorphData(float bgmTime, Maid maid, int slotNo, TimeLinePlaySet tlPlaySet)
        {
            if (tlPlaySet.fromFrame == 0)
            {
                morphMgr.SetSongPlatyTime(slotNo, bgmTime);
            }
            morphMgr.UpdatePlayMorph(maid, slotNo, tlPlaySet);
        }

        /// <summary>
        /// タイムラインカメラデータ取得(フリーダンス)
        /// </summary
        public bool GetSongCameraData(string folder, string fileName)
        {
            return cameraMgr.ReadCameraData(fileName, folder);
        }

        /// <summary>
        /// タイムラインカメラ変更
        /// </summary
        public void ChangeSonCameraData(float bgmTime)
        {
            var isAdjusted = cameraMgr.SetSongPlatyTime(bgmTime);
            cameraMgr.UpdatePlayCamera(new TimeLinePlaySet(), isAdjusted);
        }

        /// <summary>
        /// タイムラインカメラ更新（フリーダンス）
        /// </summary
        public void SetTimelineCameraTransform(CameraManager mainCameraMgr, bool isViewAngle, Vector3 adjustmentPosition)
        {
            var position = Vector3.zero;
            var rotation = Vector3.zero;
            var viewAngle = 0f;
            cameraMgr.GetSelectedFrameTransform(ref position, ref rotation, ref viewAngle);
            mainCameraMgr.SetTimelineCameraTransform(position, rotation, isViewAngle, viewAngle);
            if(adjustmentPosition != Vector3.zero)
            {
                position += new CameraManager().AdjustPosition(adjustmentPosition, MyHelper.GetCameraMainTransform());
                mainCameraMgr.SetTimelineCameraTransform(position, rotation, false, viewAngle);
            }
        }

        /// --------------------------------------------------------------------------------

        /// <summary>
        /// リストインデックス再設定（男）
        /// </summary>
        public void SetRestartIndexMan(float bgmTime)
        {

            if (!MyHelper.CheckNull(manPoseDic))
            {
                var slotNo = 0;
                foreach (var pose in manPoseDic.Values)
                {
                    var index = 0;
                    foreach (var data in pose)
                    {
                        if (data.time <= bgmTime)
                        {
                            index++;
                        }
                        else
                        {
                            break;
                        }
                    }
                    manPoseIndex[slotNo] = index == 0 ? index : index - 1;
                    slotNo++;
                }
            }
        }

        /// <summary>
        /// 男ポーズデータ取得
        /// </summary>
        public void GetSongManPoseData(List<FreeSongManSet> manData)
        {
            manPoseDic = new Dictionary<int, List<SongPoseSet>>();
            foreach (var data in manData)
            {
                var fReader = new FileReader();
                var path = Path.Combine(MyHelper.RootFolder, data.pose);
                manPoseDic[data.slotNo] = fReader.ReadSongPoseData(path);
            }
        }

        /// <summary>
        /// アクティブ男取得
        /// </summary>
        private List<Maid> GetActiveMans()
        {
            var mans = new List<Maid>();
            var mgr = GameMain.Instance.CharacterMgr;
            for (int i = 0; i < mgr.GetStockManCount(); i++)
            {
                var man = mgr.GetStockMan(i);
                if (man.isActiveAndEnabled)
                {
                    mans.Add(man);
                }
            }
            return mans;
        }

        /// <summary>
        /// 開始時男設定
        /// </summary>
        public void SetStartedMan(List<FreeSongManSet> manData)
        {
            if (MyHelper.CheckNull(manPoseDic)) return;
            var mans = GetActiveMans();
            if (MyHelper.CheckNull(mans)) return;
            foreach(var man in mans)
            {
                foreach (var data in manData)
                {
                    if (data.slotNo == man.ActiveSlotNo)
                    {
                        man.SetPos(data.position);
                        man.SetRot(data.rotation);
                    }
                }
            }
        }

        /// <summary>
        /// 終了時男設定
        /// </summary>
        public void SetEndedMan()
        {
            if (MyHelper.CheckNull(manPoseDic)) return;
            MyHelper.ClearDictionary(manPoseDic);
            var mans = GetActiveMans();
            if (MyHelper.CheckNull(mans)) return;
            foreach (var man in mans)
            {
                man.CrossFade(MyConst.DEFAULT_MAN_ANIME, false, true, false, 0f, 1f);
                man.SetPos(Vector3.zero);
                man.SetRot(Vector3.zero);
            }
        }

        /// <summary>
        /// 停止時男設定
        /// </summary>
        public void SetStopedMan(bool isStoped)
        {
            if (MyHelper.CheckNull(manPoseDic)) return;
            var mans = GetActiveMans();
            if (MyHelper.CheckNull(mans)) return;
            var maidMgr = new MaidManager();
            foreach (var man in mans)
            {
                AnimationState state = maidMgr.GetAnimationState(man);
                if (state != null)
                {
                    if (state.enabled)
                    {
                        state.speed = isStoped ? 0f : MyConst.NORMAL_ANIMATION_SPEED;
                    }
                }

            }
        }

        /// <summary>
        /// ポーズ変更（男）
        /// </summary>
        public void CrossFadeManSongePose(float bgmTime)
        {
            if (MyHelper.CheckNull(manPoseDic)) return;
            var mans = GetActiveMans();
            if (MyHelper.CheckNull(mans)) return;
            var maidMgr = new MaidManager();

            foreach (var man in mans)
            {
                var slotNo = man.ActiveSlotNo;
                if (!manPoseDic.ContainsKey(slotNo))
                {
                    continue;
                }

                var isChanged = false;
                var mgr = GameMain.Instance.CharacterMgr;
                var index = manPoseIndex[slotNo];
                var count = manPoseDic[slotNo].Count();
                if (count <= index)
                {
                    index = count - 1;
                }

                var data = manPoseDic[slotNo][index];
                if (data.time <= bgmTime)
                {
                    isChanged = true;
                    manPoseIndex[slotNo]++;
                }
                else if (index != 0 && index != count)
                {
                    index--;
                    data = manPoseDic[slotNo][index];
                }

                if (isChanged)
                {
                    var isLoop = true;
                    var isCM3D2D = false;
                    var isCrossFade = true;
                    if (0 < index)
                    {
                        AnimationState state = maidMgr.GetAnimationState(man);
                        if (state != null)
                        {
                            isCrossFade = data.animation != state.name;
                        }
                    }
                    if (isCrossFade)
                    {
                        if (data.poseType == (int)SongPoseType.AnimationNoLoop || data.poseType == (int)SongPoseType.OldAnimationNoLoop)
                        {
                            isLoop = false;
                        }
                        if (data.poseType == (int)SongPoseType.OldAnimation || data.poseType == (int)SongPoseType.OldAnimationNoLoop)
                        {
                            isCM3D2D = true;
                        }
                        maidMgr.CrossFadeAnimation(man, data.animation, isLoop, isCM3D2D, data.fadeTime);
                    }
                    man.SetPos(data.position);
                    man.SetRot(data.rotation);
                }

                if (data.speed != MyConst.NORMAL_ANIMATION_SPEED)
                {
                    AnimationState state = maidMgr.GetAnimationState(man);
                    if (state != null)
                    {
                        if (state.enabled && state.speed != data.speed &&  state.speed != 0)
                        {
                            state.speed = data.speed;
                        }
                    }
                }
            }
        }
    }

    /// <summary>
    /// 楽曲処理管理
    /// </summary>
    public class AudioManager
    {
        private AudioSourceMgr audioMgr;

        /// <summary>
        /// 楽曲読込
        /// </summary>
        public bool LoadAndPlayAudioClip(string folderPath, string fileName)
        {
            var path = new FileReader().GetFilePath(fileName, folderPath);
            var ext = Path.GetExtension(path);
            if (string.IsNullOrEmpty(path) || !File.Exists(path) ||
                (ext != MyConst.EXTENSION_OGG && ext != MyConst.EXTENSION_WAV))
            {
                if (!string.IsNullOrEmpty(path))
                {
                    Console.WriteLine(string.Format("{0}または{1}ファイルを指定してください。{2}", MyConst.EXTENSION_OGG, MyConst.EXTENSION_WAV, path));
                }
                return false;
            }

            var isLoaded = false;
            using (var www = new WWW(MyConst.PATH_WWW + path))
            {
                var timer = 0;
                while (!www.isDone)
                {
                    Thread.Sleep(MyConst.SLEEP_TIME);
                    timer += MyConst.SLEEP_TIME;
                    if (MyConst.SLEEP_TIME_OOUT < timer)
                    {
                        Console.WriteLine("音声読込タイムアウトのため処理を中止します。");
                        return false;
                    }
                }
                var audioClip = www.GetAudioClip();
                if (audioClip.loadState == AudioDataLoadState.Loaded)
                {
                    if (audioMgr == null)
                    {
                        AudioSourceMgr[] componentsInChildren = GameMain.Instance.MainCamera.gameObject.GetComponentsInChildren<AudioSourceMgr>();
                        audioMgr = componentsInChildren.FirstOrDefault(a => a.SoundType == AudioSourceMgr.Type.Bgm);
                    }
                    if (audioMgr != null)
                    {
                        audioMgr.audiosource.clip = audioClip;
                        audioMgr.audiosource.loop = false;
                        isLoaded = true;
                    }
                }
            }
            return isLoaded;
        }

        /// <summary>
        /// 楽曲タイム設定
        /// </summary>
        public void SetAudioClipTime(float bgmTime)
        {
            audioMgr.audiosource.time = bgmTime;
        }

        /// <summary>
        /// ダンスBGMボリューム設定
        /// </summary>
        public void SetVolumeDance(int volume)
        {
            var mgr = GameMain.Instance.SoundMgr;
            audioMgr.audiosource.outputAudioMixerGroup = mgr.mix_mgr[AudioMixerMgr.Group.Dance];
            audioMgr.audiosource.volume = volume;
            audioMgr.audiosource.mute = false;
            mgr.SetVolumeDance(volume);
            mgr.Apply();
        }

        /// <summary>
        /// 楽曲タイム取得
        /// </summary>
        public float GetAudioClipTime()
        {
            return audioMgr.audiosource.time;
        }

        /// <summary>
        /// 楽曲総タイム取得
        /// </summary>
        public float GetAudioClipLength()
        {
            return audioMgr.audiosource.clip.length;
        }

        /// <summary>
        /// 楽曲再生
        /// </summary>
        public void PlayAudioClip()
        {
            if (audioMgr != null)
            {
                audioMgr.audiosource.Play();
            }
        }

        /// <summary>
        /// 楽曲停止
        /// </summary>
        public void StopAudioClip()
        {
            if (audioMgr != null)
            {
                audioMgr.audiosource.Stop();
            }
        }

        /// <summary>
        /// 楽曲一時停止
        /// </summary>
        public void PauseAudioClip()
        {
            if (audioMgr != null)
            {
                audioMgr.audiosource.Pause();
            }
        }

        /// <summary>
        /// 楽曲一時停止解除
        /// </summary>
        public void UnPauseAudioClip()
        {
            if (audioMgr != null)
            {
                audioMgr.audiosource.UnPause();
            }
        }
    }

    /// <summary>
    /// カメラ処理管理
    /// </summary>
    public class CameraManager
    {
        public List<string> AutoCameraList { get; set; }
        public AutoCameraSet AutoCamera { get; set; }
        public Vector3 CurrentPosition { get; set; }
        public Vector3 CurrentRotation { get; set; }
        public bool IsZoom { get; set; }
        public bool IsCustome { get; set; }
        public bool IsAutoCamera { get; set; }
        public float ZoomSlider { get; set; }
        public int AutoCameraListIndex { get; set; }

        private float lerpTime = 0f;
        private int motionDataIndex = 0;

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public CameraManager()
        {
            IsZoom = false;
            ZoomSlider = MyConst.ZOOM_DEFAULT;
            AutoCameraList = new List<string>();
        }

        /// <summary>
        /// メインカメラ位置設定
        /// </summary
        public void SetMainCameraTransform(Vector3 position, Vector3 rotation)
        {
            SetCameraTransform(position, rotation, MyHelper.GetCameraMainTransform());
        }

        /// <summary>
        /// カメラ位置設定
        /// </summary
        public void SetCameraTransform(Vector3 position, Vector3 rotation, Transform tm)
        {
            CurrentPosition = position;
            CurrentRotation = rotation;
            tm.position = position;
            tm.rotation = Quaternion.Euler(rotation);
        }

        /// <summary>
        /// 初期化
        /// </summary
        public void Initialize()
        {
            lerpTime = 0f;
            motionDataIndex = 0;
        }

        /// <summary>
        /// タイムラインカメラ位置設定
        /// </summary
        public void SetTimelineCameraTransform(Vector3 position, Vector3 rotation, bool isViewAngle, float viewAngle)
        {
            SetMainCameraTransform(position, rotation);
            if (isViewAngle && IsZoom)
            {
                AddZoomSlider(ref viewAngle);
            }
            ZoomCamera(viewAngle);
        }

        /// <summary>
        /// メインカメラ位置取得
        /// </summary
        public void SetMainCameraCurrentTransform()
        {
            var tm = MyHelper.GetCameraMainTransform();
            CurrentPosition = tm.position;
            CurrentRotation = tm.eulerAngles;
        }

        /// <summary>
        /// カメラ移動・回転
        /// </summary
        public void TransformMotionCamera(DanceCameraMotionSet screenSet, float bgmTime, Vector3 adjustmentPosition, bool isScreenOnOff)
        {
            if (MyHelper.CheckNull(screenSet.motionData))
            {
                return;
            }
            else if (screenSet.motionData.Count() <= motionDataIndex)
            {
                return;
            }
            var count = screenSet.motionData.Count();
            if (screenSet.motionData[motionDataIndex].edTime <= bgmTime)
            {
                lerpTime = 0;
                motionDataIndex++;
                while (motionDataIndex < count)
                {
                    if (bgmTime < screenSet.motionData[motionDataIndex].edTime)
                    {
                        break;
                    }
                    motionDataIndex++;
                }
            }
            if (motionDataIndex < count &&
                screenSet.motionData[motionDataIndex].stTime <= bgmTime &&
                bgmTime < screenSet.motionData[motionDataIndex].edTime)
            {
                var mData = screenSet.motionData[motionDataIndex];
                if(screenSet.isScreen && isScreenOnOff)
                {
                    if(mData.easingType == MyConst.DANCE_SCREEN_OFF)
                    {
                        screenSet.plane.SetActive(false);
                        return;
                    }
                    screenSet.plane.SetActive(true);
                }
                var deltaTime = bgmTime - mData.stTime;
                if (lerpTime == 0 && 1 <= deltaTime)
                {
                    lerpTime = Mathf.Clamp01(deltaTime / mData.deltaTime);
                }
                else
                {
                    lerpTime += Mathf.Clamp01(1 / mData.deltaTime * Time.deltaTime);
                }

                var tl = new Timeline(false);
                var stVec = mData.transform.stPos;
                var edVec = mData.transform.edPos;
                stVec.z += screenSet.addtionalPositionZ;
                edVec.z += screenSet.addtionalPositionZ;
                var x = tl.GetEasingPosition(lerpTime, mData.easingType, stVec.x, edVec.x);
                var y = tl.GetEasingPosition(lerpTime, mData.easingType, stVec.y, edVec.y);
                var z = tl.GetEasingPosition(lerpTime, mData.easingType, stVec.z, edVec.z);
                var position = new Vector3(x, y, z);
                var rotation = tl.GetEasingRotation(lerpTime, mData.easingType, mData.transform.stRot, mData.transform.edRot).eulerAngles;
                var distance = tl.GetEasingPosition(lerpTime, mData.easingType, mData.transform.stSca.x, mData.transform.edSca.x);
                position = tl.AdjustedCameraosition(position, rotation, distance);
                var viewAngle = tl.GetEasingPosition(lerpTime, mData.easingType, mData.transform.stSca.y, mData.transform.edSca.y);

                var tm = screenSet.camera.transform;
                SetCameraTransform(position, rotation, tm);
                if (adjustmentPosition != Vector3.zero && !screenSet.isScreen)
                {
                    tm = screenSet.camera.transform;
                    position += AdjustPosition(adjustmentPosition, tm);
                    SetCameraTransform(position, rotation, tm);
                }
                AddZoomSlider(ref viewAngle);
                ZoomCamera(viewAngle);
            }
        }

        /// <summary>
        /// オートカメラリスト読込
        /// </summary>
        public void ReadAutoCameraLabel()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_AUTO_CAMERA, "");
            if (!string.IsNullOrEmpty(path))
            {
                AutoCameraList = fReader.GetAutoCameraLabel(path);
            }
        }

        /// <summary>
        /// オートカメラ設定読み込み
        /// </summary
        public void ReadAutoCameraData(string label, bool isFirst)
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_AUTO_CAMERA, "");
            if (!string.IsNullOrEmpty(path))
            {
                AutoCamera = fReader.ReadAutoCameraData(path, label, isFirst);
            }
        }

        /// <summary>
        /// オートカメラ設定リセット
        /// </summary
        public void ResetAutoCamera()
        {
            var a = AutoCamera;
            a.autoCamera = new CameraTransformSet();
            a.maidIndex = 0;
            a.autoAngleIndex = 0;
            a.deltaTime = 0;
            AutoCamera = a;
        }

        /// <summary>
        /// オートカメラ設定
        /// </summary
        public void TransformAutoCamera(List<Maid> maids)
        {
            var auto = AutoCamera;
            var cam = auto.autoCamera;
            var isChanged = false;
            if (cam.edTime <= cam.deltaTime || cam.edTime == 0)
            {
                isChanged = true;
                var maidIndex = auto.maidIndex;
                if (auto.isRandomMaid)
                {
                    var mx = maids.Count();
                    var mIndex = MyHelper.GetRandomIndex(mx);
                    if (mIndex == maidIndex)
                    {
                        mIndex++;
                        if (mx <= mIndex)
                        {
                            mIndex = 0;
                        }
                    }
                    maidIndex = mIndex;
                }

                var angleIndex = auto.autoAngleIndex;
                var count = auto.each.Count();
                var indexsH = new List<int>();
                var indexsL = new List<int>();
                for (int i = 0; i < count; i++)
                {
                    var each = auto.each[i];
                    if (each.isAngleEnabled && i != angleIndex)
                    {
                        if (each.isInfrequent)
                        {
                            indexsL.Add(i);
                        }
                        else
                        {
                            indexsH.Add(i);
                        }
                    }
                }
                var isL = false;
                if (!MyHelper.CheckNull(indexsL))
                {
                    isL = MyHelper.GetRandomIndex(MyConst.AUTO_CAMERA_FREC) == 0;
                }
                if (isL)
                {
                    angleIndex = indexsL[MyHelper.GetRandomIndex(indexsL.Count())];
                }
                else if (!MyHelper.CheckNull(indexsH))
                {
                    angleIndex = indexsH[MyHelper.GetRandomIndex(indexsH.Count())];
                }

                var data = auto.each[angleIndex];
                var min = data.positionMin;
                var max = data.positionMax;
                var stPos = new Vector3(
                    MyHelper.GetRandomFloat(min.x, max.x),
                    MyHelper.GetRandomFloat(min.y, max.y),
                    MyHelper.GetRandomFloat(min.z, max.z));
                var edPos = new Vector3(
                    MyHelper.GetRandomFloat(min.x, max.x),
                    MyHelper.GetRandomFloat(min.y, max.y),
                    MyHelper.GetRandomFloat(min.z, max.z));
                var isReverse = MyHelper.GetRandomIndex(2) == 0 ? 1f : -1f;
                var isBack = data.isBackEnabled && MyHelper.GetRandomIndex(20) == 0 ? -1f : 1f;
                stPos.z = stPos.z < MyConst.LOOK_AT_AUTO_MIN_Z ? MyConst.LOOK_AT_AUTO_MIN_Z : stPos.z;
                edPos.z = edPos.z < MyConst.LOOK_AT_AUTO_MIN_Z ? MyConst.LOOK_AT_AUTO_MIN_Z : edPos.z;

                cam = new CameraTransformSet();
                switch (angleIndex)
                {
                    case (int)LookAtAutoAngleType.Fix:
                        cam.transform.stPos = new Vector3(stPos.x * isReverse, stPos.y * isReverse, stPos.z * isBack);
                        cam.transform.edPos = cam.transform.stPos;
                        break;

                    case (int)LookAtAutoAngleType.Rotation1:
                        cam.transform.stPos = new Vector3(stPos.x * isReverse, stPos.y * isReverse, stPos.z * isBack);
                        cam.transform.edPos = new Vector3(edPos.x * isReverse * -1f, stPos.y * isReverse, stPos.z * isBack);
                        break;

                    case (int)LookAtAutoAngleType.Rotation2:
                        cam.transform.stPos = new Vector3(stPos.x * isReverse, stPos.y * isReverse, stPos.z * isBack);
                        cam.transform.edPos = new Vector3(edPos.x * isReverse * -1f, edPos.y * isReverse * -1f, edPos.z * isBack);
                        break;

                    case (int)LookAtAutoAngleType.Zoom:
                        cam.transform.stPos = new Vector3(stPos.x * isReverse, stPos.y * isReverse, stPos.z * isBack);
                        cam.transform.edPos = new Vector3(stPos.x * isReverse, stPos.y * isReverse, edPos.z * isBack);
                        break;

                    case (int)LookAtAutoAngleType.FrontLow:
                        var posY = Mathf.Max(stPos.y, edPos.y) * -1;
                        cam.transform.stPos = new Vector3(stPos.x * isReverse, posY, stPos.z);
                        cam.transform.edPos = new Vector3(edPos.x * isReverse * -1f, posY, edPos.z);
                        break;
                    case (int)LookAtAutoAngleType.BackLow:
                        posY = Mathf.Max(stPos.y, edPos.y) * -1;
                        cam.transform.stPos = new Vector3(stPos.x * isReverse, posY, stPos.z * -1f);
                        cam.transform.edPos = new Vector3(edPos.x * isReverse * -1f, posY, edPos.z * -1f);
                        break;
                }

                if (auto.autoAngleIndex != (int)LookAtAutoAngleType.FrontLow &&
                    auto.autoAngleIndex != (int)LookAtAutoAngleType.BackLow)
                {
                    if(cam.transform.stPos.y < 0)
                    {
                        cam.transform.stPos.y *= 2;
                    }
                    else if (cam.transform.edPos.y < 0)
                    {
                        cam.transform.edPos.y *= 2;
                    }
                }

                cam.edTime = MyHelper.GetRandomFloat(data.autoTime.x, data.autoTime.y);
                cam.deltaTime = 0;
                auto.basePosition = new MaidManager().GetMiadPatrsTrancform(maids[maidIndex], (int)MaidPointType.Head).position;
                auto.maidIndex = maidIndex;
                auto.autoAngleIndex = angleIndex;
            }

            var cameraTm = MyHelper.GetCameraMainTransform();
            var pos = auto.basePosition;
            cam.stTime += Mathf.Clamp01(1 / cam.edTime * Time.deltaTime);
            pos += Vector3.Lerp(cam.transform.stPos, cam.transform.edPos, cam.stTime);
            if (auto.autoAngleIndex == (int)LookAtAutoAngleType.FrontLow ||
                auto.autoAngleIndex == (int)LookAtAutoAngleType.BackLow)
            {
                pos.y = auto.autoCamera.transform.stPos.y;
            }
            else
            {
                pos.y = pos.y < 0f ? 0f : pos.y;
            }
            cameraTm.position = pos;
            pos = auto.basePosition - pos;
            cameraTm.rotation = Quaternion.Slerp(cameraTm.rotation, Quaternion.LookRotation(pos), isChanged ? 1f : 0.1f);
            cam.deltaTime += Time.deltaTime;
            auto.autoCamera = cam;
            AutoCamera = auto;
        }

        /// <summary>
        /// 位置調整
        /// </summary
        public Vector3 AdjustPosition(Vector3 adjustmentPosition, Transform tm)
        {
            var vec = Vector3.zero;
            vec += tm.right * adjustmentPosition.x * -1;
            vec += tm.up * adjustmentPosition.y;
            vec += tm.forward * adjustmentPosition.z * -1;
            return vec;
        }

        /// <summary>
        /// リストインデックス増加
        /// </summary
        public void IncrementIndex(List<CameraTransformSet> motionData, float bgmTime)
        {
            for (int i = 0; i < motionData.Count(); i++)
            {
                if (motionDataIndex >= motionData.Count() || motionData[motionDataIndex].edTime >= bgmTime)
                {
                    break;
                }
                motionDataIndex++;
            }
        }

        /// <summary>
        /// カメラズーム
        /// </summary
        public void ZoomCamera(float zoom)
        {
            try
            {
                var camera = MyHelper.GetCameraMain();
                if (camera.fieldOfView != zoom)
                {
                    camera.fieldOfView = zoom;
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// カメラズーム
        /// </summary
        public float GetFieldOfView()
        {
            return MyHelper.GetCameraMain().fieldOfView;
        }

        /// <summary>
        /// 背景色設定
        /// </summary
        public void SetBackgroundColor(Color32 color)
        {
            MyHelper.GetCameraMain().clearFlags = CameraClearFlags.SolidColor;
            MyHelper.GetCameraMain().backgroundColor = color;
        }

        /// <summary>
        /// カメラリセット
        /// </summary
        public void ResetMainCamera()
        {
            SetMainCameraTransform(GetPositionResetValue(), GetRotationResetValue());
        }

        /// <summary>
        /// フェードイン
        /// </summary
        public void FadeIn(float fadeTime)
        {
            GameMain.Instance.MainCamera.FadeIn(fadeTime, false, null, false, true, default(Color));
        }

        /// <summary>
        /// フェードアウト
        /// </summary
        public void FadeOut(float fadeTime)
        {
            GameMain.Instance.MainCamera.FadeOut(fadeTime, false, null, false, default(Color));
        }

        /// <summary>
        /// フェードアウト中判定
        /// </summary
        public bool IsFadeOut()
        {
            return GameMain.Instance.MainCamera.IsFadeOut();
        }

        /// <summary>
        /// 位置リセット値取得
        /// </summary>
        public Vector3 GetPositionResetValue()
        {
            return new Vector3(MyConst.CAMERA_DEFAULT, MyConst.CAMERA_DEFAULT_POS_Y, MyConst.CAMERA_DEFAULT_POS_Z);
        }

        /// <summary>
        /// 回転リセット値取得
        /// </summary>
        public Vector3 GetRotationResetValue()
        {
            return new Vector3(MyConst.CAMERA_DEFAULT_ROT_X, MyConst.CAMERA_DEFAULT_ROT_Y, MyConst.CAMERA_DEFAULT);
        }

        /// <summary>
        /// 視野角スライダー値加算
        /// </summary>
        private void AddZoomSlider(ref float viewAngle)
        {
            viewAngle += ZoomSlider - MyConst.ZOOM_DEFAULT;
            viewAngle = viewAngle < MyConst.ZOOM_MIN ? MyConst.ZOOM_MIN : viewAngle;
            viewAngle = MyConst.ZOOM_MAX < viewAngle ? MyConst.ZOOM_MAX : viewAngle;
        }
    }
    
    /// <summary>
    /// CM3D2.DanceCameraAdjust.Pluginのソースコードを改変して使用しています。
    /// </summary
    public class DanceCameraAdjustPlugin
    {
        private DanceCameraAdjustSet cameraAdjust;
        private Vector3 preCameraPosition;
        private float preDelta;

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public DanceCameraAdjustPlugin(DanceCameraAdjustSet cameraAdjust)
        {
            this.cameraAdjust = cameraAdjust;
            preCameraPosition = Vector3.zero;
            preDelta = 0f;
        }

        /// <summary>
        /// カメラ高さ調整
        /// </summary>
        public void AdjustCamera(List<Maid> maids, Transform danceCameraT)
        {
            var maidCount = maids.Count();
            var distanceInv = new float[maidCount];
            var sumDistanceInv = 0.0f;

            for (int i = 0; i < maidCount; i++)
            {
                var maidHead = maids[i].body0.GetBone(MyConst.BONE_HEAD);
                if (CheckTarget(maidHead, danceCameraT))
                {
                    Vector3 relpos = maidHead.position - danceCameraT.position;
                    if (Vector3.Angle(Vector3.ProjectOnPlane(danceCameraT.forward, Vector3.up), Vector3.ProjectOnPlane(relpos, Vector3.up)) <
                        (maidCount == 1 ? cameraAdjust.singleAngleMax : cameraAdjust.multiAngleMax))
                    {
                        distanceInv[i] = 1.0f / relpos.sqrMagnitude;
                        sumDistanceInv += distanceInv[i];
                    }
                }
            }

            var delta = 0f;
            for (int i = 0; i < maidCount; i++)
            {
                var maidHead = maids[i].body0.GetBone(MyConst.BONE_HEAD);
                var maidHeight = (int)(maids[i].status.body.height * maids[i].transform.localScale.y);
                if (CheckTarget(maidHead, danceCameraT))
                {
                    var deltaY = 0f;
                    if (maidHeight < cameraAdjust.baseMinHeight)
                    {
                        deltaY = cameraAdjust.correctRate * (maidHeight - cameraAdjust.baseMinHeight) / 100f;
                    }
                    else if (cameraAdjust.baseMaxHeight < maidHeight)
                    {
                        deltaY = cameraAdjust.correctRate * (maidHeight - cameraAdjust.baseMaxHeight) / 100f;
                    }
                    delta += deltaY * (distanceInv[i] / sumDistanceInv);
                }
            }

            if ((preCameraPosition - danceCameraT.position).magnitude <= cameraAdjust.cameraMoveMax)
            {
                if (delta > preDelta + cameraAdjust.deltaMax)
                {
                    delta = preDelta + cameraAdjust.deltaMax;
                }
                else if (delta < preDelta - cameraAdjust.deltaMax)
                {
                    delta = preDelta - cameraAdjust.deltaMax;
                }
            }
            if (danceCameraT.transform.position.y + delta < cameraAdjust.cameraHeightMin)
            {
                delta = cameraAdjust.cameraHeightMin - danceCameraT.transform.position.y;
            }
            if (!float.IsNaN(delta))
            {
                danceCameraT.Translate(new Vector3(0, delta, 0), Space.World);
                preDelta = delta;
                preCameraPosition = danceCameraT.position;
            }
        }

        /// <summary>
        /// 対象判定
        /// </summary>
        private bool CheckTarget(Transform maidHead, Transform danceCameraT)
        {
            return 0 < maidHead.lossyScale.z && Mathf.Abs(maidHead.position.z - danceCameraT.position.z) < MyConst.CAMERA_DEFAULT_POS_Z * 10;
        }

    }


    /// <summary>
    /// 注視・分割カメラ処理管理
    /// </summary>
    public class LookAtCameraManager
    {
        private readonly Camera[] lookAtCamera;
        private float randomTime = 0;
        private readonly bool isScreen;

        /// <summary>
        /// コンストラクタ
        /// </summary
        public LookAtCameraManager(int cameraCount, bool isScreen)
        {
            lookAtCamera = new Camera[cameraCount];
            this.isScreen = isScreen;
        }

        /// <summary>
        /// カメラ分割
        /// </summary
        public void DividedCamera(int dividedIndex, bool isVertical)
        {
            var cameraCount = int.Parse(MyConst.LOOK_AT_DIVIDED_LABEL[dividedIndex].Substring(0, 1));
            var rect = GetDividedCameraRect(cameraCount, dividedIndex, isVertical);
            for (int i = 0; i < cameraCount; i++)
            {
                if (lookAtCamera[i] == null)
                {
                    lookAtCamera[i] = new GameObject("LookAtCamera" + i).GetOrAddComponent<Camera>();
                    lookAtCamera[i].CopyFrom(MyHelper.GetCameraMain());
                }
                lookAtCamera[i].rect = rect[i];
            }
            DestroyCamera(cameraCount, lookAtCamera.GetLength(0));
        }

        /// <summary>
        /// カメラ分割設定取得
        /// </summary
        public Rect[] GetDividedCameraRect(int cameraCount, int dividedIndex, bool isVertical)
        {
            Rect[] rect = new Rect[cameraCount];
            var f0 = 0f;
            var f1 = 1f;
            var f2 = 1f / 2f;
            var f3 = 1f / 3f;
            var f4 = 1f / 4f;
            var f6 = 2f / 3f;
            var f12 = 3f / 4f;

            if (isVertical)
            {
                switch (dividedIndex)
                {
                    case 0:
                        rect[0] = new Rect(f0, f0, f1, f1);
                        break;
                    case 1:
                        rect[0] = new Rect(f2, f0, f2, f1);
                        rect[1] = new Rect(f0, f0, f2, f1);
                        break;
                    case 2:
                        rect[0] = new Rect(f3, f0, f3, f1);
                        rect[1] = new Rect(f6, f0, f3, f1);
                        rect[2] = new Rect(f0, f0, f3, f1);
                        break;
                    case 3:
                        rect[0] = new Rect(f2, f2, f2, f2);
                        rect[1] = new Rect(f0, f2, f2, f2);
                        rect[2] = new Rect(f2, f0, f2, f2);
                        rect[3] = new Rect(f0, f0, f2, f2);
                        break;
                    case 4:
                        rect[0] = new Rect(f0, f0, f12, f1);
                        rect[1] = new Rect(f12, f6, f4, f3);
                        rect[2] = new Rect(f12, f3, f4, f3);
                        rect[3] = new Rect(f12, f0, f4, f3);
                        break;
                    case 5:
                        rect[0] = new Rect(f4, f0, f12, f1);
                        rect[1] = new Rect(f0, f6, f4, f3);
                        rect[2] = new Rect(f0, f3, f4, f3);
                        rect[3] = new Rect(f0, f0, f4, f3);
                        break;
                    case 6:
                        rect[0] = new Rect(f4, f0, f2, f1);
                        rect[1] = new Rect(f12, f2, f4, f2);
                        rect[2] = new Rect(f12, f0, f4, f2);
                        rect[3] = new Rect(f0, f2, f4, f2);
                        rect[4] = new Rect(f0, f0, f4, f2);
                        break;
                    case 7:
                        rect[0] = new Rect(f0, f0, f12, f1);
                        rect[1] = new Rect(f12, f12, f4, f4);
                        rect[2] = new Rect(f12, f2, f4, f4);
                        rect[3] = new Rect(f12, f4, f4, f4);
                        rect[4] = new Rect(f12, f0, f4, f4);
                        break;
                    case 8:
                        rect[0] = new Rect(f4, f0, f12, f1);
                        rect[1] = new Rect(f0, f12, f4, f4);
                        rect[2] = new Rect(f0, f2, f4, f4);
                        rect[3] = new Rect(f0, f4, f4, f4);
                        rect[4] = new Rect(f0, f0, f4, f4);
                        break;
                    case 9:
                        rect[0] = new Rect(f3, f2, f3, f2);
                        rect[1] = new Rect(f3, f0, f3, f2);
                        rect[2] = new Rect(f6, f2, f3, f2);
                        rect[3] = new Rect(f6, f0, f3, f2);
                        rect[4] = new Rect(f0, f2, f3, f2);
                        rect[5] = new Rect(f0, f0, f3, f2);
                        break;
                    case 10:
                        rect[0] = new Rect(f4, f0, f2, f1);
                        rect[1] = new Rect(f12, f6, f4, f3);
                        rect[2] = new Rect(f12, f3, f4, f3);
                        rect[3] = new Rect(f12, f0, f4, f3);
                        rect[4] = new Rect(f0, f6, f4, f3);
                        rect[5] = new Rect(f0, f3, f4, f3);
                        rect[6] = new Rect(f0, f0, f4, f3);
                        break;
                    case 11:
                        rect[0] = new Rect(f0, f3, f12, f6);
                        rect[1] = new Rect(f12, f6, f4, f3);
                        rect[2] = new Rect(f12, f3, f4, f3);
                        rect[3] = new Rect(f12, f0, f4, f3);
                        rect[4] = new Rect(f2, f0, f4, f3);
                        rect[5] = new Rect(f4, f0, f4, f3);
                        rect[6] = new Rect(f0, f0, f4, f3);
                        break;
                    case 12:
                        rect[0] = new Rect(f4, f3, f12, f6);
                        rect[1] = new Rect(f0, f6, f4, f3);
                        rect[2] = new Rect(f0, f3, f4, f3);
                        rect[3] = new Rect(f0, f0, f4, f3);
                        rect[4] = new Rect(f4, f0, f4, f3);
                        rect[5] = new Rect(f2, f0, f4, f3);
                        rect[6] = new Rect(f12, f0, f4, f3);
                        break;
                    case 13:
                        rect[0] = new Rect(f0, f4, f12, f12);
                        rect[1] = new Rect(f12, f12, f4, f4);
                        rect[2] = new Rect(f12, f2, f4, f4);
                        rect[3] = new Rect(f12, f4, f4, f4);
                        rect[4] = new Rect(f12, f0, f4, f4);
                        rect[5] = new Rect(f2, f0, f4, f4);
                        rect[6] = new Rect(f4, f0, f4, f4);
                        rect[7] = new Rect(f0, f0, f4, f4);
                        break;
                    case 14:
                        rect[0] = new Rect(f4, f4, f12, f12);
                        rect[1] = new Rect(f0, f12, f4, f4);
                        rect[2] = new Rect(f0, f2, f4, f4);
                        rect[3] = new Rect(f0, f4, f4, f4);
                        rect[4] = new Rect(f0, f0, f4, f4);
                        rect[5] = new Rect(f4, f0, f4, f4);
                        rect[6] = new Rect(f2, f0, f4, f4);
                        rect[7] = new Rect(f12, f0, f4, f4);
                        break;
                    case 15:
                        rect[0] = new Rect(f3, f3, f3, f3);
                        rect[1] = new Rect(f3, f6, f3, f3);
                        rect[2] = new Rect(f3, f0, f3, f3);
                        rect[3] = new Rect(f6, f6, f3, f3);
                        rect[4] = new Rect(f6, f3, f3, f3);
                        rect[5] = new Rect(f6, f0, f3, f3);
                        rect[6] = new Rect(f0, f6, f3, f3);
                        rect[7] = new Rect(f0, f3, f3, f3);
                        rect[8] = new Rect(f0, f0, f3, f3);
                        break;
                    case 16:
                        rect[0] = new Rect(f4, f0, f2, f1);
                        rect[1] = new Rect(f12, f12, f4, f4);
                        rect[2] = new Rect(f12, f2, f4, f4);
                        rect[3] = new Rect(f12, f4, f4, f4);
                        rect[4] = new Rect(f12, f0, f4, f4);
                        rect[5] = new Rect(f0, f12, f4, f4);
                        rect[6] = new Rect(f0, f2, f4, f4);
                        rect[7] = new Rect(f0, f4, f4, f4);
                        rect[8] = new Rect(f0, f0, f4, f4);
                        break;
                    case 17:
                        rect[0] = new Rect(f2, f0, f2, f1);
                        rect[1] = new Rect(f4, f12, f4, f4);
                        rect[2] = new Rect(f4, f2, f4, f4);
                        rect[3] = new Rect(f4, f4, f4, f4);
                        rect[4] = new Rect(f4, f0, f4, f4);
                        rect[5] = new Rect(f0, f12, f4, f4);
                        rect[6] = new Rect(f0, f2, f4, f4);
                        rect[7] = new Rect(f0, f4, f4, f4);
                        rect[8] = new Rect(f0, f0, f4, f4);
                        break;
                }
            }
            else
            {
                switch (dividedIndex)
                {
                    case 0:
                        rect[0] = new Rect(f0, f0, f1, f1);
                        break;
                    case 1:
                        rect[0] = new Rect(f0, f2, f1, f2);
                        rect[1] = new Rect(f0, f0, f1, f2);
                        break;
                    case 2:
                        rect[0] = new Rect(f0, f3, f1, f3);
                        rect[1] = new Rect(f0, f0, f1, f3);
                        rect[2] = new Rect(f0, f6, f1, f3);
                        break;
                    case 3:
                        rect[0] = new Rect(f2, f2, f2, f2);
                        rect[1] = new Rect(f0, f2, f2, f2);
                        rect[2] = new Rect(f2, f0, f2, f2);
                        rect[3] = new Rect(f0, f0, f2, f2);
                        break;
                    case 4:
                        rect[0] = new Rect(f0, f3, f1, f6);
                        rect[1] = new Rect(f0, f0, f3, f3);
                        rect[2] = new Rect(f3, f0, f3, f3);
                        rect[3] = new Rect(f6, f0, f3, f3);
                        break;
                    case 5:
                        rect[0] = new Rect(f0, f0, f1, f6);
                        rect[1] = new Rect(f0, f6, f3, f3);
                        rect[2] = new Rect(f3, f6, f3, f3);
                        rect[3] = new Rect(f6, f6, f3, f3);
                        break;
                    case 6:
                        rect[0] = new Rect(f0, f4, f1, f2);
                        rect[1] = new Rect(f0, f12, f2, f4);
                        rect[2] = new Rect(f2, f12, f2, f4);
                        rect[3] = new Rect(f0, f0, f2, f4);
                        rect[4] = new Rect(f2, f0, f2, f4);
                        break;
                    case 7:
                        rect[0] = new Rect(f0, f4, f1, f12);
                        rect[1] = new Rect(f0, f0, f4, f4);
                        rect[2] = new Rect(f4, f0, f4, f4);
                        rect[3] = new Rect(f2, f0, f4, f4);
                        rect[4] = new Rect(f12, f0, f4, f4);
                        break;
                    case 8:
                        rect[0] = new Rect(f0, f0, f1, f12);
                        rect[1] = new Rect(f0, f12, f4, f4);
                        rect[2] = new Rect(f4, f12, f4, f4);
                        rect[3] = new Rect(f2, f12, f4, f4);
                        rect[4] = new Rect(f12, f12, f4, f4);
                        break;
                    case 9:
                        rect[0] = new Rect(f0, f3, f2, f3);
                        rect[1] = new Rect(f2, f3, f2, f3);
                        rect[2] = new Rect(f0, f6, f2, f3);
                        rect[3] = new Rect(f2, f6, f2, f3);
                        rect[4] = new Rect(f0, f0, f2, f3);
                        rect[5] = new Rect(f2, f0, f2, f3);
                        break;
                    case 10:
                        rect[0] = new Rect(f0, f4, f1, f2);
                        rect[1] = new Rect(f0, f12, f3, f4);
                        rect[2] = new Rect(f3, f12, f3, f4);
                        rect[3] = new Rect(f6, f12, f3, f4);
                        rect[4] = new Rect(f0, f0, f3, f4);
                        rect[5] = new Rect(f3, f0, f3, f4);
                        rect[6] = new Rect(f6, f0, f3, f4);
                        break;
                    case 11:
                        rect[0] = new Rect(f0, f0, f12, f6);
                        rect[1] = new Rect(f0, f6, f4, f3);
                        rect[2] = new Rect(f4, f6, f4, f3);
                        rect[3] = new Rect(f2, f6, f4, f3);
                        rect[4] = new Rect(f12, f6, f4, f3);
                        rect[5] = new Rect(f12, f3, f4, f3);
                        rect[6] = new Rect(f12, f0, f4, f3);
                        break;
                    case 12:
                        rect[0] = new Rect(f4, f0, f12, f6);
                        rect[1] = new Rect(f12, f6, f4, f3);
                        rect[2] = new Rect(f2, f6, f4, f3);
                        rect[3] = new Rect(f4, f6, f4, f3);
                        rect[4] = new Rect(f0, f6, f4, f3);
                        rect[5] = new Rect(f0, f3, f4, f3);
                        rect[6] = new Rect(f0, f0, f4, f3);
                        break;
                    case 13:
                        rect[0] = new Rect(f0, f0, f12, f12);
                        rect[1] = new Rect(f0, f12, f4, f4);
                        rect[2] = new Rect(f4, f12, f4, f4);
                        rect[3] = new Rect(f2, f12, f4, f4);
                        rect[4] = new Rect(f12, f12, f4, f4);
                        rect[5] = new Rect(f12, f2, f4, f4);
                        rect[6] = new Rect(f12, f4, f4, f4);
                        rect[7] = new Rect(f12, f0, f4, f4);
                        break;
                    case 14:
                        rect[0] = new Rect(f4, f0, f12, f12);
                        rect[1] = new Rect(f12, f12, f4, f4);
                        rect[2] = new Rect(f2, f12, f4, f4);
                        rect[3] = new Rect(f4, f12, f4, f4);
                        rect[4] = new Rect(f0, f12, f4, f4);
                        rect[5] = new Rect(f0, f2, f4, f4);
                        rect[6] = new Rect(f0, f4, f4, f4);
                        rect[7] = new Rect(f0, f0, f4, f4);
                        break;
                    case 15:
                        rect[0] = new Rect(f4, f3, f2, f6);
                        rect[1] = new Rect(f12, f6, f4, f3);
                        rect[2] = new Rect(f12, f3, f4, f3);
                        rect[3] = new Rect(f12, f0, f4, f3);
                        rect[4] = new Rect(f2, f0, f4, f3);
                        rect[5] = new Rect(f4, f0, f4, f3);
                        rect[6] = new Rect(f0, f0, f4, f3);
                        rect[7] = new Rect(f0, f3, f4, f3);
                        rect[8] = new Rect(f0, f6, f4, f3);
                        break;
                    case 16:
                        rect[0] = new Rect(f0, f4, f1, f2);
                        rect[1] = new Rect(f0, f12, f4, f4);
                        rect[2] = new Rect(f4, f12, f4, f4);
                        rect[3] = new Rect(f2, f12, f4, f4);
                        rect[4] = new Rect(f12, f12, f4, f4);
                        rect[5] = new Rect(f0, f0, f4, f4);
                        rect[6] = new Rect(f4, f0, f4, f4);
                        rect[7] = new Rect(f2, f0, f4, f4);
                        rect[8] = new Rect(f12, f0, f4, f4);
                        break;
                    case 17:
                        rect[0] = new Rect(f0, f2, f1, f2);
                        rect[1] = new Rect(f0, f4, f4, f4);
                        rect[2] = new Rect(f4, f4, f4, f4);
                        rect[3] = new Rect(f2, f4, f4, f4);
                        rect[4] = new Rect(f12, f4, f4, f4);
                        rect[5] = new Rect(f0, f0, f4, f4);
                        rect[6] = new Rect(f4, f0, f4, f4);
                        rect[7] = new Rect(f2, f0, f4, f4);
                        rect[8] = new Rect(f12, f0, f4, f4);
                        break;
                }
            }
            return rect;
        }

        /// <summary>
        /// 小画面設定
        /// </summary
        public void SetSubScreen(MaidLookAtEachSet[] eachSet)
        {
            for (int i = 0; i < eachSet.Count(); i++)
            {
                if (eachSet[i].isLookAt)
                {
                    if (lookAtCamera[i] == null)
                    {
                        lookAtCamera[i] = new GameObject("LookAtCamera" + i).GetOrAddComponent<Camera>();
                        lookAtCamera[i].CopyFrom(MyHelper.GetCameraMain());
                    }
                    var rect = GetSubCameraRect(i, eachSet[i].subSizeIndex);
                    lookAtCamera[i].rect = rect;
                }
                else
                {
                    DestroyCamera(i, i + 1);
                }
            }
        }

        /// <summary>
        /// ロックオン設定
        /// </summary
        public void LockOn()
        {
            int i = 0;
            if (lookAtCamera[i] == null)
            {
                lookAtCamera[i] = new GameObject("LookAtCamera" + i).GetOrAddComponent<Camera>();
                lookAtCamera[i].CopyFrom(MyHelper.GetCameraMain());
            }
        }

        /// <summary>
        /// カメラ分割設定取得
        /// </summary
        public Rect GetSubCameraRect(int subIndex, int sizeIndex)
        {
            var f0 = 0f;
            var f2 = 1f / 2f;
            var f3 = 1f / 3f;
            var f4 = 1f / 4f;
            var f6 = 2f / 3f;
            var f12 = 3f / 4f;
            Rect rect = new Rect(f0, f0, f0, f0);

            switch (subIndex)
            {
                case 0:
                    switch (sizeIndex)
                    {
                        case 0:
                            rect = new Rect(f0, f12, f4, f4);
                            break;
                        case 1:
                            rect = new Rect(f0, f6, f3, f3);
                            break;
                        case 2:
                            rect = new Rect(f0, f2, f2, f2);
                            break;
                    }
                    break;

                case 1:
                    switch (sizeIndex)
                    {
                        case 0:
                            rect = new Rect(f12, f12, f4, f4);
                            break;
                        case 1:
                            rect = new Rect(f6, f6, f3, f3);
                            break;
                        case 2:
                            rect = new Rect(f2, f2, f2, f2);
                            break;
                    }
                    break;

                case 2:
                    switch (sizeIndex)
                    {
                        case 0:
                            rect = new Rect(f0, f0, f4, f4);
                            break;
                        case 1:
                            rect = new Rect(f0, f0, f3, f3);
                            break;
                        case 2:
                            rect = new Rect(f0, f0, f2, f2);
                            break;
                    }
                    break;

                case 3:
                    switch (sizeIndex)
                    {
                        case 0:
                            rect = new Rect(f12, f0, f4, f4);
                            break;
                        case 1:
                            rect = new Rect(f6, f0, f3, f3);
                            break;
                        case 2:
                            rect = new Rect(f2, f0, f2, f2);
                            break;
                    }
                    break;
            }
            return rect;
        }

        /// <summary>
        /// カメラ削除
        /// </summary
        public void DestroyCamera(int startIndex, int endIndex)
        {
            if (startIndex < 0)
            {
                startIndex = 0;
            }
            if (lookAtCamera.GetLength(0) < endIndex)
            {
                endIndex = lookAtCamera.GetLength(0);
            }
            for (int i = startIndex; i < endIndex; i++)
            {
                if (lookAtCamera[i] != null)
                {
                    GameObject.Destroy(lookAtCamera[i]);
                    lookAtCamera[i] = null;
                }
            }
        }

        /// <summary>
        /// LookAtメイド設定
        /// </summary
        public void SetCameraMotion()
        {
            var tm = MyHelper.GetCameraMainTransform();
            lookAtCamera[0].transform.position = tm.position;
            lookAtCamera[0].transform.rotation = tm.rotation;
        }

        /// <summary>
        /// LookAtメイド設定
        /// </summary
        public MaidLookAtEachSet SetLookAtMaid(MaidLookAtEachSet mLookAtEach, LookAtSet lookAtSet, int index, Maid maid, MaidLookAtSet mLookAt)
        {
            try
            {
                var basePosition = Vector3.zero;
                var relativePos = Vector3.zero;
                var cameraTm = lookAtCamera[index].transform;
                var maidTm = new MaidManager().GetMiadPatrsTrancform(maid, mLookAtEach.pointIndex);
                if (maidTm == null)
                {
                    return mLookAtEach;
                }

                if (mLookAt.lookAtIndex == (int)LookAtCameraType.LockOn)
                {
                    basePosition = new Vector3(cameraTm.position.x, maidTm.position.y, cameraTm.position.z);
                    cameraTm = MyHelper.GetCameraMainTransform();
                }
                else if (index == 0 && !isScreen &&
                        mLookAt.lookAtIndex != (int)LookAtCameraType.SubCamera)
                {
                    cameraTm = MyHelper.GetCameraMainTransform();
                }
                else if (mLookAtEach.typeIndex == (int)LookAtType.Around)
                {
                    var tm = MyHelper.GetCameraMainTransform();
                    cameraTm.position = tm.position;
                    cameraTm.eulerAngles = tm.eulerAngles;
                }
                var x = 0f;
                var y = 0f;
                var z = 0f;

                switch (mLookAtEach.typeIndex)
                {
                    case (int)LookAtType.FixRotate:
                        var angle = 360 - maidTm.rotation.eulerAngles.y;
                        x = Mathf.Cos(angle * Mathf.Deg2Rad) * mLookAtEach.distanceSlider;
                        z = Mathf.Sin(angle * Mathf.Deg2Rad) * mLookAtEach.distanceSlider;
                        cameraTm.position = new Vector3(maidTm.position.x + x, maidTm.position.y, maidTm.position.z + z);

                        relativePos = maidTm.position - cameraTm.position;
                        Quaternion rotation = Quaternion.LookRotation(relativePos);
                        cameraTm.rotation = Quaternion.Slerp(cameraTm.rotation, rotation, Time.deltaTime);
                        cameraTm.position = maidTm.position - cameraTm.forward * mLookAtEach.distanceSlider;
                        break;

                    case (int)LookAtType.Fix:
                        angle = 360 - maidTm.rotation.eulerAngles.y;
                        x = Mathf.Cos(angle * Mathf.Deg2Rad) * mLookAtEach.distanceSlider;
                        z = Mathf.Sin(angle * Mathf.Deg2Rad) * mLookAtEach.distanceSlider;
                        cameraTm.position = new Vector3(maidTm.position.x + x, maidTm.position.y, maidTm.position.z + z);

                        relativePos = maidTm.position - cameraTm.position;
                        rotation = Quaternion.LookRotation(relativePos);
                        cameraTm.rotation = Quaternion.Slerp(cameraTm.rotation, rotation, MyConst.LOOK_AT_FIXED_SPEED);
                        cameraTm.position = maidTm.position - cameraTm.forward * mLookAtEach.distanceSlider;
                        break;

                    case (int)LookAtType.Around:
                        var way = Vector3.zero;
                        switch (mLookAtEach.aroundTypeIndex)
                        {
                            case (int)LookAtAroundAngleType.Front:
                                way = cameraTm.forward;
                                break;
                            case (int)LookAtAroundAngleType.Back:
                                way = -cameraTm.forward;
                                break;
                            case (int)LookAtAroundAngleType.Left:
                                way = -cameraTm.right;
                                break;
                            case (int)LookAtAroundAngleType.Right:
                                way = cameraTm.right;
                                break;
                            case (int)LookAtAroundAngleType.Up:
                                way = -cameraTm.up;
                                mLookAtEach.isOffsetX = false;
                                mLookAtEach.isFixedPosY = false;
                                mLookAtEach.isFixedRotX = false;
                                mLookAtEach.isFixedRotY = false;
                                break;
                            case (int)LookAtAroundAngleType.Down:
                                way = cameraTm.up;
                                mLookAtEach.isOffsetX = false;
                                mLookAtEach.isFixedPosY = false;
                                mLookAtEach.isFixedRotX = false;
                                mLookAtEach.isFixedRotY = false;
                                break;
                        }

                        if (index == 0 && !isScreen)
                        {
                            way = cameraTm.forward;
                        }
                        cameraTm.position = maidTm.position - way * mLookAtEach.distanceSlider;
                        cameraTm.LookAt(maidTm);
                        break;

                    case (int)LookAtType.Rotate:
                        cameraTm.position = maidTm.position - cameraTm.forward * mLookAtEach.distanceSlider;
                        cameraTm.RotateAround(maidTm.position, Vector3.up, lookAtSet.rotateAroundTime * Time.deltaTime);
                        break;

                    case (int)LookAtType.Auto:
                        var cam = mLookAtEach.autoCamera;
                        var isChanged = false;
                        if (cam.edTime <= cam.deltaTime || mLookAtEach.isRandomMaid && randomTime == 0)
                        {
                            isChanged = true;
                            cam = new CameraTransformSet();
                            var angleIndex = mLookAtEach.autoAngleIndex;
                            var count = lookAtSet.autoData.Count();
                            var indexs = new List<int>();
                            for (int i = 0; i < count; i++)
                            {
                                if (lookAtSet.autoData[i].isEnabled && i != angleIndex)
                                {
                                    indexs.Add(i);
                                }
                            }
                            if (!MyHelper.CheckNull(indexs))
                            {
                                angleIndex = indexs[MyHelper.GetRandomIndex(indexs.Count())];
                            }
                            var data = lookAtSet.autoData[angleIndex];
                            var min = new Vector3(0f, 0f, MyConst.LOOK_AT_AUTO_MIN_Z);
                            var max = data.position;
                            var stPos = new Vector3(
                                MyHelper.GetRandomFloat(min.x, max.x),
                                MyHelper.GetRandomFloat(min.y, max.y),
                                MyHelper.GetRandomFloat(min.z, max.z));
                            var edPos = new Vector3(
                                MyHelper.GetRandomFloat(min.x, max.x),
                                MyHelper.GetRandomFloat(min.y, max.y),
                                MyHelper.GetRandomFloat(min.z, max.z));
                            var isReverse = MyHelper.GetRandomIndex(2) == 0 ? 1f : -1f;
                            var isBack = MyHelper.GetRandomIndex(MyConst.AUTO_CAMERA_FREC * 2) == 0 ? -1f : 1f;
                            stPos.z = stPos.z < MyConst.LOOK_AT_AUTO_MIN_Z ? MyConst.LOOK_AT_AUTO_MIN_Z : stPos.z;
                            edPos.z = edPos.z < MyConst.LOOK_AT_AUTO_MIN_Z ? MyConst.LOOK_AT_AUTO_MIN_Z : edPos.z;

                            switch (angleIndex)
                            {
                                case (int)LookAtAutoAngleType.Fix:
                                    cam.transform.stPos = new Vector3(stPos.x * isReverse, stPos.y * isReverse, stPos.z * isBack);
                                    cam.transform.edPos = cam.transform.stPos;
                                    break;

                                case (int)LookAtAutoAngleType.Rotation1:
                                    cam.transform.stPos = new Vector3(stPos.x * isReverse, stPos.y * isReverse, stPos.z * isBack);
                                    cam.transform.edPos = new Vector3(edPos.x * isReverse * -1f, stPos.y * isReverse, stPos.z * isBack);
                                    break;

                                case (int)LookAtAutoAngleType.Rotation2:
                                    cam.transform.stPos = new Vector3(stPos.x * isReverse, stPos.y * isReverse, stPos.z * isBack);
                                    cam.transform.edPos = new Vector3(edPos.x * isReverse * -1f, edPos.y * isReverse * -1f, edPos.z * isBack);
                                    break;

                                case (int)LookAtAutoAngleType.Zoom:
                                    cam.transform.stPos = new Vector3(stPos.x * isReverse, stPos.y * isReverse, stPos.z * isBack);
                                    cam.transform.edPos = new Vector3(stPos.x * isReverse, stPos.y * isReverse, edPos.z * isBack);
                                    break;

                                case (int)LookAtAutoAngleType.FrontLow:
                                    var posY = Mathf.Max(stPos.y, edPos.y) * -1;
                                    cam.transform.stPos = new Vector3(stPos.x * isReverse, posY, stPos.z);
                                    cam.transform.edPos = new Vector3(edPos.x * isReverse * -1f, posY, edPos.z);
                                    break;
                                case (int)LookAtAutoAngleType.BackLow:
                                    posY = Mathf.Max(stPos.y, edPos.y) * -1;
                                    cam.transform.stPos = new Vector3(stPos.x * isReverse, posY, stPos.z * -1f);
                                    cam.transform.edPos = new Vector3(edPos.x * isReverse * -1f, posY, edPos.z * -1f);
                                    break;
                            }

                            if (mLookAtEach.isRandomMaid)
                            {
                                cam.edTime = mLookAt.randomTime;
                            }
                            else
                            {
                                cam.edTime = MyHelper.GetRandomFloat(data.autoTime.x, data.autoTime.y);
                            }
                            mLookAtEach.autoAngleIndex = angleIndex;
                        }
                        var pos = maidTm.position;
                        cam.stTime += Mathf.Clamp01(1 / cam.edTime * Time.deltaTime);
                        pos += Vector3.Lerp(cam.transform.stPos, cam.transform.edPos, cam.stTime);
                        if (mLookAtEach.autoAngleIndex == (int)LookAtAutoAngleType.FrontLow ||
                            mLookAtEach.autoAngleIndex == (int)LookAtAutoAngleType.BackLow)
                        {
                            pos.y = mLookAtEach.autoCamera.transform.stPos.y;
                        }
                        else
                        {
                            pos.y = pos.y < 0f ? 0f : pos.y;
                        }
                        cameraTm.position = pos;
                        pos = maidTm.position - pos;
                        var rotTo = Quaternion.LookRotation(pos);
                        cameraTm.rotation = Quaternion.Lerp(cameraTm.rotation, Quaternion.LookRotation(pos), isChanged ? 1f : 0.1f);

                        if (mLookAtEach.isRandomMaid)
                        {
                            cam.deltaTime = randomTime;
                        }
                        else
                        {
                            cam.deltaTime += Time.deltaTime;
                        }
                        mLookAtEach.autoCamera = cam;
                        mLookAtEach.isOffsetX = false;
                        mLookAtEach.isFixedPosY = false;
                        mLookAtEach.isFixedRotX = false;
                        mLookAtEach.isFixedRotY = false;
                        break;

                    default:
                        if (mLookAt.lookAtIndex == (int)LookAtCameraType.LockOn)
                        {
                            cameraTm.position = basePosition;
                            relativePos = maidTm.position - cameraTm.position;
                            rotation = Quaternion.LookRotation(relativePos);
                            cameraTm.rotation = Quaternion.Slerp(cameraTm.rotation, rotation, mLookAt.chasingSpeed * Time.deltaTime);
                            var baseAngle = MyHelper.IsVR() ? 180f : 90f;
                            x = Mathf.Cos(baseAngle * Mathf.Deg2Rad) * mLookAtEach.distanceSlider;
                            z = Mathf.Sin(baseAngle * Mathf.Deg2Rad) * mLookAtEach.distanceSlider;
                            pos = new Vector3(maidTm.position.x + x, maidTm.position.y, maidTm.position.z + z);
                            cameraTm.position = Vector3.Lerp(basePosition, pos, mLookAt.chasingSpeed * Time.deltaTime) - cameraTm.forward * mLookAtEach.distanceSlider / 100;
                        }
                        break;
                }

                if (mLookAtEach.isOffsetX || mLookAtEach.isFixedPosY)
                {
                    x = mLookAtEach.isOffsetX ? mLookAtEach.offsetX : 0f;
                    y = mLookAtEach.isFixedPosY ? mLookAtEach.fixedPosY : cameraTm.position.y;
                    cameraTm.position = new Vector3(cameraTm.position.x + x, y, cameraTm.position.z);
                }
                if (mLookAtEach.isFixedRotX || mLookAtEach.isFixedRotY)
                {
                    x = mLookAtEach.isFixedRotX ? mLookAtEach.fixedRotX : cameraTm.eulerAngles.x;
                    y = mLookAtEach.isFixedRotY ? mLookAtEach.fixedRotY : cameraTm.eulerAngles.y;
                    cameraTm.rotation = Quaternion.Euler(new Vector3(x, y, cameraTm.eulerAngles.z));
                }
                if (index == 0 && !isScreen && mLookAt.lookAtIndex != (int)LookAtCameraType.SubCamera)
                {
                    lookAtCamera[index].transform.position = cameraTm.position;
                    lookAtCamera[index].transform.rotation = cameraTm.rotation;
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return mLookAtEach;
        }

        /// <summary>
        /// LookAtランダムタイムチェック
        /// </summary
        public bool IsChangingTime(float randomChangedTime)
        {
            return randomChangedTime <= randomTime;
        }

        /// <summary>
        /// LookAtランダムタイム更新
        /// </summary
        public void UpdateRandomTime()
        {
            randomTime += Time.deltaTime;
        }

        /// <summary>
        /// LookAtランダムタイム初期化
        /// </summary
        public void InitializeRandomTime()
        {
            randomTime = 0;
        }

        /// <summary>
        /// LookAtランダムポイント設定
        /// </summary
        public int SetRandomPoint(int pointIndex)
        {
            var max = MyConst.LOOK_AT_POINT_LABEL.GetLength(0);
            var index = MyHelper.GetRandomIndex(max);
            if (pointIndex == index)
            {
                index++;
                if (max <= index)
                {
                    index = 0;
                }
            }
            return index;
        }

        /// <summary>
        /// LookAtランダムメイド設定
        /// </summary
        public int SetRandomMaid(int maidIndex, List<int> maidList)
        {
            var max = maidList.Count();
            var index = MyHelper.GetRandomIndex(max);
            if (maidIndex == maidList[index])
            {
                index++;
                if (max <= index)
                {
                    index = 0;
                }
            }
            return maidList[index];
        }

        /// <summary>
        /// レンダーテクスチャー設定
        /// </summary
        public void SetRenderTexture(RenderTexture rTexture, GameObject screen, bool isMask)
        {
            var index = MyConst.SCREEN_CAMERA_INDEX - 1;
            var cam = new GameObject(MyConst.SCREEN_CAMERA).GetOrAddComponent<Camera>();
            cam.targetTexture = rTexture;
            if (isMask)
            {
                cam.cullingMask &= ~(1 << screen.gameObject.layer);
            }
            cam.clearFlags = CameraClearFlags.SolidColor;
            cam.backgroundColor = MyHelper.GetCameraMain().backgroundColor;
            cam.nearClipPlane = MyHelper.GetCameraMain().nearClipPlane;
            cam.farClipPlane = MyHelper.GetCameraMain().farClipPlane;
            lookAtCamera[index] = cam;
        }
    }

    /// <summary>
    /// サウンド処理管理
    /// </summary>
    public class SoundManager
    {
        private readonly SoundMgr soundMgr;

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public SoundManager()
        {
            soundMgr = GameMain.Instance.SoundMgr;
        }

        /// <summary>
        /// BGMタイム取得
        /// </summary>
        public float GetBgmTime()
        {
            return soundMgr.GetAudioSourceBgm().time;
        }

        /// <summary>
        /// BGMタイム設定
        /// </summary>
        public void SetBgmTime(float bgmTime)
        {
            soundMgr.GetAudioSourceBgm().time = bgmTime;
        }

        /// <summary>
        /// BGMミュート判定
        /// </summary>
        public bool IsMuteBgm()
        {
            return soundMgr.GetAudioSourceBgm().mute;
        }

        /// <summary>
        /// BGMミュート
        /// </summary>
        public void MuteBgm(bool isMute)
        {
            soundMgr.GetAudioSourceBgm().mute = isMute;
        }

        /// <summary>
        /// BGM停止
        /// </summary>
        public void StopBgm(float time)
        {
            soundMgr.StopBGM(time);
        }

        /// <summary>
        /// BGM一時停止
        /// </summary>
        public void PauseBgm()
        {
            soundMgr.GetAudioSourceBgm().Pause();
        }

        /// <summary>
        /// BGM一時停止解除
        /// </summary>
        public void UnPauseBgm()
        {
            soundMgr.GetAudioSourceBgm().UnPause();
        }

        /// <summary>
        /// BGM名取得
        /// </summary>
        public string GetClipName()
        {
            return soundMgr.GetAudioSourceBgm().clip.name;
        }

        /// <summary>
        /// BGM総タイム取得
        /// </summary>
        public float GetClipLength()
        {
            return soundMgr.GetAudioSourceBgm().clip.length;
        }

        /// <summary>
        /// BGMボリューム取得
        /// </summary>
        public int GetVolumeDance()
        {
            return soundMgr.GetVolumeDance();
        }

        /// <summary>
        /// ダンスボリューム設定
        /// </summary>
        public void SetVolumeDance(int volume, bool isDance)
        {
            var bgm = soundMgr.GetAudioSourceBgm();
            var group = isDance ? AudioMixerMgr.Group.Dance : AudioMixerMgr.Group.BGM;
            bgm.outputAudioMixerGroup = soundMgr.mix_mgr[group];
            //mgr.SetVolume(AudioSourceMgr.Type.Bgm, volume);
            soundMgr.SetVolumeDance(volume);
            soundMgr.Apply();
        }

        /// <summary>
        /// ダンスBGM再生
        /// </summary>
        public void PlayDanceBGM(string bgmName)
        {
            soundMgr.PlayDanceBGM(bgmName, 1f, false);
        }

        /// <summary>
        /// ダンスBGM再生（CM3D2）
        /// </summary>
        public void PlayBGMCM3D2Dance(string bgmName)
        {
            soundMgr.PlayBGMLegacy(bgmName, 0f, false);
        }

        /// <summary>
        /// BGM再生
        /// </summary>
        public void PlayBGM(string bgmName)
        {
            soundMgr.PlayBGM(bgmName, 1f, true);
        }

        /// <summary>
        /// SE再生
        /// </summary>
        public void PlaySe(string seName)
        {
            soundMgr.PlaySe(seName, false);
        }

        /// <summary>
        /// ランダムBGM再生
        /// </summary>
        public string GetRandomBgmName()
        {
            var bgm = MyConst.COM3D2_RANDOM_BGM_INDEX;
            var index = new System.Random().Next(0, bgm.GetLength(0));
            return string.Format(MyConst.FILE_BGM, bgm[index]);
        }

    }

    /// <summary>
    /// 背景処理管理
    /// </summary>
    public class BackgroundManager
    {
        public SkyboxSet SkyboxSet { get; set; }
        public Dictionary<string, FreeBgSet> BackgroundDic { get; set; }
        public Vector3 BgPosition { get; set; }
        public Vector3 BgRotation { get; set; }
        public Color32 BgColor { get; set; }
        public Dictionary<string, List<FreeBgPartsSet>> BgPartsDic { get; set; }
        public List<string> BgPartsList { get; set; }
        public FreeForegroundSet[] ForegroundSet { get; set; }
        public Dictionary<int, FreeMaidMaskSet> MaidMaskDic { get; set; }
        public string SavedBackgroundName { get; set; }
        public Color SavedBackgroundColor { get; set; }
        public int BackgroundIndex { get; set; }
        public int BgInstanceIndex { get; set; }
        public int MaidMaskIndex { get; set; }
        public bool IsBgInstanceComboOn { get; set; }
        public bool IsBgIntance { get; set; }

        public float Scale { get; set; }

        public int bgPartsIndex = 0;
        private GameObject bgInstanceParts;
        private GameObject foregroundPanel;
        private GameObject maidMaskPanel;
        private Dictionary<string, GameObject> danceBgDic;
        private Dictionary<int, FreeMaidMaskPanelSet[]> maidMaskPanelDic;

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public BackgroundManager()
        {
            SkyboxSet = new SkyboxSet();
            BgPartsDic = new Dictionary<string, List<FreeBgPartsSet>>();
            maidMaskPanelDic = new Dictionary<int, FreeMaidMaskPanelSet[]>();
        }

        /// <summary>
        /// 背景リスト読込
        /// </summary>
        public bool ReadBackgroundData()
        {
            var isRead = false;
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_BACKGROUND, "");
            if (!string.IsNullOrEmpty(path))
            {
                BackgroundDic = fReader.ReadBackgroundData(path);
                isRead = true;
            }
            else
            {
                BackgroundDic = new Dictionary<string, FreeBgSet>();
                BackgroundDic["データがありません"] = new FreeBgSet();
            }
            return isRead;
        }

        /// <summary>
        /// 背景位置設定
        /// </summary>
        public void SetBackgroundPosition(Vector3 position)
        {
            GameMain.Instance.BgMgr.SetPos(position);
        }

        /// <summary>
        /// 背景回転設定
        /// </summary>
        public void SetBackgroundRotation(Vector3 rotation)
        {
            GameMain.Instance.BgMgr.SetRot(rotation);
        }

        /// <summary>
        /// 背景サイズ設定
        /// </summary>
        public void SetBackgroundScale(float scale)
        {
            var localScale = new Vector3(scale, scale, scale);
            GameMain.Instance.BgMgr.current_bg_object.transform.localScale = localScale;
        }

        /// <summary>
        /// 背景変更
        /// </summary>
        public void ChangeBackground(FreeBgSet data)
        {
            try
            {
                if (!string.IsNullOrEmpty(data.bgName))
                {
                    if (data.bgName != GetBackgroundName())
                    {
                        DeleteBGObject();
                        GameMain.Instance.BgMgr.ChangeBg(data.bgName);
                    }
                    SetBackgroundPosition(data.position);
                    SetBackgroundRotation(data.rotation);
                    SetBackgroundScale(data.scale);
                }
            }
            catch (Exception)
            {
                Console.WriteLine(string.Format("選択された背景が導入されていません：{0}", data.bgName));
            }
        }

        /// <summary>
        /// ランダム背景変更
        /// </summary>
        public void ChangeRandomBackground()
        {
            var isRead = true;
            if (MyHelper.CheckNull(BackgroundDic))
            {
                isRead = ReadBackgroundData();
                if (isRead)
                {
                    BackgroundIndex = BackgroundDic.Count() - 1;
                }
                else
                {
                    BackgroundIndex = 0;
                }
            }
            if (isRead)
            {
                var bgName = GetBackgroundName();
                var list = new List<string>();
                foreach (var key in BackgroundDic.Keys)
                {
                    var data = BackgroundDic[key];
                    if (data.bgName != bgName && data.isRandom)
                    {
                        list.Add(key);
                    }
                }
                if (!MyHelper.CheckNull(list))
                {
                    var indx = MyHelper.GetRandomIndex(list.Count());
                    ChangeBackground(BackgroundDic[list[indx]]);
                }
            }
        }

        /// <summary>
        /// 背景名取得
        /// </summary>
        public string GetBackgroundName()
        {
            return GameMain.Instance.BgMgr.GetBGName();
        }

        /// <summary>
        /// 背景削除
        /// </summary>
        public int DeleteBackground()
        {
            var backgroundIndex = 0;
            DeleteBGObject();
            if (!MyHelper.CheckNull(BackgroundDic))
            {
                backgroundIndex = BackgroundDic.Count() - 1;
            }
            return backgroundIndex;
        }

        /// <summary>
        /// 背景オブジェクト廃棄
        /// </summary>
        private void DeleteBGObject()
        {
            var mgr = GameMain.Instance.BgMgr;
            mgr.OnDestroy();
            GameObject.Destroy(mgr.current_bg_object);
            mgr.DeleteBg();
        }

        /// <summary>
        /// スカイボックス設定（想定通り機能していない）
        /// </summary>
        public void SetSkybox()
        {
            var skyboxSet = this.SkyboxSet;
            var reader = new FileReader();
            string path;
            if (skyboxSet.isPngFoloder)
            {
                path = reader.GetFilePath(skyboxSet.textureName, MyConst.FOLDER_PNG);
            }
            else
            {
                path = reader.CheckFilePath(skyboxSet.textureName);
            }

            if (!string.IsNullOrEmpty(path))
            {

                skyboxSet.texture = reader.ReadSkyboxTexture(path);
                var material = new Material(Shader.Find(MyConst.SHADER_UNLIGHT_TRANS));
                material.mainTexture = skyboxSet.texture;
                RenderSettings.skybox = material;
                MyHelper.GetCameraMain().clearFlags = CameraClearFlags.Skybox;
            }
            this.SkyboxSet = skyboxSet;
        }

        /// <summary>
        /// スカイボックス解除
        /// </summary>
        public void ResetSkybox()
        {
            MyHelper.GetCameraMain().clearFlags = CameraClearFlags.Color;
            RenderSettings.skybox = null;
            GameObject.Destroy(SkyboxSet.texture);
        }

        /// <summary>
        /// 背景パースリスト読込
        /// </summary>
        public void GetBgPartsList()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_BACKGROUND_PARTS, "");
            if (!string.IsNullOrEmpty(path))
            {
                BgPartsList = fReader.GetBgPartsLabel(path);
            }
        }

        /// <summary>
        /// 背景パーツ読込
        /// </summary>
        public void LoadBgParts(string key)
        {
            if (BgPartsDic.ContainsKey(key))
            {
                DestroyBgParts(key);
            }
            List<FreeBgPartsSet> partsList = new List<FreeBgPartsSet>();
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_BACKGROUND_PARTS, "");
            if (!string.IsNullOrEmpty(path))
            {
                partsList = fReader.ReadBackgroundPartsData(path, key);
            }
            for (int i = 0; i < partsList.Count(); i++)
            {
                var data = partsList[i];
                data.bgData = LoadBgInstance(data.bgName);
                if (data.bgData != null)
                {
                    data.bgData.transform.position = data.position;
                    data.bgData.transform.rotation = Quaternion.Euler(data.rotation);
                    data.bgData.transform.localScale = data.scale;
                    foreach (Transform item in data.bgData.transform)
                    {
                        if (data.partsName.Exists(d => d == item.name))
                        {
                            item.gameObject.SetActive(true);
                        }
                        else
                        {
                            GameObject.Destroy(item.gameObject);
                        }
                    }
                    partsList[i] = data;
                }
            }
            BgPartsDic[key] = partsList;
        }

        /// <summary>
        /// 背景パーツ読込（フリーダンスムービー用ライブステージ）
        /// </summary>
        public List<GameObject> LoadBgPartsLiveStage()
        {
            var parts = new List<GameObject>();
            var data = LoadBgInstance(MyConst.STAGE_LIVE[0]);
            if (data != null)
            {
                foreach (Transform item in data.transform)
                {
                    if (MyConst.PARTS_LIVE_CUSTOM.Contains(item.name))
                    {
                        item.gameObject.SetActive(true);
                        parts.Add(item.gameObject);
                    }
                    else
                    {
                        GameObject.Destroy(item.gameObject);
                    }
                }
            }
            return parts;
        }

        /// <summary>
        /// 背景パーツ読込（フリーダンスムービー用ポールステージ）
        /// </summary>
        public GameObject LoadBgPartsPoleStage()
        {
            var obj = new GameObject();
            var data = LoadBgInstance(MyConst.STAGE_POLE[0]);
            if (data != null)
            {
                foreach (Transform item in data.transform)
                {
                    if (MyConst.PARTS_POLE[0] == item.name)
                    {
                        obj = item.gameObject;
                        var vec = obj.transform.position;
                        vec.z *= -1f;
                        obj.transform.position = vec;
                        vec = obj.transform.eulerAngles;
                        vec.y += 180f;
                        obj.transform.eulerAngles = vec;
                    }
                    else
                    {
                        GameObject.Destroy(item.gameObject);
                    }
                }
            }
            return obj;
        }


        /// <summary>
        /// パーツ廃棄
        /// </summary>
        public void DestroyBgParts(string key)
        {
            var partsList = BgPartsDic[key];
            foreach (var data in partsList)
            {
                GameObject.Destroy(data.bgData);
            }
            BgPartsDic.Remove(key);
        }

        /// <summary>
        /// 背景インスタンス設定
        /// </summary>
        public void SetBgInstance(string bgName)
        {
            bgInstanceParts = LoadBgInstance(bgName);
        }

        /// <summary>
        /// 背景インスタンスラベル取得
        /// </summary>
        public List<string> GetBgInstanceLabelList()
        {
            var labelList = new List<string>();
            if (bgInstanceParts != null)
            {
                foreach (Transform item in bgInstanceParts.transform)
                {
                    labelList.Add(item.name);
                }
            }
            labelList.Add("");
            return labelList;
        }

        /// <summary>
        /// 背景インスタンス廃棄
        /// </summary>
        public void DestroyBgInstance()
        {
            if (bgInstanceParts != null)
            {
                GameObject.Destroy(bgInstanceParts);
                bgInstanceParts = null;
            }
        }

        /// <summary>
        /// 複数インスタンス有効化
        /// </summary>
        public void SetActiveAllBgInstance(bool isActive)
        {
            if (bgInstanceParts != null)
            {
                foreach (Transform item in bgInstanceParts.transform)
                {
                    item.gameObject.SetActive(isActive);
                }
            }
        }

        /// <summary>
        /// 単独インスタンス有効化
        /// </summary>
        public void SetActiveOneBgInstance(string name)
        {
            if (bgInstanceParts != null)
            {
                foreach (Transform item in bgInstanceParts.transform)
                {
                    if (item.name == name)
                    {
                        item.gameObject.SetActive(!item.gameObject.activeSelf);
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// ダンス背景読込
        /// </summary>
        public void LoadDanceBg(Dictionary<string, string> bgDic)
        {
            danceBgDic = new Dictionary<string, GameObject>();
            foreach (var key in bgDic.Keys)
            {
                danceBgDic[key] = LoadBgInstance(bgDic[key]);
            }
        }

        /// <summary>
        /// 背景インスタンス読込
        /// </summary>
        private GameObject LoadBgInstance(string bgName)
        {
            GameObject.Destroy(bgInstanceParts);
            bgInstanceParts = null;

            UnityEngine.Object obj = GameMain.Instance.BgMgr.CreateAssetBundle(bgName);
            if (obj == null)
            {
                obj = Resources.Load(MyConst.FOLDER_BG + bgName);
                if (obj == null)
                {
                    obj = Resources.Load(MyConst.FOLDER_BG2 + bgName);
                }
            }
            if (obj == null)
            {
                Console.WriteLine(string.Format("選択された背景が導入されていません：{0}", bgName));
                return null;
            }
            return UnityEngine.Object.Instantiate(obj) as GameObject;
        }

        /// <summary>
        /// ダンス背景座標設定
        /// </summary>
        public void SetDanceBgTransform(DanceBgSet data)
        {
            if (!MyHelper.CheckNull(danceBgDic))
            {
                var obj = danceBgDic[data.bgName + data.groupNo];
                obj.transform.position = data.transform.stPos;
                obj.transform.rotation = Quaternion.Euler(data.transform.stRot);
                obj.transform.localScale = new Vector3(data.scale, data.scale, data.scale);
            }
        }

        /// <summary>
        /// ダンス背景削除
        /// </summary>
        public void DeleteDanceBg()
        {
            if (!MyHelper.CheckNull(danceBgDic))
            {
                foreach (var key in danceBgDic.Keys.ToList())
                {
                    GameObject.Destroy(danceBgDic[key]);
                    danceBgDic[key] = null;
                }
                MyHelper.ClearDictionary(danceBgDic);
            }
            if (!string.IsNullOrEmpty(SavedBackgroundName))
            {
                FreeBgSet bgSet = new FreeBgSet();
                bgSet.bgName = SavedBackgroundName;
                bgSet.position = Vector3.zero;
                bgSet.rotation = Vector3.zero;
                bgSet.scale = MyConst.SCALE_DEFAULT;
                ChangeBackground(bgSet);
            }
        }

        /// <summary>
        /// 全景パネル設定
        /// </summary>
        private void SetForegroundPanel()
        {
            if (foregroundPanel == null)
            {
                foregroundPanel = new GameObject("ForegroundPanel");
                UnityEngine.Object.DontDestroyOnLoad(foregroundPanel);
                var canvas = foregroundPanel.AddComponent<Canvas>();
                canvas.renderMode = RenderMode.ScreenSpaceOverlay;
            }
        }

        /// <summary>
        /// 全景パネル設定（複数）
        /// </summary>
        public void SetForeground(int index)
        {
            DestoryForeground(index);
            SetForegroundPanel();
            var canvas = foregroundPanel.GetComponent<Canvas>();

            var data = ForegroundSet[index];
            if (!string.IsNullOrEmpty(data.pngName))
            {
                data.image = new GameObject("ForegroundImage" + index).AddComponent<Image>();
                data.image.transform.SetParent(canvas.transform, false);
                data.image.rectTransform.anchoredPosition = Vector3.zero;
                data.image.transform.SetSiblingIndex(index);
                if (!data.pngName.Contains(MyConst.EXTENSION_PNG))
                {
                    data.pngName += MyConst.EXTENSION_PNG;
                }
                var reader = new FileReader();
                var path = Path.Combine(MyHelper.RootFolder, MyConst.FOLDER_PNG);
                path = reader.CheckFilePath(Path.Combine(path, data.pngName));
                if (!string.IsNullOrEmpty(path))
                {
                    var texture = reader.ReadPngTexture(path);
                    data.image.sprite = Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), Vector2.zero);
                    if (data.isFixedSize)
                    {
                        data.image.rectTransform.sizeDelta = new Vector2(data.width, data.height);
                    }
                    else
                    {
                        data.image.rectTransform.anchorMin = new Vector2(0f, 0f);
                        data.image.rectTransform.anchorMax = new Vector2(1f, 1f);
                    }
                    data.image.color
                        = new Color32((byte)MyConst.COLOR_MAX, (byte)MyConst.COLOR_MAX, (byte)MyConst.COLOR_MAX, (byte)data.alpha);
                }
                ForegroundSet[index] = data;
            }
        }

        /// <summary>
        /// 全景性設定削除
        /// </summary>
        public void DestoryForeground(int index)
        {
            var data = ForegroundSet[index];
            if (data.image != null)
            {
                GameObject.Destroy(data.image.sprite);
            }
            GameObject.Destroy(data.image);
            ForegroundSet[index] = data;
        }

        /// <summary>
        /// メイドマスク設定
        /// </summary>
        public void SetMaidMask(List<Maid> maids, MaidManager maidMgr)
        {
            DestoryMaidMask(false);
            maidMaskPanelDic = new Dictionary<int, FreeMaidMaskPanelSet[]>();
            foreach (var maid in maids)
            {
                var slot = maidMgr.GetActiveSlotNo(maid);
                var data = new FreeMaidMaskPanelSet[MyConst.MAID_MASK_VALUE.Count()];
                foreach (var key in MaidMaskDic.Keys)
                {
                    var mask = MaidMaskDic[key];
                    if (mask.isEnabled)
                    {
                        var range = Enumerable.Range(0, 2);
                        if (key == (int)MaidMaskParam.Vag)
                        {
                            range = Enumerable.Range(2, 1);
                        }
                        foreach (var i in range)
                        {
                            data[i] = SetMaidMaskPanel(mask, i, slot * 100 + i);
                        }
                    }
                }
                maidMaskPanelDic[slot] = data;
            }
        }

        /// <summary>
        /// メイドマスク設定（複数）
        /// </summary>
        private FreeMaidMaskPanelSet SetMaidMaskPanel(FreeMaidMaskSet mask, int index, int label)
        {
            Canvas canvas;
            if (maidMaskPanel == null)
            {
                maidMaskPanel = new GameObject("MaidMaskPanel");
                canvas = maidMaskPanel.AddComponent<Canvas>();
                canvas.renderMode = RenderMode.ScreenSpaceOverlay;
            }
            else
            {
                canvas = maidMaskPanel.GetComponent<Canvas>();
            }

            var data = new FreeMaidMaskPanelSet();
            data.image = new GameObject("MaskImage" + label).AddComponent<Image>();
            data.image.transform.SetParent(canvas.transform, false);
            data.image.rectTransform.anchoredPosition = Vector3.zero;

            var texture = GetTexture(mask.pngName);
            data.image.sprite = Sprite.Create(texture, new Rect(0, 0, texture.width, texture.height), Vector2.zero);
            data.image.rectTransform.sizeDelta = new Vector2(mask.width, mask.height);
            data.image.color = mask.color;
            data.image.material.shader.name = MyConst.SHADER_LIGHTED_TRANS;
            data.apname = MyConst.MAID_MASK_VALUE[index];
            data.mask = mask;
            return data;
        }

        /// <summary>
        /// メイドマスク移動
        /// </summary>
        public void MoveMaidMask(List<Maid> maids, MaidManager maidMgr, Size<int> size)
        {
            var w = size.width / (float)MyConst.BASE_WINDOW_WIDTH;
            var h = size.height / (float)MyConst.BASE_WINDOW_HEIGHT;
            var scale = w < h ? w : h;
            maidMaskPanel.GetComponent<Canvas>().GetOrAddComponent<CanvasScaler>().scaleFactor = scale;

            foreach (var maid in maids)
            {
                var slot = maidMgr.GetActiveSlotNo(maid);
                if (maidMaskPanelDic.ContainsKey(slot))
                {
                    var mask = maidMaskPanelDic[slot];
                    for (int i = 0; i < mask.Count(); i++)
                    {
                        if (!string.IsNullOrEmpty(mask[i].apname))
                        {
                            Vector3 pos;
                            Quaternion rot;
                            Vector3 sca;
                            maid.body0.GetAttachPointWorld(TBody.SlotID.body, mask[i].apname, out pos, out rot, out sca);
                            var tm = MyHelper.GetCameraMainTransform();
                            var d = Vector3.Distance(tm.position, pos);
                            d = Mathf.Exp(-d / 2.5f);

                            mask[i].image.rectTransform.sizeDelta = new Vector2(mask[i].mask.width * d, mask[i].mask.height * d);
                            mask[i].image.rectTransform.position = RectTransformUtility.WorldToScreenPoint(MyHelper.GetCameraMain(), pos);
                        }
                    }
                    maidMaskPanelDic[slot] = mask;
                }
            }
        }

        /// <summary>
        /// メイドマスク破棄
        /// </summary>
        public void DestoryMaidMask(bool isUnabled)
        {
            if (!MyHelper.CheckNull(maidMaskPanelDic))
            {
                foreach (var key in maidMaskPanelDic.Keys)
                {
                    for (int i = 0; i < maidMaskPanelDic[key].Count(); i++)
                    {
                        var data = maidMaskPanelDic[key][i];
                        if (data.image != null)
                        {
                            GameObject.Destroy(data.image.sprite);
                        }
                        GameObject.Destroy(data.image);
                        maidMaskPanelDic[key][i] = data;
                    }
                }
            }
            MyHelper.ClearDictionary(maidMaskPanelDic);
            if (isUnabled)
            {
                foreach (var key in MaidMaskDic.Keys.ToList())
                {
                    var data = MaidMaskDic[key];
                    data.isEnabled = false;
                    MaidMaskDic[key] = data;
                }
            }
        }

        /// <summary>
        /// メイドマスク設定判定
        /// </summary>
        public bool IsMaidMask()
        {
            return !MyHelper.CheckNull(maidMaskPanelDic);
        }


        /// <summary>
        /// テクスチャー取得
        /// </summary>
        private Texture2D GetTexture(string pngName)
        {
            Texture2D texture = null;
            if (!pngName.Contains(MyConst.EXTENSION_PNG))
            {
                pngName += MyConst.EXTENSION_PNG;
            }
            var reader = new FileReader();
            var path = Path.Combine(MyHelper.RootFolder, MyConst.FOLDER_PNG);
            path = reader.CheckFilePath(Path.Combine(path, pngName));
            if (!string.IsNullOrEmpty(path))
            {
                texture = reader.ReadPngTexture(path);
            }
            return texture;
        }
    }

    /// <summary>
    /// フリーダンスオブジェクト処理管理
    /// </summary>
    public class DanceObjectManager
    {
        public Dictionary<string, Texture2D> PrimitiveTexture { get; set; }
        public Dictionary<string, GameObject> DancePrefab { get; set; }
        public Dictionary<string, GameObject> DancePrimitive { get; set; }
        public Dictionary<string, GameObject> DanceParticle { get; set; }
        public Dictionary<string, GameObject> DanceLight { get; set; }
        public Dictionary<string, SpriteRenderer> PngSpriteRenderer { get; set; }

        public List<DanceItemSet> ItemData { get; set; }
        public List<DancePrefabSet> PrefabData { get; set; }
        public List<DanceMaidPrefabSet> MaidPrefabData { get; set; }
        public List<DancePrimitiveSet> PrimitiveData { get; set; }
        public List<DancePartticleSet> ParticleData { get; set; }
        public List<DanceParticle> DanceParticleData { get; set; }
        public List<DanceCameraMotionSet> DanceScreenData { get; set; }
        public List<DanceLightSet> LightData { get; set; }

        private Dictionary<int, float> maidHeadY;
        private List<GameObject> movieParts;
        private FreeBubbleLameSet bubbleSet;
        private FreeLineSet lineSet;
        private readonly VideoManager videoMgr;

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public DanceObjectManager()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_SETTING_DANCE_EFFECT, "");
            if (!string.IsNullOrEmpty(path))
            {
                bubbleSet = fReader.GetSettingOfDanceEffectBubble(path);
                lineSet = fReader.GetSettingOfDanceEffectLine(path);
            }
            videoMgr = new VideoManager(false);
        }

        public DanceObjectManager(FreeLineSet lineSet)
        {
            this.lineSet = lineSet;
        }

        /// <summary>
        /// オブジェクト抹消処理
        /// </summary>
        public void DestroyObject()
        {
            if (!MyHelper.CheckNull(DanceScreenData))
            {
                for (int i = 0; i < DanceScreenData.Count(); i++)
                {
                    if (DanceScreenData[i].rTexture != null)
                    {
                        DanceScreenData[i].rTexture.Release();
                    }
                    if (DanceScreenData[i].plane != null)
                    {
                        GameObject.Destroy(DanceScreenData[i].plane);
                    }
                    if (DanceScreenData[i].camera != null && i != MyConst.CAMERA_MAIN)
                    {
                        GameObject.Destroy(DanceScreenData[i].camera);
                    }
                }
            }
            if (!MyHelper.CheckNull(PngSpriteRenderer))
            {
                foreach (var key in PngSpriteRenderer.Keys)
                {
                    GameObject.Destroy(PngSpriteRenderer[key]);
                }
            }
            if (!MyHelper.CheckNull(DancePrefab))
            {
                foreach (var key in DancePrefab.Keys)
                {
                    GameObject.Destroy(DancePrefab[key]);
                }
                Resources.UnloadUnusedAssets();
            }
            if (!MyHelper.CheckNull(DancePrimitive))
            {
                foreach (var key in DancePrimitive.Keys)
                {
                    GameObject.Destroy(DancePrimitive[key]);
                }
            }
            if (!MyHelper.CheckNull(DanceParticle))
            {
                foreach (var key in DanceParticle.Keys)
                {
                    GameObject.Destroy(DanceParticle[key]);
                }
            }
            if (!MyHelper.CheckNull(PrimitiveTexture))
            {
                foreach (var key in PrimitiveTexture.Keys)
                {
                    GameObject.Destroy(PrimitiveTexture[key]);
                }
            }
            if (!MyHelper.CheckNull(DanceLight))
            {
                foreach (var key in DanceLight.Keys)
                {
                    GameObject.Destroy(DanceLight[key]);
                }
            }
            if (!MyHelper.CheckNull(movieParts))
            {
                foreach (var obj in movieParts)
                {
                    GameObject.Destroy(obj);
                }
            }
            videoMgr.EndVideo();

            MyHelper.ClearDictionary(PngSpriteRenderer);
            MyHelper.ClearDictionary(PrimitiveTexture);
            MyHelper.ClearDictionary(DancePrefab);
            MyHelper.ClearList(DanceScreenData);
            MyHelper.ClearList(ItemData);
            MyHelper.ClearList(PrefabData);
            MyHelper.ClearList(MaidPrefabData);
            MyHelper.ClearList(PrimitiveData);
            MyHelper.ClearList(ParticleData);
            MyHelper.ClearList(LightData);
        }

        /// <summary>
        /// プレハブ設定複製処理
        /// </summary>
        public void DuplicatePrefabData(List<Maid> maids, MaidManager maidMgr)
        {
            var list = new List<DancePrefabSet>();
            foreach (var data in PrefabData)
            {
                if (data.maidSlotNo > MyConst.PRE_INDEX && CheckAllMaids(data.option))
                {
                    var ms = maids.FindAll(m => maidMgr.GetDanceSlotNo(m) == data.maidSlotNo && maidMgr.GetCustomSlotNo(m) != data.maidSlotNo);
                    if (!MyHelper.CheckNull(ms))
                    {
                        foreach (var maid in ms)
                        {
                            var pos = maidMgr.GetStockDancePosition(maid);
                            var rot = maidMgr.GetStockDanceRotation(maid);
                            var d = data;
                            var customSlotNo = maidMgr.GetCustomSlotNo(maid);
                            d.group = GetDuplicatedGroup(d.group, customSlotNo);
                            d.maidSlotNo = customSlotNo;
                            d.transform.stPos += pos;
                            d.transform.edPos += pos;
                            d.transform.stRot += rot;
                            d.transform.edRot += rot;
                            list.Add(d);
                        }
                    }
                }
            }
            if (!MyHelper.CheckNull(list))
            {
                foreach (var l in list)
                {
                    PrefabData.Add(l);
                }
            }
        }

        /// <summary>
        /// プリミティブ設定複製処理
        /// </summary>
        public void DuplicatePrimitiveData(List<Maid> maids, MaidManager maidMgr)
        {
            var list = new List<DancePrimitiveSet>();
            foreach (var data in PrimitiveData)
            {
                if (data.maidSlotNo > MyConst.PRE_INDEX && CheckAllMaids(data.option))
                {
                    var ms = maids.FindAll(m => maidMgr.GetDanceSlotNo(m) == data.maidSlotNo && maidMgr.GetCustomSlotNo(m) != data.maidSlotNo);
                    if (!MyHelper.CheckNull(ms))
                    {
                        foreach (var maid in ms)
                        {
                            var pos = maidMgr.GetStockDancePosition(maid);
                            var rot = maidMgr.GetStockDanceRotation(maid);
                            var d = data;
                            var customSlotNo = maidMgr.GetCustomSlotNo(maid);
                            d.group = GetDuplicatedGroup(d.group, customSlotNo);
                            d.maidSlotNo = customSlotNo;
                            d.transform.stPos += pos;
                            d.transform.edPos += pos;
                            d.transform.stRot += rot;
                            d.transform.edRot += rot;
                            list.Add(d);
                        }
                    }
                }
            }
            if (!MyHelper.CheckNull(list))
            {
                foreach (var l in list)
                {
                    PrimitiveData.Add(l);
                }
            }
        }

        /// <summary>
        /// プレハブ設定調整処理
        /// </summary>
        public void AdjustPrefabData(List<Maid> maids, MaidManager maidMgr)
        {
            for (int i = 0; i < PrefabData.Count(); i++)
            {
                var data = PrefabData[i];
                if (data.option.ToLower().Contains(MyConst.OBJECT_OPTION_HEIGHT_ADJUSTMENT))
                {
                    foreach(var maid in maids)
                    {
                        var customSlotNo = maidMgr.GetCustomSlotNo(maid);
                        if(data.maidSlotNo == customSlotNo)
                        {
                            var y = maid.body0.GetBone(MyConst.BONE_ALL).transform.position.y - MyConst.STAND_HEIGHT_BASE;
                            if (y < 0)
                            {
                                y *= MyConst.STAND_HEIGHT_LOW;
                            }
                            else
                            {
                                y *= MyConst.STAND_HEIGHT_TALL; 
                            }
                            data.transform.stPos.y += y;
                            data.transform.edPos.y += y;
                            data.transform.stSca.y += y;
                            data.transform.edSca.y += y;
                            PrefabData[i] = data;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// プリミティブ設定調整処理
        /// </summary>
        public void AdjustPrimitiveData(List<Maid> maids, MaidManager maidMgr)
        {
            var cylinderName = Enum.GetName(typeof(PrimitiveType), PrimitiveType.Cylinder).ToLower();
            for (int i = 0; i < PrimitiveData.Count(); i++)
            {
                var data = PrimitiveData[i];
                if (data.type.ToLower() == cylinderName &&
                    data.option.ToLower().Contains(MyConst.OBJECT_OPTION_HEIGHT_ADJUSTMENT))
                {
                    foreach (var maid in maids)
                    {
                        var customSlotNo = maidMgr.GetCustomSlotNo(maid);
                        if (data.maidSlotNo == customSlotNo)
                        {
                            var y = maid.body0.GetBone(MyConst.BONE_ALL).transform.position.y - MyConst.STAND_HEIGHT_BASE;
                            if (y < 0)
                            {
                                y *= MyConst.STAND_HEIGHT_TALL;
                            }
                            else
                            {
                                y *= MyConst.STAND_HEIGHT_LOW;
                            }
                            data.transform.stPos.y += y;
                            data.transform.edPos.y += y;
                            data.transform.stSca.y += y;
                            data.transform.edSca.y += y;
                            PrimitiveData[i] = data;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// ライト設定複製処理
        /// </summary>
        public void DuplicateLightData(List<Maid> maids, MaidManager maidMgr)
        {
            var list = new List<DanceLightSet>();
            foreach (var data in LightData)
            {
                if (data.maidSlotNo > MyConst.PRE_INDEX && CheckAllMaids(data.option))
                {
                    var ms = maids.FindAll(m => maidMgr.GetDanceSlotNo(m) == data.maidSlotNo && maidMgr.GetCustomSlotNo(m) != data.maidSlotNo);
                    if (!MyHelper.CheckNull(ms))
                    {
                        foreach (var maid in ms)
                        {
                            var pos = maidMgr.GetStockDancePosition(maid);
                            var rot = maidMgr.GetStockDanceRotation(maid);
                            var d = data;
                            var customSlotNo = maidMgr.GetCustomSlotNo(maid);
                            d.group = GetDuplicatedGroup(d.group, customSlotNo);
                            d.maidSlotNo = customSlotNo;
                            d.transform.stPos += pos;
                            d.transform.edPos += pos;
                            d.transform.stRot += rot;
                            d.transform.edRot += rot;
                            list.Add(d);
                        }
                    }
                }
            }
            if (!MyHelper.CheckNull(list))
            {
                foreach (var l in list)
                {
                    LightData.Add(l);
                }
            }
        }

        /// <summary>
        /// 複製処理用グループ取得
        /// </summary>
        private int GetDuplicatedGroup(int group, int customSlotNo)
        {
            return group + customSlotNo * MyConst.DUPLICATE_GROUP;
        }

        /// <summary>
        /// 全メイド適用チェック
        /// </summary>
        private bool CheckAllMaids(string option)
        {
            return option.ToLower().Contains(MyConst.OBJECT_OPTION_ALL_MAIDS);
        }


        /// <summary>
        /// フリーダンス背景変更
        /// </summary>
        public int ChangeFreeDanceBg(List<DanceBgSet> changeBg, float bgmTime, int danceBgIndex, bool isFreeStoped, ref BackgroundManager bgMgr)
        {
            if (danceBgIndex < changeBg.Count())
            {
                if (changeBg[danceBgIndex].changeTime <= bgmTime)
                {
                    var isChange = false;
                    if (changeBg.Count() - 1 == danceBgIndex)
                    {
                        isChange = true;
                    }
                    else if (danceBgIndex < changeBg.Count() &&
                             (bgmTime < changeBg[danceBgIndex + 1].changeTime ||
                              changeBg[danceBgIndex].changeTime == changeBg[danceBgIndex + 1].changeTime))
                    {
                        isChange = true;
                    }
                    if (isChange && !isFreeStoped)
                    {
                        bgMgr.SetDanceBgTransform(changeBg[danceBgIndex]);
                    }
                    danceBgIndex++;
                }
            }
            return danceBgIndex;
        }

        /// <summary>
        /// フリーダンスPNG画像変更
        /// </summary>
        public void ChangeFreeDancePng(List<DancePngSet> changePng, float bgmTime)
        {
            List<string> keys = new List<string>();
            foreach (var data in changePng)
            {
                var key = data.pngName;
                if (PngSpriteRenderer.ContainsKey(key))
                {
                    if (data.stTime <= bgmTime && bgmTime < data.edTime)
                    {
                        keys.Add(key);
                        PngSpriteRenderer[key].transform.position = data.transform.stPos;
                        PngSpriteRenderer[key].transform.rotation = Quaternion.Euler(data.transform.stRot);
                    }
                    else
                    {
                        PngSpriteRenderer[key].enabled = false;
                    }
                }
            }
            foreach (var key in keys)
            {
                PngSpriteRenderer[key].enabled = true;
            }
        }

        /// <summary>
        /// テクスチャー読込(Primitive)
        /// </summary>
        public void LoadDancePrimitiveTexture()
        {
            var textureList = PrimitiveData.Where(d => !string.IsNullOrEmpty(d.texture)).Select(d => d.texture).ToList();
            if (!MyHelper.CheckNull(textureList))
            {
                var path = Path.Combine(MyHelper.RootFolder, MyConst.FOLDER_PNG);
                PrimitiveTexture = new FileReader().GetPngTexturFile(textureList, path);
            }
        }

        /// <summary>
        /// メイド初期頭位置保持
        /// </summary>
        public void KeepMaidPositionY(List<Maid> maids, MaidManager maidMgr)
        {
            if(PrefabData.Exists(d => d.option.ToLower().Contains(MyConst.OBJECT_OPTION_STAND_MIKE)))
            {
                maidHeadY = new Dictionary<int, float>();
                foreach (var maid in maids)
                {
                    maidHeadY[maidMgr.GetCustomSlotNo(maid)] = maid.body0.GetBone(MyConst.BONE_HEAD).transform.position.y;
                }
            }
        }

        /// <summary>
        /// フリーダンスプレハブ変更
        /// </summary>
        public void ChangeFreeDancePrefab(float bgmTime, List<Maid> maids, MaidManager maidMgr)
        {
            var bubble = new Dictionary<string, bool>();
            var change = new List<string>();
            for (int i = 0; i < PrefabData.Count(); i++)
            {
                var data = PrefabData[i];
                var key = data.name + data.group;
                bubble[key] = data.isBubble;
                if (DancePrefab.ContainsKey(key))
                {
                    if (data.stTime <= bgmTime && bgmTime < data.edTime)
                    {
                        change.Add(key);
                        var deltaTime = bgmTime - data.stTime;
                        if (data.lerpTime == 0 && 1 <= deltaTime)
                        {
                            data.lerpTime = Mathf.Clamp01(deltaTime / data.deltaTime);
                        }
                        else
                        {
                            data.lerpTime += Mathf.Clamp01(1 / data.deltaTime * Time.deltaTime);
                        }

                        var position = Vector3.Lerp(data.transform.stPos, data.transform.edPos, data.lerpTime);
                        if (data.option.ToLower().Contains(MyConst.OBJECT_OPTION_STAND_MIKE) && !MyHelper.CheckNull(maids))
                        {
                            foreach (var maid in maids)
                            {
                                var slotNo = maidMgr.GetCustomSlotNo(maid);
                                if (slotNo == data.maidSlotNo)
                                {  
                                    position.y += maidHeadY[slotNo];
                                    break;
                                }
                            }
                        }
                        DancePrefab[key].transform.position = position;
                        DancePrefab[key].transform.rotation
                            = Quaternion.Lerp(Quaternion.Euler(data.transform.stRot),
                                              Quaternion.Euler(data.transform.edRot), data.lerpTime);
                        DancePrefab[key].transform.localScale
                            = Vector3.Lerp(data.transform.stSca, data.transform.edSca, data.lerpTime);
                        PrefabData[i] = data;
                    }
                }
            }
            foreach (var key in change)
            {
                DancePrefab[key] = SetActiveOfPrefabe(DancePrefab[key], true, bubble[key]);
            }
            for (int i = 0; i < PrefabData.Count(); i++)
            {
                var data = PrefabData[i];
                var key = data.name + data.group;
                if (!change.Contains(key))
                {
                    if (!data.option.ToLower().Contains(MyConst.OBJECT_OPTION_NOTDEACTIVE))
                    {
                        DancePrefab[key] = SetActiveOfPrefabe(DancePrefab[key], false, bubble[key]);
                    }
                    data.lerpTime = 0;
                    PrefabData[i] = data;
                }
            }
        }

        /// <summary>
        /// プレハブ読込
        /// </summary>
        public void LoadDancePrefabObject()
        {
            DancePrefab = new Dictionary<string, GameObject>();
            foreach (var data in PrefabData)
            {
                var key = data.name + data.group;
                var path = "";
                GameObject obj = null;
                if (!DancePrefab.ContainsKey(key))
                {
                    path = MyConst.FOLDER_PREFAB + data.name;
                    obj = GameObject.Instantiate(Resources.Load(path)) as GameObject;
                    if (obj != null)
                    {
                        obj = SetActiveOfPrefabe(obj, false, data.isBubble);
                        DancePrefab[key] = obj;
                    }
                }
            }
            if (MyHelper.CheckNull(DancePrefab))
            {
                DancePrefab = null;
            }
            Resources.UnloadUnusedAssets();
        }

        /// <summary>
        /// フリーダンスプリミティブ変更
        /// </summary>
        public void ChangeFreeDancePrimitive(float bgmTime, List<Maid> maids)
        {
            List<string> change = new List<string>();
            for (int i = 0; i < PrimitiveData.Count(); i++)
            {
                var data = PrimitiveData[i];
                var key = data.type + data.group;
                if (DancePrimitive.ContainsKey(key) && data.stTime <= bgmTime && bgmTime < data.edTime)
                {
                    change.Add(key);
                    var deltaTime = bgmTime - data.stTime;
                    if (data.lerpTime == 0 && 1 <= deltaTime)
                    {
                        data.lerpTime = Mathf.Clamp01(deltaTime / data.deltaTime);
                    }
                    else
                    {
                        data.lerpTime += Mathf.Clamp01(1 / data.deltaTime * Time.deltaTime);
                    }
                    DancePrimitive[key].transform.position
                        = Vector3.Lerp(data.transform.stPos, data.transform.edPos, data.lerpTime);
                    DancePrimitive[key].transform.rotation
                        = Quaternion.Lerp(Quaternion.Euler(data.transform.stRot),
                                          Quaternion.Euler(data.transform.edRot), data.lerpTime);
                    DancePrimitive[key].transform.localScale
                        = Vector3.Lerp(data.transform.stSca, data.transform.edSca, data.lerpTime);

                    var material = DancePrimitive[key].GetComponent<Renderer>().material;
                    if (!string.IsNullOrEmpty(data.shader) && material.shader.name != data.shader)
                    {
                        var shader = Shader.Find(data.shader);
                        if (shader != null)
                        {
                            material.shader = shader;
                            material.mainTexture = null;
                        }
                    }
                    if (!data.isFlashing)
                    {
                        if (data.option.ToLower().Contains(MyConst.OBJECT_OPTION_RANDOM_COLOR))
                        {
                            if (data.colorTimer == 0)
                            {
                                material.color = MyHelper.GetRandomColor(material.color.a);
                                data.colorTimer += Time.deltaTime;
                            }
                            else if (MyConst.MIN_RANDOM_TIME < data.colorTimer ||
                                     MyConst.MIN_RANDOM_TIME / 2f <= data.colorTimer && MyHelper.GetRandomIndex(10) == 0)
                            {
                                data.colorTimer = 0;
                            }
                            else
                            {
                                data.colorTimer += Time.deltaTime;
                            }
                        }
                        else if(data.colorTimer == 0)
                        {
                            var color = Vector4.Lerp(data.stColor, data.edColor, data.lerpTime);
                            material.color = new Color32((byte)color.x, (byte)color.y, (byte)color.z, (byte)color.w);
                        }
                    }

                    if (material.mainTexture != null)
                    {
                        if (material.mainTexture.name == data.texture)
                        {
                            data.texture = "";
                        }
                    }
                    if (!string.IsNullOrEmpty(data.texture) &&
                        !MyHelper.CheckNull(PrimitiveTexture) && PrimitiveTexture.ContainsKey(data.texture))
                    {
                        material.mainTexture = PrimitiveTexture[data.texture];
                        if (1 < data.textureSize.x || 1 < data.textureSize.y)
                        {
                            material.mainTexture.wrapMode = TextureWrapMode.Repeat;
                            material.mainTexture.filterMode = FilterMode.Point;
                            material.mainTextureScale = data.textureSize;
                        }
                        else
                        {
                            material.mainTexture.wrapMode = TextureWrapMode.Clamp;
                            material.mainTexture.filterMode = FilterMode.Bilinear;
                        }
                    }
                    DancePrimitive[key].GetComponent<Renderer>().material = material;

                    if (data.type.ToLower().Contains(MyConst.OBJECT_PRIMITIVE_LINE))
                    {
                        var type = data.type.Split(MyConst.DELIMITER_STRING)[1].ToLower();
                        TransformLine(DancePrimitive[key], type);
                    }
                    else
                    {
                        var y = -1f;
                        var cylinderName = Enum.GetName(typeof(PrimitiveType), PrimitiveType.Cylinder).ToLower();
                        if (data.type.ToLower() == cylinderName &&
                           data.option.ToLower().Contains(MyConst.OBJECT_OPTION_LIFTUP))
                        {
                            var tmY = DancePrimitive[key].transform.position.y;
                            if (data.transform.stPos.y < data.transform.edPos.y && 0 <= data.transform.edPos.y)
                            {
                                y = Math.Abs(data.transform.stPos.y) + tmY;
                            }
                            else if (data.transform.edPos.y < data.transform.stPos.y && 0 <= data.transform.stPos.y)
                            {
                                y = data.transform.stPos.y + tmY;
                            }
                            else if (data.transform.edPos.y == data.transform.stPos.y)
                            {
                                y = data.transform.edPos.y + data.transform.edSca.y;
                                if (data.transform.stPos.y == 0)
                                {
                                    change.Remove(key);
                                }
                            }
                        }

                        if (y >= 0 && !MyHelper.CheckNull(maids))
                        {
                            foreach (var maid in maids)
                            {
                                var p = maid.transform.position;
                                if (p.y != y && Math.Abs(p.z - data.transform.stPos.z) < 100f)
                                {
                                    p.y = y;
                                    maid.transform.position = p;
                                }
                            }
                        }
                    }

                    if (data.isFlashing)
                    {
                        if (data.colorTimer == 0 && MyHelper.GetRandomIndex(lineSet.flashingRndomTime) == 0)
                        {
                            DancePrimitive[key].GetComponent<Renderer>().material.color = new Color32((byte)0, (byte)0, (byte)0, (byte)255);
                            data.colorTimer = lineSet.flashingInterval * -1;
                        }
                        else if (data.colorTimer > 0)
                        {
                            DancePrimitive[key].GetComponent<Renderer>().material.color = new Color32((byte)data.stColor.x, (byte)data.stColor.y, (byte)data.stColor.z, (byte)data.stColor.w);
                            data.colorTimer = 0;
                        }
                        else if (data.colorTimer < 0)
                        {
                            data.colorTimer += Time.deltaTime;
                        }
                    }
                    PrimitiveData[i] = data;
                }
            }

            foreach (var key in change)
            {
                DancePrimitive[key].SetActive(true);
            }
            for (int i = 0; i < PrimitiveData.Count(); i++)
            {
                var data = PrimitiveData[i];
                var key = data.type + data.group;
                if (!change.Contains(key))
                {
                    DancePrimitive[key].SetActive(false);
                    data.lerpTime = 0;
                    PrimitiveData[i] = data;
                }
            }
        }

        /// <summary>
        /// フリーダンスプリミティブ作成
        /// </summary>
        public void CreateDancePrimitive()
        {
            DancePrimitive = new Dictionary<string, GameObject>();
            foreach (var data in PrimitiveData)
            {
                var key = data.type + data.group;
                var type = (PrimitiveType)MyConst.ENUM_EX_VALUE;
                GameObject obj = null;
                if (!DancePrimitive.ContainsKey(key))
                {
                    if (data.type.ToLower().Contains(MyConst.OBJECT_PRIMITIVE_LINE))
                    {
                        obj = CreateDanceLineObject(key, data.type.Split(MyConst.DELIMITER_STRING)[1].ToLower());
                    }
                    else
                    {
                        foreach (PrimitiveType value in Enum.GetValues(typeof(PrimitiveType)))
                        {
                            var name = Enum.GetName(typeof(PrimitiveType), value).ToLower();
                            if (data.type.ToLower() == name)
                            {
                                type = value;
                                break;
                            }
                        }
                        if (type != (PrimitiveType)MyConst.ENUM_EX_VALUE)
                        {
                            obj = GameObject.CreatePrimitive(type);
                        }
                    }
                    if (obj != null)
                    {
                        obj.SetActive(false);
                        DancePrimitive[key] = obj;
                    }
                }
            }
            if (MyHelper.CheckNull(DancePrimitive))
            {
                DancePrimitive = null;
            }
        }

        /// <summary>
        /// フリーダンスパーティクル変更
        /// </summary>
        public void ChangeFreeDanceParticle(float bgmTime)
        {
            List<string> change = new List<string>();
            for (int i = 0; i < ParticleData.Count(); i++)
            {
                var data = ParticleData[i];
                var key = data.label + data.group;
                if (DanceParticle.ContainsKey(key) && data.stTime <= bgmTime && bgmTime < data.edTime)
                {
                    change.Add(key);
                    var deltaTime = bgmTime - data.stTime;
                    if (data.lerpTime == 0 && 1 <= deltaTime)
                    {
                        data.lerpTime = Mathf.Clamp01(deltaTime / data.deltaTime);
                    }
                    else
                    {
                        data.lerpTime += Mathf.Clamp01(1 / data.deltaTime * Time.deltaTime);
                    }
                    DanceParticle[key].transform.position
                        = Vector3.Lerp(data.transform.stPos, data.transform.edPos, data.lerpTime);
                    DanceParticle[key].transform.rotation
                        = Quaternion.Lerp(Quaternion.Euler(data.transform.stRot),
                                          Quaternion.Euler(data.transform.edRot), data.lerpTime);
                    DanceParticle[key].transform.localScale
                        = Vector3.Lerp(data.transform.stSca, data.transform.edSca, data.lerpTime);
                    ParticleData[i] = data;
                }
            }

            var mgr = new StageParticleManager();
            foreach (var key in change)
            {
                DanceParticle[key] = mgr.PlayDanceParticle(true, DanceParticle[key]);
            }
            for (int i = 0; i < ParticleData.Count(); i++)
            {
                var data = ParticleData[i];
                var key = data.label + data.group;
                if (!change.Contains(key))
                {
                    DanceParticle[key] = mgr.PlayDanceParticle(false, DanceParticle[key]);
                    data.lerpTime = 0;
                    ParticleData[i] = data;
                }
            }
        }

        /// <summary>
        /// フリーダンスパーティクル作成
        /// </summary>
        public void CreateDanceParticle()
        {
            DanceParticle = new Dictionary<string, GameObject>();
            foreach (var data in ParticleData)
            {
                var key = data.label + data.group;
                if (!DanceParticle.ContainsKey(key))
                {
                    var p = DanceParticleData.FirstOrDefault(d => d.label == data.label);
                    if (!string.IsNullOrEmpty(p.label))
                    {
                        DanceParticle[key] = new StageParticleManager().UpdateParticle(p, true, false);
                    }
                }
            }
            if (MyHelper.CheckNull(DanceParticle))
            {
                DanceParticle = null;
            }
        }

        /// <summary>
        /// フリーダンスライン作成
        /// </summary>
        public GameObject CreateDanceLineObject(string key, string type)
        {
            var obj = new GameObject(key);
            var renderer = obj.GetOrAddComponent<LineRenderer>();
            if (renderer != null)
            {
                foreach (StageLineType value in Enum.GetValues(typeof(StageLineType)))
                {
                    if (type == Enum.GetName(typeof(StageLineType), value).ToLower())
                    {
                        var positionCount = 0;
                        switch (value)
                        {
                            case StageLineType.Square:
                                positionCount = 4;
                                break;
                        }
                        renderer.positionCount = positionCount;
                        var point = GetDefaultPoint(value, positionCount);
                        for (int i = 0; i < positionCount; i++)
                        {
                            renderer.SetPosition(i, point[i]);
                        }
                    }
                }
                renderer.startWidth = lineSet.frameWidth;
                renderer.endWidth = lineSet.frameWidth;
                renderer.numCornerVertices = lineSet.numCornerVertices;
                renderer.loop = true;
                renderer.useWorldSpace = true;
                renderer.enabled = true;
            }
            return obj;
        }

        /// <summary>
        /// フリーダンスライン初期位置取得
        /// </summary>
        public Vector3[] GetDefaultPoint(StageLineType type, int positionCount)
        {
            var vec = new Vector3[positionCount];
            switch (type)
            {
                case StageLineType.Square:
                    var length = lineSet.length / 2;
                    vec[0] = new Vector3(length, length, 0f);
                    vec[1] = new Vector3(-length, length, 0f);
                    vec[2] = new Vector3(-length, -length, 0f);
                    vec[3] = new Vector3(length, -length, 0f);
                    break;
            }
            return vec;
        }

        /// <summary>
        /// フリーダンスライン位置設定
        /// </summary>
        public void TransformLine(GameObject obj, string type)
        {
            var renderer = obj.GetComponent<LineRenderer>();
            var matrix = obj.transform.localToWorldMatrix;
            foreach (StageLineType value in Enum.GetValues(typeof(StageLineType)))
            {
                if (type == Enum.GetName(typeof(StageLineType), value).ToLower())
                {
                    var positionCount = renderer.positionCount;
                    var point = GetDefaultPoint(value, positionCount);
                    for (int j = 0; j < positionCount; j++)
                    {
                        Vector3 position = matrix * new Vector4(point[j].x, point[j].y, point[j].z, 1f);
                        renderer.SetPosition(j, position);
                    }
                }
            }
        }

        /// <summary>
        /// スクリーン作成
        /// </summary>
        public void CreateScreen(RenderTextureSet renderTextureSet)
        {
            for (int i = 1; i < DanceScreenData.Count(); i++)
            {
                var screenData = DanceScreenData[i];
                if (screenData.isMotionOn)
                {
                    screenData.camera = new GameObject("Camera" + i).GetOrAddComponent<Camera>();
                    if (screenData.rTexture == null)
                    {
                        screenData.rTexture = new RenderTexture(renderTextureSet.width, renderTextureSet.height, MyConst.RENDER_TEXTURE_DEPTH);
                        screenData.rTexture.antiAliasing = MyConst.RENDER_TEXTURE_ANTIALIASING;
                    }
                    screenData.camera.targetTexture = screenData.rTexture;
                    screenData.camera.backgroundColor = MyHelper.GetCameraMain().backgroundColor;
                    screenData.camera.nearClipPlane = MyHelper.GetCameraMain().nearClipPlane;
                    screenData.camera.farClipPlane = MyHelper.GetCameraMain().farClipPlane;
                    if (screenData.plane == null)
                    {
                        screenData.plane = GameObject.CreatePrimitive(PrimitiveType.Plane);
                        screenData.plane.transform.position = screenData.position;
                        screenData.plane.transform.rotation = Quaternion.Euler(screenData.rotation);
                        screenData.plane.transform.localScale = screenData.scale;
                        screenData.plane.gameObject.layer = MyConst.CAMERA_LAYER_SCREEN_MASK;
                        var material = new Material(Shader.Find(MyConst.SHADER_UNLIGHT));
                        material.mainTexture = screenData.rTexture;
                        material.color = Color.white;
                        screenData.plane.GetComponent<Renderer>().material = material;
                    }
                    if (renderTextureSet.isMask)
                    {
                        screenData.camera.cullingMask &= ~(1 << screenData.plane.gameObject.layer);
                    }
                    DanceScreenData[i] = screenData;
                }
            }
        }

        /// <summary>
        /// フリーダンスライト変更
        /// </summary>
        public void ChangeFreeDanceLight(float bgmTime, StageLightManager lightMgr, List<Maid> maids, MaidManager maidMgr)
        {
            List<string> keys = new List<string>();
            for (int i = 0; i < LightData.Count(); i++)
            {
                var data = LightData[i];
                var key = data.type + data.group;
                if (DanceLight.ContainsKey(key))
                {
                    if (data.stTime <= bgmTime && bgmTime < data.edTime)
                    {
                        keys.Add(key);
                        var deltaTime = bgmTime - data.stTime;
                        if (data.lerpTime == 0 && 1 <= deltaTime)
                        {
                            data.lerpTime = Mathf.Clamp01(deltaTime / data.deltaTime);
                        }
                        else
                        {
                            data.lerpTime += Mathf.Clamp01(1 / data.deltaTime * Time.deltaTime);
                        }
                        DanceLight[key].transform.position
                            = Vector3.Lerp(data.transform.stPos, data.transform.edPos, data.lerpTime);
                        DanceLight[key].transform.rotation
                            = Quaternion.Lerp(Quaternion.Euler(data.transform.stRot),
                                              Quaternion.Euler(data.transform.edRot), data.lerpTime);
                        var color = Vector3.Lerp(data.stColor, data.edColor, data.lerpTime);
                        DanceLight[key].GetComponent<Light>().color
                            = new Color32(GetColorValue(color.x), GetColorValue(color.y), GetColorValue(color.z), MyConst.COLOR_MAX);
                        var obj = DanceLight[key];
                        var light = obj.GetComponent<Light>();
                        light.range = data.range;
                        light.intensity = data.intensity;
                        light.spotAngle = data.spotAngle;
                        LightData[i] = data;

                        if (data.option.ToLower().Contains(MyConst.OBJECT_OPTION_MAINLIGHT_ON))
                        {
                            lightMgr.SetMainLight(true);
                        }
                        else if (data.option.ToLower().Contains(MyConst.OBJECT_OPTION_MAINLIGHT_OFF))
                        {
                            lightMgr.SetMainLight(false);
                        }

                        if (data.maidSlotNo > MyConst.PRE_INDEX && (light.type == LightType.Spot || light.type == LightType.Point))
                        {
                            var maid = maids.FirstOrDefault(m => maidMgr.GetCustomSlotNo(m) == data.maidSlotNo);
                            if (maid != null)
                            {
                                var pos = light.transform.position;
                                pos.x = maid.body0.Pelvis.position.x;
                                pos.y += maid.transform.position.y;
                                pos.z = maid.body0.Pelvis.position.z;
                                light.transform.position = pos;
                            }
                        }
                    }
                }
            }
            foreach (var key in keys)
            {
                DanceLight[key].SetActive(true);
            }
            for (int i = 0; i < LightData.Count(); i++)
            {
                var data = LightData[i];
                var key = data.type + data.group;
                if (!keys.Contains(key))
                {
                    DanceLight[key].SetActive(false);
                    data.lerpTime = 0;
                    LightData[i] = data;
                }
            }
        }

        /// <summary>
        /// フリーダンスライト作成
        /// </summary>
        public void CreateDanceLightObject(StageLightManager lightMgr)
        {
            DanceLight = new Dictionary<string, GameObject>();
            foreach (var data in LightData)
            {
                var key = data.type + data.group;
                var type = (LightType)MyConst.ENUM_EX_VALUE;
                GameObject obj = null;
                if (!DanceLight.ContainsKey(key))
                {
                    foreach (LightType value in Enum.GetValues(typeof(LightType)))
                    {
                        var name = Enum.GetName(typeof(LightType), value).ToLower();
                        if (data.type.ToLower() == name)
                        {
                            type = value;
                            break;
                        }
                    }
                    if (type != (LightType)MyConst.ENUM_EX_VALUE)
                    {
                        obj = new GameObject(key);
                        var light = obj.AddComponent<Light>();
                        light.type = type;
                        if (type == LightType.Directional)
                        {
                            lightMgr.CopyMainLight(light);
                        }
                    }
                    if (obj != null)
                    {
                        obj.SetActive(false);
                        DanceLight[key] = obj;
                    }
                }
            }
            if (MyHelper.CheckNull(DanceLight))
            {
                DanceLight = null;
            }
        }

        /// <summary>
        /// カメラモーション実行判定
        /// </summary>
        public bool IsCameraMotionOn()
        {
            return DanceScreenData[MyConst.CAMERA_MAIN].isMotionOn ? true : false;
        }

        /// <summary>
        /// カメラモーションインデックス設定
        /// </summary>
        public void SetCameraMotionData(float startTime)
        {
            for (int i = 0; i < DanceScreenData.Count(); i++)
            {
                if (DanceScreenData[i].isMotionOn)
                {
                    DanceScreenData[i].cameraMgr.IncrementIndex(DanceScreenData[i].motionData, startTime);
                }
            }
        }

        /// <summary>
        /// 公式ダンス背景映像読込
        /// </summary>
        public void LoadDanceMovie(List<DanceMovieSet> movieData, DanceMovieType movieTypeIndex, string movieLabel, string bgName, bool isTransparent)
        {
            videoMgr.IsTransparent = isTransparent;
            var movie = movieData.FindAll(d => d.label == movieLabel);
            if (MyHelper.CheckNull(movie))
            {
                return;
            }
            var type = movieTypeIndex;
            var gameObjects = new List<GameObject>();
            if (MyHelper.IsExistingArrayKey(MyConst.STAGE_LIVE, bgName))
            {
                type = DanceMovieType.LiveStage;
                foreach (var name in MyConst.PARTS_LIVE_OFFICIAL)
                {
                    gameObjects.Add(GameObject.Find(name));
                }
            }
            else if (MyHelper.IsExistingArrayKey(MyConst.STAGE_THEATER, bgName))
            {
                type = DanceMovieType.Theater;
            }
            else if (MyHelper.IsExistingArrayKey(MyConst.STAGE_POLE, bgName))
            {
                type = DanceMovieType.PoleStage;
                foreach (var name in MyConst.PARTS_POLE)
                {
                    gameObjects.Add(GameObject.Find(name));
                }
            }
            else if (movie.Count() == 1)
            {
                type = (DanceMovieType)movie[0].type;
            }

            var fileName = movie.FirstOrDefault(d => d.type == (int)type).fileName;
            if (string.IsNullOrEmpty(fileName))
            {
                return;
            }

            if (!MyHelper.CheckNull(gameObjects))
            {
                videoMgr.LoadOfficialDanceVideo(gameObjects, fileName);
            }
            else
            {
                movieParts = new List<GameObject>();
                var mgr = new BackgroundManager();
                var obj = new List<GameObject>();
                switch (type)
                {
                    case DanceMovieType.LiveStage:
                        movieParts = mgr.LoadBgPartsLiveStage();
                        break;
                    case DanceMovieType.Theater:
                        var o = GameObject.CreatePrimitive(PrimitiveType.Plane);
                        o.transform.position = new Vector3(0f, 4.7f, -6.5f);
                        o.transform.eulerAngles = new Vector3(90f, 0f, 0f);
                        o.transform.localScale = new Vector3(3.2f, 1f, 1f);
                        movieParts.Add(o);
                        break;
                    case DanceMovieType.PoleStage:
                        movieParts.Add(mgr.LoadBgPartsPoleStage());
                        break;
                }
                if (!MyHelper.CheckNull(movieParts))
                {
                    obj.Add(movieParts[0]);
                    videoMgr.LoadOfficialDanceVideo(obj, fileName);
                }
            }
        }

        /// <summary>
        /// 歌モード背景映像読込
        /// </summary>
        public void LoadSongMovie(FreeSongSet movie, bool isTransparent)
        {
            movieParts = new List<GameObject>();
            var folder = new SongManager().GetSongFolder(movie.folder);
            var filePath = new FileReader().GetFilePath(movie.movieName, folder);
            if (string.IsNullOrEmpty(filePath))
            {
                return;
            }
            videoMgr.IsTransparent = isTransparent;
            videoMgr.IsMuted = movie.isMute;
            videoMgr.Volume = movie.volume;
            var obj = GameObject.CreatePrimitive(PrimitiveType.Plane);
            obj.transform.position = movie.position;
            obj.transform.eulerAngles = movie.rotation;
            obj.transform.localScale = movie.scale;
            videoMgr.LoadSongModeVideo(obj, filePath);
            movieParts.Add(obj);
        }

        /// <summary>
        /// ビデオ背景映像タイム指定
        /// </summary>
        public void SeekVideo(float time)
        {
            videoMgr.SeekVideo(time);
        }

        /// <summary>
        /// ビデオ背景映像一時停止／再開
        /// </summary>
        public void PauseVideo(bool isPaused)
        {
            videoMgr.PauseVideo(isPaused);
        }

        /// <summary>
        /// ビデオ再生判定
        /// </summary>
        public bool IsVideoPlayed()
        {
            return videoMgr.IsPlayed();
        }

        /// <summary>
        /// ビデオ再生判定
        /// </summary>
        public bool IsVideoMuted()
        {
            return videoMgr.IsMuted;
        }

        /// <summary>
        /// ビデオ現在タイム取得
        /// </summary
        public float GetVideoCurrentTime()
        {
            return videoMgr.GetCurrentTime();
        }

        /// <summary>
        /// カラー値取得
        /// </summary>
        private byte GetColorValue(float value)
        {
            return (byte)Mathf.Clamp(value, MyConst.COLOR_MIN, MyConst.COLOR_MAX);
        }

        /// <summary>
        /// プレハブアクティブ設定
        /// </summary>
        private GameObject SetActiveOfPrefabe(GameObject obj, bool emit, bool isBubble)
        {
            if (isBubble)
            {
                bubbleSet.bubbleLame = obj;
                new StageParticleManager().SetBubbleLameEmitter(bubbleSet, emit);
                obj = bubbleSet.bubbleLame;
                bubbleSet.bubbleLame = null;
            }
            else
            {
                obj.SetActive(emit);
            }
            return obj;
        }

    }

    /// <summary>
    /// 舞台道具処理管理
    /// </summary>
    public class SatgeObjectManager
    {
        public Dictionary<TBody.SlotID, bool> ScreenUndressDic { get; set; }
        public List<FreeStageObjectSet> StageObjectData { get; set; }
        public Dictionary<TBody.SlotID, string[]> UndressJudgmentDic { get; set; }
        public List<string> StageObjectList { get; set; }
        public FreeCyalumeSet[] CyalumeSet { get; set; }
        public FreeCrowdSet CrowdSet { get; set; }
        public string[] UndressExceptList { get; set; }
        public float RotatedTime { get; set; }
        public int EachIndex { get; set; }
        public int CyalumeIndex { get; set; }
        public bool IsTurnedRight { get; set; }
        public bool IsStageObjectSetting { get; set; }
        public bool IsStageObjectTransform { get; set; }
        public bool IsCyalumeSelectedLeft { get; set; }

        private List<GameObject> cyalume;
        private Shader mirrorShader;
        private Texture cyalumeTexture;
        private bool isRotating;
        private float cyalumeColorTime;

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public SatgeObjectManager()
        {
            StageObjectData = new List<FreeStageObjectSet>();
            ScreenUndressDic = new Dictionary<TBody.SlotID, bool>();
            foreach (var key in GetScreenUnderessKeys())
            {
                ScreenUndressDic[key] = false;
            }
            RotatedTime = MyConst.ITWEEN_ROTATING_TIME;
            CyalumeSet = new FreeCyalumeSet[MyConst.STAGE_OBJECT_CYALUME_MAX];
            cyalume = new List<GameObject>();
            IsCyalumeSelectedLeft = true;
        }

        /// <summary>
        /// オブジェクト設定読込
        /// </summary>
        public void ReadSettingXml()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_SETTING_SCREEN_UNDRESS, "");
            if (!string.IsNullOrEmpty(path))
            {
                UndressExceptList = fReader.GetSettingOfScreenUndressExcept(path);
                UndressJudgmentDic = fReader.GetSettingOfScreenUndressJudgment(path);
            }
        }

        /// <summary>
        /// スクリーン脱衣キー取得
        /// </summary>
        public List<TBody.SlotID> GetScreenUnderessKeys()
        {
            var keys = MyConst.UNDRESS_SLOT.Keys.Where(d => 0 <= d).ToList();
            keys.AddRange(MyConst.SCREEN_UNDRESS_EXTRA_SLOT.Keys);
            return keys;
        }

        /// <summary>
        /// ステージオブジェクトタイプ取得
        /// </summary>
        public PrimitiveType GetStageObjectType(string value)
        {
            return MyHelper.GetDictionaryKey(MyConst.STAGE_OBJECT_TYPE, value);
        }

        /// <summary>
        /// ステージオブジェクト破棄
        /// </summary>
        public void DestroySatgeObjedt(int stageObjectIndex)
        {
            DestroyObject(StageObjectData[stageObjectIndex]);
            StageObjectData.RemoveAt(stageObjectIndex);
        }

        /// <summary>
        /// ステージオブジェクト全破棄
        /// </summary>
        public void DestroyAllSatgeObjedt()
        {
            foreach (var d in StageObjectData)
            {
                DestroyObject(d);
            }
            StageObjectData = new List<FreeStageObjectSet>();
        }

        /// <summary>
        /// ステージオブジェクト色設定
        /// </summary>
        public void SetSatgeObjedtColor(GameObject stageObject, Color32 color)
        {
            stageObject.GetComponent<MeshRenderer>().material.color = color;
        }

        /// <summary>
        /// ステージオブジェクト透明度設定
        /// </summary>
        public void SetSatgeObjedtScreenAlpha(GameObject stageObject, Color32 color, bool isTrans)
        {
            var renderer = stageObject.GetComponent<MeshRenderer>();
            renderer.material.color = color;
            renderer.material.shader = Shader.Find(isTrans ? MyConst.SHADER_UNLIGHT_TRANS : MyConst.SHADER_UNLIGHT);
        }

        /// <summary>
        /// ステージオブジェクトマテリアル設定
        /// </summary>
        public void SetStageObjectMaterial(int stageObejctIndex, bool isTexture)
        {
            var data = StageObjectData[stageObejctIndex];
            if (isTexture)
            {
                if (!string.IsNullOrEmpty(data.textureName))
                {
                    var reader = new FileReader();
                    var path = reader.GetFilePath(data.textureName, MyConst.FOLDER_PNG);
                    if (!string.IsNullOrEmpty(path))
                    {
                        data.texture = reader.ReadPngTexture(path);
                        if (data.isRepeat)
                        {
                            data.texture.wrapMode = TextureWrapMode.Repeat;
                            data.texture.filterMode = FilterMode.Point;
                        }
                        else
                        {
                            data.texture.wrapMode = TextureWrapMode.Clamp;
                            data.texture.filterMode = FilterMode.Bilinear;
                        }
                    }
                }
                else if (data.texture != null)
                {
                    GameObject.Destroy(data.texture);
                    data.texture = null;
                }
            }

            var shaderName = MyConst.SHADER_DIFFUSE;
            if (data.isUnlight)
            {
                shaderName = MyConst.SHADER_UNLIGHT_TRANS;
            }
            else if (data.isLight)
            {
                shaderName = data.isTrans ? MyConst.SHADER_LIGHTED_TRANS : MyConst.SHADER_LIGHTED;
            }
            else if (data.isTrans)
            {
                shaderName = MyConst.SHADER_DIFFUSE_TRANS;
            }

            var material = data.stageObject.GetComponent<MeshRenderer>().material;
            material.mainTextureScale = new Vector2(data.textureScaleX, data.textureScaleY);
            material.shader = Shader.Find(shaderName);
            material.mainTexture = null;
            material.mainTexture = data.texture;
            StageObjectData[stageObejctIndex] = data;
        }

        /// <summary>
        /// ステージオブジェクトリスト取得
        /// </summary>
        public void GetStageObjectList()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_STAGE_OBJECT, "");
            if (!string.IsNullOrEmpty(path))
            {
                StageObjectList = fReader.GetStageObjectLabel(path);
            }
        }

        /// <summary>
        /// ステージオブジェクトテクスチャー解除
        /// </summary>
        public void RemoveStageObjcetTexture(int stageObejctIndex)
        {
            var data = StageObjectData[stageObejctIndex];
            var material = data.stageObject.GetComponent<MeshRenderer>().material;
            material.mainTexture = null;
            GameObject.Destroy(data.texture);
            data.texture = null;
            StageObjectData[stageObejctIndex] = data;
        }

        /// <summary>
        /// ステージオブジェクトスクリーン設定
        /// </summary>
        public void SetLookAtScreen(LookAtSet lookAtSet, MaidManager maidMgr)
        {
            var maids = maidMgr.GetVisibleMaids();
            if (!MyHelper.CheckNull(maids))
            {
                for (int i = 0; i < StageObjectData.Count(); i++)
                {
                    var type = GetStageObjectType(StageObjectData[i].key);
                    if (type == (PrimitiveType)MyConst.STAGE_OBJECT_SCREEN ||
                        type == (PrimitiveType)MyConst.STAGE_OBJECT_CURVED_SCREEN)
                    {
                        var isUpdate = false;
                        var data = StageObjectData[i];
                        var eachSet = data.maidLookAt.divisionSet[MyConst.SCREEN_CAMERA_INDEX - 1];
                        var IsChanging = data.lookAtCam.IsChangingTime(data.maidLookAt.randomTime);
                        List<int> maidList = null;
                        if (eachSet.isRandomMaid)
                        {
                            if (IsChanging)
                            {
                                if (MyHelper.CheckNull(maidList))
                                {
                                    maidList = Enumerable.Range(0, maids.Count()).ToList();
                                }
                                eachSet.maidIndex = data.lookAtCam.SetRandomMaid(eachSet.maidIndex, maidList);
                                maidList.Remove(eachSet.maidIndex);
                            }
                            isUpdate = true;
                        }
                        if (eachSet.isRandomPoint)
                        {
                            if (IsChanging)
                            {
                                eachSet.pointIndex = data.lookAtCam.SetRandomPoint(eachSet.pointIndex);
                            }
                            isUpdate = true;
                        }
                        if (maids.Count() <= eachSet.maidIndex)
                        {
                            eachSet.maidIndex = 0;
                        }
                        eachSet = data.lookAtCam.SetLookAtMaid(
                                            eachSet, lookAtSet, MyConst.SCREEN_CAMERA_INDEX - 1,
                                            maids[eachSet.maidIndex], data.maidLookAt);
                        if (IsChanging)
                        {
                            data.lookAtCam.InitializeRandomTime();
                        }
                        else if (isUpdate)
                        {
                            data.lookAtCam.UpdateRandomTime();
                        }
                        data.maidLookAt.divisionSet[MyConst.SCREEN_CAMERA_INDEX - 1] = eachSet;
                        StageObjectData[i] = data;
                    }
                }
            }
        }

        /// <summary>
        /// メイドボディ表示
        /// </summary>
        public void ViewMaidBody(List<Maid> maids)
        {
            foreach (var maid in maids)
            {
                var skin = maid.body0.GetSlot((int)TBody.SlotID.body);
                if (skin.m_dicDelNodeBody != null)
                {
                    foreach (var key in skin.m_dicDelNodeBody.Keys.ToList())
                    {
                        skin.m_dicDelNodeBody[key] = true;
                    }
                    maid.body0.FixMaskFlag();
                    maid.body0.FixVisibleFlag(true);
                    maid.AllProcPropSeqStart();
                }
            }
        }

        /// <summary>
        /// スクリーン脱衣設定
        /// </summary>
        public void SetScreenUndress(bool isUndress)
        {
            var goArray = FindGameObject();
            foreach (var go in goArray.Where(g => g.layer == MyConst.CAMERA_LAYER_CHARA || g.layer == MyConst.CAMERA_LAYER_SCREEN_MASK))
            {
                foreach (var slot in ScreenUndressDic.Keys)
                {
                    if (ScreenUndressDic[slot] && UndressJudgmentDic.ContainsKey(slot) && !MyConst.SCREEN_UNDRESS_EXTRA_SLOT.ContainsKey(slot))
                    {
                        var isMatching = false;
                        var array = UndressJudgmentDic[slot];
                        for (int i = 0; i < array.Count(); i++)
                        {
                            var data = array[i].Split(MyConst.DELIMITER_CSV);
                            foreach (var d in data.Where(d => !string.IsNullOrEmpty(d)))
                            {
                                if (i == 0 && go.name == d ||
                                    i == 1 && go.name.StartsWith(d) ||
                                    i == 2 && go.name.EndsWith(d))
                                {
                                    isMatching = true;
                                    break;
                                }
                            }
                            if (isMatching)
                            {
                                break;
                            }
                        }
                        if (isMatching)
                        {
                            go.layer = isUndress ? MyConst.CAMERA_LAYER_SCREEN_MASK : MyConst.CAMERA_LAYER_CHARA;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// スクリーンマスク設定
        /// </summary>
        public void SetMask(List<Maid> maids, bool isMasked)
        {
            foreach (var maid in maids)
            {
                for (int i = 0; i < maid.body0.goSlot.Count; i++)
                {
                    var skin = maid.body0.goSlot[i];
                    foreach (var pair in ScreenUndressDic)
                    {
                        if (pair.Value)
                        {
                            if (isMasked)
                            {
                                if (!skin.listMaskSlot.Contains((int)pair.Key))
                                {
                                    skin.listMaskSlot.Add((int)pair.Key);
                                }
                            }
                            else
                            {
                                skin.listMaskSlot.Remove((int)pair.Key);
                            }
                        }
                    }
                }
                maid.body0.FixMaskFlag();
                maid.body0.FixVisibleFlag(false);
                maid.AllProcPropSeqStart();
            }
        }

        /// <summary>
        /// マスク設定クリア
        /// </summary>
        public void ClearAllMask(List<Maid> maids)
        {
            foreach (var maid in maids)
            {
                for (int i = 0; i < maid.body0.goSlot.Count; i++)
                {
                    var skin = maid.body0.goSlot[i];
                    skin.listMaskSlot.Clear();
                }
                maid.body0.FixMaskFlag();
                maid.body0.FixVisibleFlag(false);
                maid.AllProcPropSeqStart();
            }
        }

        /// <summary>
        /// スクリーン脱衣用設定文字出力
        /// </summary>
        public void ExportScreenUndressList()
        {
            Console.WriteLine("--▼キャラレイヤーオブジェクト-----------");
            var goArray = FindGameObject();
            foreach (var go in goArray.Where(g => g.layer == MyConst.CAMERA_LAYER_CHARA))
            {
                var isMatching = false;
                for (int i = 0; i < UndressExceptList.Count(); i++)
                {
                    var data = UndressExceptList[i].Split(MyConst.DELIMITER_CSV);
                    foreach (var d in data)
                    {
                        if (i == 0 && go.name == d ||
                            i == 1 && go.name.StartsWith(d) ||
                            i == 2 && go.name.EndsWith(d))
                        {
                            isMatching = true;
                            break;
                        }
                    }
                    if (isMatching)
                    {
                        break;
                    }
                }
                isMatching = false;
                if (!isMatching)
                {
                    Console.WriteLine(go.layer + " / " + go.name);
                }
            }
            Console.WriteLine("--▲キャラレイヤーオブジェクト-----------");
        }

        /// <summary>
        /// オブジェクト検索
        /// </summary>
        private GameObject[] FindGameObject()
        {
            return GameObject.FindObjectsOfType<GameObject>();
        }

        /// <summary>
        /// オブジェクト回転設定
        /// </summary>
        public void RotateToITween(GameObject obj)
        {
            iTween.RotateTo(obj,
                iTween.Hash("y", 720f * (IsTurnedRight ? -1 : 1),
                            "time", RotatedTime,
                            "looptype", iTween.LoopType.loop,
                            "easetype", "linear"
                            ));
            isRotating = true;
        }

        /// <summary>
        /// オブジェクト回転停止
        /// </summary>
        public void StopITween(GameObject obj, Vector3 rotation)
        {
            iTween.Stop(obj);
            isRotating = false;
            obj.transform.eulerAngles = rotation;
        }

        /// <summary>
        /// オブジェクト回転状態確認
        /// </summary>
        public bool IsRotatingITween()
        {
            return isRotating;
        }

        /// <summary>
        /// ポール位置設定
        /// </summary>
        public void SetPolePosition(int stageObejctIndex, Vector3 maidPosition)
        {
            var data = StageObjectData[stageObejctIndex];
            data.stageObject.transform.position = maidPosition;
            data.position = maidPosition;
            StageObjectData[stageObejctIndex] = data;
        }

        /// <summary>
        /// ステージオブジェクト作成
        /// </summary>
        public void CreateSatgeObjedt(int listIndex, RenderTextureSet renderTextureSet, MaidManager maidMgr)
        {
            var list = ReadStageObjectData(listIndex);
            if (!MyHelper.CheckNull(list))
            {
                foreach (var data in list)
                {
                    var type = GetStageObjectType(data.key);
                    switch (type)
                    {
                        case (PrimitiveType)MyConst.STAGE_OBJECT_MIRROR:
                            CreateMirror(data);
                            break;

                        case (PrimitiveType)MyConst.STAGE_OBJECT_SCREEN:
                            CreateScreen(data, renderTextureSet, maidMgr);
                            break;

                        case (PrimitiveType)MyConst.STAGE_OBJECT_POLE:
                            CreatePole(data);
                            break;
                        case (PrimitiveType)MyConst.STAGE_OBJECT_LINE:
                            CreateLine(data);
                            break;
                        case (PrimitiveType)MyConst.STAGE_OBJECT_CURVED_PANEL:
                        case (PrimitiveType)MyConst.STAGE_OBJECT_CURVED_SCREEN:
                            CreateCurved(data, type, renderTextureSet, maidMgr);
                            break;
                        default:
                            CreatePrimitive(data, type);
                            break;
                    }
                }
            }
        }

        /// <summary>
        /// ステージオブジェクト作成（プリミティブ）
        /// </summary>
        private void CreatePrimitive(FreeStageObjectSet data, PrimitiveType type)
        {
            data.stageObject = GameObject.CreatePrimitive(type);
            data.stageObject.GetComponent<MeshRenderer>().material = new Material(Shader.Find(MyConst.SHADER_DIFFUSE));
            SetSatgeObjedtColor(data.stageObject, data.color);
            data.stageObject.transform.position = data.position;
            data.stageObject.transform.rotation = Quaternion.Euler(data.rotation);
            data.stageObject.transform.localScale = data.scale;
            StageObjectData.Add(data);
            SetStageObjectMaterial(StageObjectData.Count() - 1, !string.IsNullOrEmpty(data.textureName));
        }

        /// <summary>
        /// ステージオブジェクト作成（ポール）
        /// </summary>
        private void CreatePole(FreeStageObjectSet data)
        {
            data.stageObject = GameObject.CreatePrimitive(PrimitiveType.Cylinder);
            data.stageObject.GetComponent<Renderer>().material = new Material(Shader.Find(MyConst.SHADER_DIFFUSE));
            SetSatgeObjedtColor(data.stageObject, data.color);
            data.stageObject.transform.position = data.position;
            data.stageObject.transform.rotation = Quaternion.Euler(data.rotation);
            data.stageObject.transform.localScale = data.scale;
            data.textureName = "";
            StageObjectData.Add(data);
        }

        /// <summary>
        /// ステージオブジェクト作成（ラインフレーム）
        /// </summary>
        private void CreateLine(FreeStageObjectSet data)
        {
            var objMgr = new DanceObjectManager(data.lineSet);
            data.stageObject = objMgr.CreateDanceLineObject(MyConst.OBJECT_PRIMITIVE_LINE, data.lineSet.type);
            data.stageObject.GetComponent<Renderer>().material = new Material(Shader.Find(MyConst.SHADER_DIFFUSE));
            SetSatgeObjedtColor(data.stageObject, data.color);
            data.stageObject.transform.position = data.position;
            data.stageObject.transform.rotation = Quaternion.Euler(data.rotation);
            data.stageObject.transform.localScale = data.scale;
            data.textureName = "";
            objMgr.TransformLine(data.stageObject, data.lineSet.type);
            StageObjectData.Add(data);
            SetStageObjectMaterial(StageObjectData.Count() - 1, false);
        }

        /// <summary>
        /// ステージオブジェクト作成（鏡）
        /// </summary>
        private void CreateMirror(FreeStageObjectSet data)
        {
            if (GetMirrorShader())
            {
                data.stageObject = GameObject.CreatePrimitive(PrimitiveType.Plane);
                data.stageObject.GetOrAddComponent<MirrorReflection2>();
                var refleftion2 = data.stageObject.GetComponent<MirrorReflection2>();
                refleftion2.m_TextureSize = MyConst.MIRROR_TEXTURE_SIZE;
                refleftion2.m_ClipPlaneOffset = 0f;
                data.stageObject.GetComponent<Renderer>().enabled = true;

                var material = new Material(Shader.Find(MyConst.MATERIAL_MIRROR));
                material.shader = mirrorShader;
                data.stageObject.GetComponent<Renderer>().material = material;
                data.stageObject.transform.position = data.position;
                data.stageObject.transform.rotation = Quaternion.Euler(data.rotation);
                data.stageObject.transform.localScale = data.scale;
                StageObjectData.Add(data);
            }
        }

        /// <summary>
        /// 鏡シェーダー取得（ShaderChange.Plugin付属シェーダー）
        /// </summary>
        private bool GetMirrorShader()
        {
            if (mirrorShader == null)
            {
                var path = MyHelper.RootFolder.Replace(MyConst.FOLDER_ROOT, "") + MyConst.FILE_PATH_SHADER;
                path = new FileReader().CheckFilePath(path);
                if (!string.IsNullOrEmpty(path))
                {
                    mirrorShader = AssetBundle.LoadFromFile(path).LoadAsset(MyConst.MATERIAL_ASSET_MIRROR) as Shader;
                }
            }
            return mirrorShader != null;
        }

        /// <summary>
        /// スクリーン作成
        /// </summary>
        private void CreateScreen(FreeStageObjectSet data, RenderTextureSet renderTextureSet, MaidManager maidMgr)
        {
            var maids = maidMgr.GetVisibleMaids();
            if (MyHelper.CheckNull(maids))
            {
                Console.WriteLine("メイドが配置されていません");
            }
            else
            {
                data.stageObject = GameObject.CreatePrimitive(PrimitiveType.Plane);
                data.stageObject.transform.position = data.position;
                data.stageObject.transform.rotation = Quaternion.Euler(data.rotation);
                data.stageObject.transform.localScale = data.scale;

                SetScreen(renderTextureSet, ref data);
                var material = GetMaterial(data);
                data.stageObject.GetComponent<Renderer>().material = material;
                StageObjectData.Add(data);
            }
        }

        /// <summary>
        /// 湾曲スクリーン作成
        /// </summary>
        private void CreateCurved(FreeStageObjectSet data, PrimitiveType type, RenderTextureSet renderTextureSet, MaidManager maidMgr)
        {
            var maids = maidMgr.GetVisibleMaids();
            if (MyHelper.CheckNull(maids) &&
                type == (PrimitiveType)MyConst.STAGE_OBJECT_CURVED_SCREEN)
            {
                Console.WriteLine("メイドが配置されていません");
            }
            else
            {
                data.stageObject = new GameObject();
                data.stageObject.transform.position = data.position;
                data.stageObject.transform.rotation = Quaternion.Euler(data.rotation);
                data.stageObject.transform.localScale = data.scale;

                var width = data.curevedSet.width;
                var height = data.curevedSet.height;
                var depth = data.curevedSet.depth;
                var points = data.curevedSet.points;
                var rad = data.curevedSet.angle / (points - 1f) * Mathf.PI / 180f;

                var vertices = new List<Vector3>();
                for (int i = 0; i < points; i++)
                {

                    var cos = Mathf.Cos(rad * i);
                    var sin = Mathf.Sin(rad * i);
                    var r = 1 / Mathf.Sqrt(Mathf.Pow(cos / (width / 2f), 2) + Mathf.Pow(sin / depth, 2));
                    var x = r * cos;
                    var y = r * sin;
                    vertices.Add(new Vector3(x, y, 0f));
                    vertices.Add(new Vector3(x, y, height));
                }
                var point = 0;
                var triangles = new List<int>();
                for (int i = 0; i < points - 1; i++)
                {
                    triangles.Add(point);
                    triangles.Add(point + 1);
                    triangles.Add(point + 2);
                    triangles.Add(point + 1);
                    triangles.Add(point + 3);
                    triangles.Add(point + 2);
                    point += 2;
                }
                var uv = new List<Vector2>();
                for (int i = 0; i < points; i++)
                {
                    uv.Add(new Vector3(i * 2f / points, 0f));
                    uv.Add(new Vector3(i * 2f / points, 2f));
                }

                var mesh = new Mesh();
                mesh.vertices = vertices.ToArray();
                mesh.triangles = triangles.ToArray();
                mesh.uv = uv.ToArray();
                mesh.RecalculateNormals();

                var meshFilter = data.stageObject.GetOrAddComponent<MeshFilter>();
                var meshRenderer = data.stageObject.GetOrAddComponent<MeshRenderer>();
                Material material;

                if (type == (PrimitiveType)MyConst.STAGE_OBJECT_CURVED_SCREEN)
                {
                    SetScreen(renderTextureSet, ref data);
                    material = GetMaterial(data);
                }
                else
                {
                    var shaderName = MyConst.SHADER_DIFFUSE;
                    if (data.isUnlight)
                    {
                        shaderName = MyConst.SHADER_UNLIGHT_TRANS;
                    }
                    material = new Material(Shader.Find(shaderName));
                    var reader = new FileReader();
                    var path = reader.GetFilePath(data.textureName, MyConst.FOLDER_PNG);
                    if (!string.IsNullOrEmpty(path))
                    {
                        data.texture = reader.ReadPngTexture(path);
                        if (data.texture != null)
                        {
                            data.texture.wrapMode = TextureWrapMode.Clamp;
                            material.mainTexture = data.texture;
                        }
                    }
                }
                material.mainTextureScale = new Vector2(data.textureScaleX, data.textureScaleY);
                meshFilter.mesh = mesh;
                meshRenderer.material = material;
                data.isCurved = true;
                StageObjectData.Add(data);
            }
        }

        /// <summary>
        /// スクリーン設定
        /// </summary>
        private void SetScreen(RenderTextureSet renderTextureSet, ref FreeStageObjectSet data)
        {
            IsStageObjectSetting = true;
            data.stageObject.gameObject.layer = MyConst.CAMERA_LAYER_SCREEN_MASK;

            data.rTexture = new RenderTexture(renderTextureSet.width, renderTextureSet.height, MyConst.RENDER_TEXTURE_DEPTH);
            data.rTexture.antiAliasing = MyConst.RENDER_TEXTURE_ANTIALIASING;
            data.lookAtCam = new LookAtCameraManager(MyConst.SCREEN_CAMERA_INDEX, true);
            data.lookAtCam.SetRenderTexture(data.rTexture, data.stageObject, renderTextureSet.isMask);

            data.maidLookAt = new MaidLookAtSet();
            data.maidLookAt.randomTime = MyConst.LOOK_AT_RANDOM_TIME;
            data.maidLookAt.cameraIndex = 0;
            data.maidLookAt.divisionSet = new MaidLookAtEachSet[MyConst.SCREEN_CAMERA_INDEX];
        }

        /// <summary>
        /// マテリアル設定
        /// </summary>
        private Material GetMaterial(FreeStageObjectSet data)
        {
            var material = new Material(Shader.Find(MyConst.SHADER_UNLIGHT));
            material.mainTexture = data.rTexture;
            return material;
        }

        /// <summary>
        /// オブジェクト破棄
        /// </summary>
        private void DestroyObject(FreeStageObjectSet data)
        {
            var type = GetStageObjectType(data.key);
            if (type == (PrimitiveType)MyConst.STAGE_OBJECT_SCREEN ||
                type == (PrimitiveType)MyConst.STAGE_OBJECT_CURVED_SCREEN)
            {
                if (data.rTexture != null)
                {
                    data.rTexture.Release();
                }
                if (data.lookAtCam != null)
                {
                    data.lookAtCam.DestroyCamera(0, MyConst.SCREEN_CAMERA_INDEX);
                }
            }
            if (data.videoMgr != null)
            {
                data.videoMgr.EndVideo();
            }
            GameObject.Destroy(data.stageObject);
            GameObject.Destroy(data.texture);
        }

        /// <summary>
        /// ステージオブジェクトデータ読込
        /// </summary>
        private List<FreeStageObjectSet> ReadStageObjectData(int listIndex)
        {
            var stageData = new List<FreeStageObjectSet>();
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_STAGE_OBJECT, "");
            if (!string.IsNullOrEmpty(path))
            {
                stageData = fReader.ReadStageObjectData(path, StageObjectList[listIndex]);
            }
            return stageData;
        }

        //------------------------------------------------------------------------------------------

        /// <summary>
        /// 人垣データ削除
        /// </summary>
        public void DeleteCrowdData()
        {
            var data = CrowdSet;
            if (!MyHelper.CheckNull(data.crowd))
            {
                foreach (var obj in data.crowd)
                {
                    GameObject.Destroy(obj);
                }
            }
            data.crowd = new List<GameObject>();
            CrowdSet = data;
        }

        /// <summary>
        /// 人垣データ作成
        /// </summary>
        public void CreateCrowdData()
        {
            DeleteCrowdData();
            var data = CrowdSet;
            var distance = data.centerDistance;
            for (int h = 0; h < data.layer; h++)
            {
                for (int i = 0; i < data.mobNumber; i++)
                {
                    var idx = MyHelper.GetRandomIndex(2) + 1;
                    var fileName = MyConst.FOLDER_PREFAB + string.Format(MyConst.OBJECT_MOB, idx);
                    var obj = GameObject.Instantiate(Resources.Load(fileName)) as GameObject;
                    var space = data.mobDistanceX / 3f;
                    var y = 360f / data.mobNumber * i + MyHelper.GetRandomFloat(data.mobDistanceX - space, data.mobDistanceX + space);
                    obj.transform.eulerAngles = new Vector3(-90f, y, 0f);
                    var rotX = 0;
                    var rotY = y * Mathf.Deg2Rad;
                    var pos = new Vector3(Mathf.Cos(rotX) * Mathf.Sin(rotY), 0f, Mathf.Cos(rotX) * Mathf.Cos(rotY));
                    space = data.mobDistanceZ / 3f;
                    obj.transform.position += pos * (distance + MyHelper.GetRandomFloat(-space, space)) * -1;
                    data.crowd.Add(obj);
                }
                distance += data.mobDistanceZ;
            }
            CrowdSet = data;
        }

        //------------------------------------------------------------------------------------------

        /// <summary>
        /// ステージサイリウムデータ削除
        /// </summary>
        public void DeleteCyalumeData()
        {
            foreach (var obj in cyalume)
            {
                GameObject.Destroy(obj);
            }
            MyHelper.ClearList(cyalume);
            GameObject.Destroy(cyalumeTexture);
            cyalumeTexture = null;
        }

        /// <summary>
        /// ステージサイリウムデータ読込
        /// </summary>
        public void ReadCyalumeData()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_SETTING, "");
            if (!string.IsNullOrEmpty(path))
            {
                CyalumeSet = fReader.GetSettingOfCyalume(path);
            }
        }

        /// <summary>
        /// ステージサイリウムデータ作成
        /// </summary>
        public void CreateCyalumeData()
        {
            cyalumeColorTime = 0;
            DeleteCyalumeData();
            var data = CyalumeSet[CyalumeIndex];
            if (!string.IsNullOrEmpty(data.textureName))
            {
                var reader = new FileReader();
                var path = reader.GetFilePath(data.textureName, MyConst.FOLDER_PNG);
                cyalumeTexture = reader.ReadPngTexture(path);
                cyalumeTexture.wrapMode = TextureWrapMode.Clamp;
                cyalumeTexture.filterMode = FilterMode.Bilinear;
            }
            else
            {
                GameObject.Destroy(cyalumeTexture);
                cyalumeTexture = null;
            }

            if (data.isRandomColor)
            {
                data.color[0] = MyHelper.GetRandomColor(data.color[0].a / (float)MyConst.COLOR_MAX);
                data.color[1] = data.color[0];
            }

            for (int h = 0; h < MyConst.STAGE_OBJECT_CYALUME_FLOORS; h++)
            {
                var floor = h == 0 ? data.floor1st : data.floor2nd;
                var isPair = h == 0 ? data.isPair1st : data.isPair2nd;
                for (int i = 0; i < floor.x; i++)
                {
                    for (int j = 0; j < floor.y; j++)
                    {
                        for (int k = 0; k < (isPair ? 2 : 1); k++)
                        {
                            cyalume.Add(CreateCyalume(data, i, j, h != 0, k == 0));
                        }   
                    }
                }
            }
        }

        /// <summary>
        /// ステージサイリウム作成
        /// </summary>
        public GameObject CreateCyalume(FreeCyalumeSet data, int column, int row, bool isUpper, bool isLeft)
        {
            var obj = GameObject.CreatePrimitive(PrimitiveType.Plane);
            var pos = isUpper ? data.position2nd : data.position1st;
            obj.transform.position = new Vector3(
                pos.x + data.pairSpace * (isLeft ? -1 : 1) + column * data.positionAdjustment.x,
                pos.y + row * data.positionAdjustment.y,
                pos.z + row * data.positionAdjustment.z);
            obj.transform.eulerAngles = new Vector3(
                data.rotation.x * (isLeft ? 1 : -1),
                data.rotation.y,
                data.rotation.z);
            obj.transform.localScale = new Vector3(data.scale.x, data.scale.y, data.scale.z);

            if(data.moveDistance != Vector3.zero)
            {
                iTween.MoveBy(obj, iTween.Hash(
                    "x", data.moveDistance.x,
                    "y", data.moveDistance.y,
                    "z", data.moveDistance.z * (isLeft ? -1 : 1),
                    "time", data.moveTime,
                    "looptype", iTween.LoopType.pingPong, "easetype", iTween.EaseType.easeInOutExpo));
            }
            if (data.rotationAddY != 0)
            {
                iTween.RotateAdd(obj, iTween.Hash(
                    "x", 0f,
                    "y", data.rotationAddY,
                    "z", 0f,
                    "time", data.moveTime,
                    "looptype", iTween.LoopType.pingPong, "easetype", iTween.EaseType.easeInOutExpo));
            }
            if (data.fadeTime != 0)
            {
                iTween.FadeTo(obj, iTween.Hash(
                   "alpha", 1f,
                   "time", data.fadeTime,
                   "looptype", iTween.LoopType.pingPong, "easetype", iTween.EaseType.easeInOutExpo));
            }
            var material = obj.GetComponent<Renderer>().material;
            material.shader = Shader.Find(MyConst.SHADER_UNLIGHT_TRANS);
            material.mainTextureScale = new Vector2(1f, 1f);
            material.mainTexture = cyalumeTexture;
            material.color = data.color[isLeft ? 0 : 1];
            if (data.isRandomColors)
            {
                material.color = MyHelper.GetRandomColor(material.color.a);
            }
            return obj;
        }

        /// <summary>
        /// ステージサイリウムランダム色変更
        /// </summary>
        public void ChangeCyalumeColor()
        {
            if (MyHelper.CheckNull(cyalume)) return;
            var data = CyalumeSet[CyalumeIndex];
            if (!data.isRandomChanged || data.changeTime <= 0) return;
            if (data.changeTime <= cyalumeColorTime)
            {
                cyalumeColorTime = 0;
                if (data.isRandomColor)
                {
                    data.color[0] = MyHelper.GetRandomColor(data.color[0].a / (float)MyConst.COLOR_MAX);
                    data.color[1] = data.color[0];
                }
                SetColor(data);
            }
            else
            {
                cyalumeColorTime += Time.deltaTime;
            }
        }

        /// <summary>
        /// サイリウム色変更
        /// </summary>
        private void SetColor(FreeCyalumeSet data)
        {
            for (int h = 0; h < MyConst.STAGE_OBJECT_CYALUME_FLOORS; h++)
            {
                var floor = h == 0 ? data.floor1st : data.floor2nd;
                var isPair = h == 0 ? data.isPair1st : data.isPair2nd;
                for (int i = 0; i < floor.x; i++)
                {
                    for (int j = 0; j < floor.y; j++)
                    {
                        for (int k = 0; k < (isPair ? 2 : 1); k++)
                        {
                            for (int c = 0; c < cyalume.Count; c++)
                            {
                                var material = cyalume[c].GetComponent<Renderer>().material;
                                material.color = data.color[k == 0 ? 0 : 1];
                                if (data.isRandomColors)
                                {
                                    material.color = MyHelper.GetRandomColor(material.color.a);
                                }
                                cyalume[c].GetComponent<Renderer>().material = material;
                            }
                        }
                    }
                }
            }
        }

    }

    /// <summary>
    /// モデル処理管理
    /// </summary>
    public class StageModelManager
    {
        public List<string> ModelList { get; set; }
        public List<FreeModelSet> ModelData { get; set; }

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public StageModelManager()
        {
            ModelData = new List<FreeModelSet>();
        }

        /// <summary>
        /// モデルラベル読込
        /// </summary>
        public void ReadModeLabel()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_STAGE_MODEL, "");
            if (!string.IsNullOrEmpty(path))
            {
                ModelList = fReader.GetStageModelLabel(path);
            }
        }

        /// <summary>
        /// モデル破棄
        /// </summary>
        public void DeleteModModel(int modelIndex)
        {
            GameObject.Destroy(ModelData[modelIndex].modelObject);
            var obj = ModelData[modelIndex];
            obj.modelObject = null;
            ModelData[modelIndex] = obj;
            ModelData.RemoveAt(modelIndex);
        }

        /// <summary>
        /// モデル読込
        /// </summary>
        public bool LoadModel(string label, bool isList)
        {
            var isRead = false;
            var maids = new MaidManager().GetActiveMaids();
            if (!MyHelper.CheckNull(maids))
            {
                var list = new List<FreeModelSet>();
                if (isList)
                {
                    list = ReadModeData(label);
                }
                else
                {
                    var dt = new FreeModelSet();
                    dt.viewName = label;
                    dt.modelName = label;
                    dt.modelName = MyHelper.EndsWith(label, MyConst.EXTENSION_MODEL);
                    dt.scale = new Vector3(1f, 1f, 1f);
                    list.Add(dt);
                }

                int count = ModelData.Count(m => m.viewName.Contains(label));
                foreach (var d in list)
                {
                    if (MyHelper.IsExistingOfficialFile(d.modelName) || MyHelper.IsExistingModFile(d.modelName))
                    {
                        var data = new FreeModelSet();
                        var tMorph = new TMorph(maids[0].body0.GetSlot(8));
                        data.modelObject = ImportCM.LoadSkinMesh_R(d.modelName, tMorph, "", tMorph.bodyskin, 0);
                        if (d.position != Vector3.zero)
                        {
                            data.modelObject.transform.position = d.position;
                            data.position = d.position;
                        }
                        if (d.rotation != Vector3.zero)
                        {
                            data.modelObject.transform.rotation = Quaternion.Euler(d.rotation);
                            data.rotation = d.rotation;
                        }
                        if (d.scale != new Vector3(1f, 1f, 1f))
                        {
                            data.modelObject.transform.localScale = d.scale;
                        }
                        data.modelObject.SetActive(true);
                        data.scale = d.scale;
                        data.viewName = d.viewName + count;
                        data.modelName = d.modelName;
                        ModelData.Add(data);
                        isRead = true;
                        count++;
                    }
                    else
                    {
                        Console.WriteLine(string.Format("モデルファイルがありません：{0}", d.modelName));
                    }
                }
            }
            else
            {
                Console.WriteLine("メイドが配置されていません");
            }
            return isRead;
        }

        /// <summary>
        /// モデル位置設定
        /// </summary>
        public void SetModelFollowingPosition()
        {
            var maidMgr = new MaidManager();
            var maids = maidMgr.GetActiveMaids();
            if (!MyHelper.CheckNull(maids))
            {
                for (int i = 0; i < ModelData.Count(); i++)
                {
                    var data = ModelData[i];
                    if (data.isFollowing && data.maidIndex < maids.Count())
                    {
                        var maid = maids[data.maidIndex];
                        var position = maidMgr.GetMiadPatrsPotision(maid, data.pointIndex);
                        data.modelObject.transform.position = data.position + position;
                        ModelData[i] = data;
                    }
                }
            }
        }

        /// <summary>
        /// モデルデータ読込
        /// </summary>
        private List<FreeModelSet> ReadModeData(string label)
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_STAGE_MODEL, "");
            if (!string.IsNullOrEmpty(path))
            {
                return fReader.ReadModelData(path, label);
            }
            return null;
        }

    }

    /// <summary>
    /// パーティクル処理管理
    /// </summary>
    public class StageParticleManager
    {
        public List<string> BubbleLameList { get; set; }
        public List<string> ParticleList { get; set; }
        public List<FreeBubbleLameSet> BubbleLameData { get; set; }
        public List<DanceParticle> ParticleData { get; set; }
        public string BubbleLameLable { get; set; }
        public string ParticleLable { get; set; }
        public string OfficialLable { get; set; }
        public bool IsBubbleLame { get; set; }
        public int BubbleLameMenuIndex { get; set; }
        public int ParticleMenuIndex { get; set; }
        public int BubbleLameIndex { get; set; }
        public int ParticleIndex { get; set; }
        public int LifeGradientIndex { get; set; }
        public int LifeAlphaIndex { get; set; }
        public int SpeedGradientIndex { get; set; }
        public int SpeedAlphaIndex { get; set; }

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public StageParticleManager()
        {
            BubbleLameData = new List<FreeBubbleLameSet>();
            ParticleData = new List<DanceParticle>();
        }

        /// <summary>
        /// バブル・ラメ設定（旧形式）
        /// </summary>
        #region BubbleLame

        /// <summary>
        /// バブル・ラメリスト取得
        /// </summary>
        public void GetBubbleLameList()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_STAGE_BUBBLE_LAME, "");
            if (!string.IsNullOrEmpty(path))
            {
                BubbleLameList = fReader.GetStageBubbleLameLabel(path);
            }
        }

        /// <summary>
        /// バブル・ラメ設定読込
        /// </summary>
        public void LoadBubbleLame(string label)
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_STAGE_BUBBLE_LAME, "");
            if (!string.IsNullOrEmpty(path))
            {
                var data = fReader.ReadBubbleLameData(path, label);
                if (MyConst.STAGE_BUBBLE_LAME_TYPE.ContainsKey(data.type))
                {
                    path = MyConst.FOLDER_PREFAB + MyConst.STAGE_BUBBLE_LAME_TYPE[data.type];
                    data.bubbleLame = GameObject.Instantiate(Resources.Load(path)) as GameObject;
                    if (data.bubbleLame != null)
                    {
                        data.label += BubbleLameData.Count().ToString("00");
                        BubbleLameData.Add(data);
                        BubbleLameIndex = BubbleLameData.Count() - 1;
                        SetBubbleLameParameter(true, false);
                    }
                }
            }
        }

        /// <summary>
        /// バブル・ラメパラメータ設定
        /// </summary>
        public void SetBubbleLameParameter(bool isSetTexture, bool isRemove)
        {
            var data = BubbleLameData[BubbleLameIndex];
            data = SetBubbleLameEmitter(data, true);
            var render = data.bubbleLame.GetComponent<ParticleRenderer>();
            if (render != null)
            {
                if (isRemove)
                {
                    render.material.mainTexture = null;
                    GameObject.Destroy(data.texture);
                    data.texture = null;
                }
                render.material.SetColor(MyConst.MATERIAL_COLOR, data.color);
                if (isSetTexture)
                {
                    var reader = new FileReader();
                    var path = reader.GetFilePath(data.textureName, MyConst.FOLDER_PNG);
                    if (!string.IsNullOrEmpty(path))
                    {
                        data.texture = reader.ReadPngTexture(path);
                        render.material.mainTexture = data.texture;
                    }
                    else if (data.texture != null)
                    {
                        GameObject.Destroy(data.texture);
                        data.texture = null;
                    }
                }
            }
            data.bubbleLame.transform.position = data.position;
            data.bubbleLame.transform.rotation = Quaternion.Euler(data.rotation);
            BubbleLameData[BubbleLameIndex] = data;
        }

        /// <summary>
        /// バブル・ラメエミッター設定
        /// </summary>
        public FreeBubbleLameSet SetBubbleLameEmitter(FreeBubbleLameSet data, bool emit)
        {
            var emitter = data.bubbleLame.GetComponent<EllipsoidParticleEmitter>();
            if (emitter != null)
            {
                emitter.emit = emit;
                emitter.minSize = data.minSize;
                emitter.maxSize = data.maxSize;
                emitter.minEnergy = data.minEnergy;
                emitter.maxEnergy = data.maxEnergy;
                emitter.minEmission = data.minEmission;
                emitter.maxEmission = data.maxEmission;
                emitter.worldVelocity = data.worldVelocity;
                emitter.rndVelocity = data.rndVelocity;
                emitter.angularVelocity = data.angularVelocity;
                emitter.rndAngularVelocity = data.rndAngularVelocity;
                emitter.rndRotation = data.rndRotation;
            }
            return data;
        }

        /// <summary>
        /// バブル・ラメ破棄
        /// </summary>
        public void DestroyBubbleLame()
        {
            GameObject.Destroy(BubbleLameData[BubbleLameIndex].bubbleLame);
            BubbleLameData.RemoveAt(BubbleLameIndex);
            BubbleLameIndex = 0;
        }

        #endregion

        /// <summary>
        /// パーティクル設定（shuriken）
        /// </summary>
        #region Particle

        /// <summary>
        /// パーティクルリスト取得
        /// </summary>
        public void GetParticleList()
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_STAGE_PARTICLE, "");
            if (!string.IsNullOrEmpty(path))
            {
                ParticleList = fReader.GetStageBubbleLameLabel(path);
            }
        }

        /// <summary>
        /// パーティクル破棄
        /// </summary>
        public void DestroyParticle()
        {
            GameObject.Destroy(ParticleData[ParticleIndex].particle);
            ParticleData.RemoveAt(ParticleIndex);
            ParticleIndex = 0;
        }

        /// <summary>
        /// パーティクル再生
        /// </summary>
        public void PlayParticle(bool isClear)
        {
            var particle = ParticleData[ParticleIndex].particle.GetOrAddComponent<ParticleSystem>();
            if (isClear)
            {
                particle.Clear();
            }
            else if (!particle.isPlaying)
            {
                particle.Play();
            }
            else
            {
                particle.Stop();
            }
        }

        /// <summary>
        /// ダンスパーティクル再生
        /// </summary>
        public GameObject PlayDanceParticle(bool isPlay, GameObject obj)
        {
            var particle = obj.GetOrAddComponent<ParticleSystem>();
            if (isPlay)
            {
                if (!particle.isPlaying)
                {
                    particle.Play();
                }
            }
            else
            {
                if (!particle.isStopped)
                {
                    particle.Stop();
                }
            }
            return obj;
        }

        /// <summary>
        /// パーティクル読込
        /// </summary>
        public void LoadParticle(int index)
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_STAGE_PARTICLE, "");
            if (!string.IsNullOrEmpty(path))
            {
                var data = fReader.GetSettingOfStageEffectParticle(path, ParticleList[index], false);
                if (!string.IsNullOrEmpty(data.label))
                {
                    data.particle = UpdateParticle(data, true, true);
                    ParticleData.Add(data);
                }
            }

        }

        /// <summary>
        /// 公式パーティクル読込（未使用）
        /// </summary>
        public void LoadOfficialParticle(string name)
        {
            var path = MyConst.FOLDER_PARTICLE + "/";
            path = MyConst.FOLDER_PREFAB + (name.StartsWith(path) ? name : path + name);
            var data = new DanceParticle();
            data.particle = GameObject.Instantiate(Resources.Load(path)) as GameObject;
            if(data.particle != null)
            {
                data.position = data.particle.transform.position;
                data.rotation = data.particle.transform.eulerAngles;
                data.scale = data.particle.transform.localScale;
                var material = data.particle.GetComponent<Renderer>().material;
                if(material != null)
                {
                    data.textureName = material.mainTexture.name;
                    data.shaderName = material.shader.name;
                    data.color = material.color;
                }

                var particle = data.particle.GetOrAddComponent<ParticleSystem>();

                data.main.duration = particle.main.duration;
                data.main.isLoop = particle.main.loop;
                data.main.startDelay = GetMinMaxCurve(particle.main.startDelay);
                data.main.startLifetime = GetMinMaxCurve(particle.main.startLifetime);
                data.main.startSpeed = GetMinMaxCurve(particle.main.startSpeed);
                data.main.startSize = GetMinMaxCurve(particle.main.startSize);
                data.main.startRotation = GetMinMaxCurve(particle.main.startRotation) / Mathf.Deg2Rad;
                data.main.gravityModifier = GetMinMaxCurve(particle.main.gravityModifier);
                data.main.maxParticles = particle.main.maxParticles;

                data.emission.enabled = particle.emission.enabled;
                data.emission.rateOverTime = GetMinMaxCurve(particle.emission.rateOverTime);
                data.emission.rateOverTime = GetMinMaxCurve(particle.emission.rateOverTime);

                data.shape.enabled = particle.shape.enabled;
                data.shape.shapeType = particle.shape.shapeType;
                data.shape.angle = particle.shape.angle;
                data.shape.sphericalDirectionAmount = particle.shape.sphericalDirectionAmount;
                data.shape.randomDirectionAmount = particle.shape.randomDirectionAmount;
                data.shape.boxSize = particle.shape.box;
                data.shape.radiusMode = particle.shape.radiusMode;
                data.shape.radius = particle.shape.radius;
                data.shape.radiusSpread = particle.shape.radiusSpread;
                data.shape.radiusSpeed = GetMinMaxCurve(particle.shape.radiusSpeed);
                data.shape.arcMode = particle.shape.arcMode;
                data.shape.arc = particle.shape.arc;
                data.shape.arcSpread = particle.shape.arcSpread;
                data.shape.arcSpeed = GetMinMaxCurve(particle.shape.arcSpeed);

                new FileReader().GetParticleDefaultColorSetting(ref data);

                data.inheritVelocity.enabled = particle.inheritVelocity.enabled;
                data.inheritVelocity.curve = GetMinMaxCurve(particle.inheritVelocity.curve);

                data.velocityOverLifetime.enabled = particle.velocityOverLifetime.enabled;
                data.velocityOverLifetime.speed.x = GetMinMaxCurve(particle.velocityOverLifetime.x);
                data.velocityOverLifetime.speed.y = GetMinMaxCurve(particle.velocityOverLifetime.y);
                data.velocityOverLifetime.speed.z = GetMinMaxCurve(particle.velocityOverLifetime.z);

                data.limitVelocityOverLifetime.enabled = particle.limitVelocityOverLifetime.enabled;
                data.limitVelocityOverLifetime.dampen = particle.limitVelocityOverLifetime.dampen;
                data.limitVelocityOverLifetime.limit.x = GetMinMaxCurve(particle.limitVelocityOverLifetime.limitX);
                data.limitVelocityOverLifetime.limit.y = GetMinMaxCurve(particle.limitVelocityOverLifetime.limitY);
                data.limitVelocityOverLifetime.limit.z = GetMinMaxCurve(particle.limitVelocityOverLifetime.limitZ);

                data.forceOverLifetime.enabled = particle.forceOverLifetime.enabled;
                data.forceOverLifetime.randomized = particle.forceOverLifetime.randomized;
                data.forceOverLifetime.force.x = GetMinMaxCurve(particle.forceOverLifetime.x);
                data.forceOverLifetime.force.y = GetMinMaxCurve(particle.forceOverLifetime.y);
                data.forceOverLifetime.force.z = GetMinMaxCurve(particle.forceOverLifetime.z);

                data.externalForces.enabled = particle.externalForces.enabled;
                data.externalForces.multiplier = particle.externalForces.multiplier;

                data.sizeOverLifetime.enabled = particle.sizeOverLifetime.enabled;
                data.sizeOverLifetime.size.x = GetMinMaxCurve(particle.sizeOverLifetime.x);
                data.sizeOverLifetime.size.y = GetMinMaxCurve(particle.sizeOverLifetime.y);
                data.sizeOverLifetime.size.z = GetMinMaxCurve(particle.sizeOverLifetime.z);

                data.sizeBySpeed.enabled = particle.sizeBySpeed.enabled;
                data.sizeBySpeed.size.x = GetMinMaxCurve(particle.sizeBySpeed.x);
                data.sizeBySpeed.size.y = GetMinMaxCurve(particle.sizeBySpeed.y);
                data.sizeBySpeed.size.z = GetMinMaxCurve(particle.sizeBySpeed.z);
                data.sizeBySpeed.range = particle.sizeBySpeed.range;

                data.rotationOverLifetime.enabled = particle.rotationOverLifetime.enabled;
                data.rotationOverLifetime.rotation.x = GetMinMaxCurve(particle.rotationOverLifetime.x);
                data.rotationOverLifetime.rotation.y = GetMinMaxCurve(particle.rotationOverLifetime.y);
                data.rotationOverLifetime.rotation.z = GetMinMaxCurve(particle.rotationOverLifetime.z);

                data.rotationBySpeed.enabled = particle.rotationBySpeed.enabled;
                data.rotationBySpeed.rotation.x = GetMinMaxCurve(particle.rotationBySpeed.x);
                data.rotationBySpeed.rotation.y = GetMinMaxCurve(particle.rotationBySpeed.y);
                data.rotationBySpeed.rotation.z = GetMinMaxCurve(particle.rotationBySpeed.z);
                data.rotationBySpeed.range = particle.rotationBySpeed.range;

                data.collision.enabled = particle.collision.enabled;
                data.collision.dampen = GetMinMaxCurve(particle.collision.dampen);
                data.collision.bounce = GetMinMaxCurve(particle.collision.bounce);
                data.collision.lifetimeLoss = GetMinMaxCurve(particle.collision.lifetimeLoss);
                data.collision.minKillSpeed = particle.collision.minKillSpeed;

                data.noise.enabled = particle.noise.enabled;
                data.noise.strength.x = GetMinMaxCurve(particle.noise.strengthX);
                data.noise.strength.y = GetMinMaxCurve(particle.noise.strengthY);
                data.noise.strength.z = GetMinMaxCurve(particle.noise.strengthZ);
                data.noise.frequency = particle.noise.frequency;

                data.officialName = name;
                ParticleData.Add(data);
            }
            else
            {
                Console.WriteLine("指定した公式パーティクルは存在しません：" + path);
            }
        }

        /// <summary>
        /// パーティクル更新
        /// </summary>
        public GameObject UpdateParticle(DanceParticle data, bool isNew, bool isPlay)
        {
            if (isNew)
            {
                GameObject.Destroy(data.particle);
                data.particle = new GameObject(data.label);
            }
            var particle = data.particle.GetOrAddComponent<ParticleSystem>();
            if (isPlay)
            {
                particle.Play();
            }
            else
            {
                particle.Stop();
            }

            var render = particle.GetComponent<Renderer>();
            var reader = new FileReader();
            var path = reader.GetFilePath(data.textureName, MyConst.FOLDER_PNG);
            if (!string.IsNullOrEmpty(path))
            {
                var shaderName = string.IsNullOrEmpty(data.shaderName) ? MyConst.SHADER_PARTICLE : data.shaderName;
                var material = new Material(Shader.Find(shaderName));
                material.mainTexture = reader.ReadPngTexture(path);
                if (data.isColor)
                {
                    material.color = data.color;
                }
                render.material = material;
            }
            particle.transform.position = data.position;
            particle.transform.rotation = Quaternion.Euler(data.rotation);
            particle.transform.localScale = data.scale;

            var main = particle.main;
            if (data.main.enabled)
            {
                main.duration = data.main.duration;
                main.loop = data.main.isLoop;
                main.startDelay = GetMinMaxCurve(data.main.startDelay);
                main.startLifetime = GetMinMaxCurve(data.main.startLifetime);
                main.startSpeed = GetMinMaxCurve(data.main.startSpeed);
                main.startSize = GetMinMaxCurve(data.main.startSize);
                main.startRotation = GetMinMaxCurve(data.main.startRotation * Mathf.Deg2Rad);
                main.gravityModifier = GetMinMaxCurve(data.main.gravityModifier);
                main.maxParticles = data.main.maxParticles;
                main.scalingMode = ParticleSystemScalingMode.Local;
            }
            main.playOnAwake = false;

            var emission = particle.emission;
            emission.enabled = data.emission.enabled;
            if (data.emission.enabled)
            {
                emission.rateOverTime = GetMinMaxCurve(data.emission.rateOverTime);
                emission.rateOverDistance = GetMinMaxCurve(data.emission.rateOverDistance);
                if (data.emission.burst != Vector3.zero)
                {
                    var burst = data.emission.burst;
                    emission.SetBursts(new ParticleSystem.Burst[] { new ParticleSystem.Burst(burst.z, (short)burst.x, (short)burst.y) });
                }
                else
                {
                    emission.SetBursts(new ParticleSystem.Burst[] { new ParticleSystem.Burst(0, 0, 0) });
                }
            }

            var shape = particle.shape;
            shape.enabled = data.shape.enabled;
            if (data.shape.enabled)
            {
                shape.shapeType = data.shape.shapeType;
                shape.angle = data.shape.angle;
                shape.sphericalDirectionAmount = data.shape.sphericalDirectionAmount;
                shape.randomDirectionAmount = data.shape.randomDirectionAmount;
                shape.box = data.shape.boxSize;
                shape.radiusMode = data.shape.radiusMode;
                shape.radius = data.shape.radius;
                shape.radiusSpread = data.shape.radiusSpread;
                shape.radiusSpeed = GetMinMaxCurve(data.shape.radiusSpeed);
                shape.arcMode = data.shape.arcMode;
                shape.arc = data.shape.arc;
                shape.arcSpread = data.shape.arcSpread;
                shape.arcSpeed = GetMinMaxCurve(data.shape.arcSpeed);
            }

            var gType = MyConst.PARTICLE_GRADIENT_TYPE.Keys.ToArray();
            var colorOverLifetime = particle.colorOverLifetime;
            colorOverLifetime.enabled = data.colorOverLifetime.enabled;
            if (data.colorOverLifetime.enabled)
            {
                var color = colorOverLifetime.color;
                color.mode = data.colorOverLifetime.isRandom ? ParticleSystemGradientMode.RandomColor : data.colorOverLifetime.mode;
                if (data.colorOverLifetime.mode == gType[0])
                {
                    color.gradient.SetKeys(data.colorOverLifetime.gradientColor[gType[0]], data.colorOverLifetime.gradientAlpha[gType[0]]);
                }
                else
                {
                    color.gradientMin = new Gradient();
                    color.gradientMin.SetKeys(data.colorOverLifetime.gradientColor[gType[0]], data.colorOverLifetime.gradientAlpha[gType[0]]);
                    color.gradientMax.SetKeys(data.colorOverLifetime.gradientColor[gType[1]], data.colorOverLifetime.gradientAlpha[gType[1]]);
                }
                colorOverLifetime.color = color;
            }

            var colorBySpeed = particle.colorBySpeed;
            colorBySpeed.enabled = data.colorBySpeed.enabled;
            if (data.colorBySpeed.enabled)
            {
                var color = colorBySpeed.color;
                color.mode = data.colorBySpeed.isRandom ? ParticleSystemGradientMode.RandomColor : data.colorBySpeed.mode;
                if (data.colorOverLifetime.mode == gType[0])
                {
                    color.gradient.SetKeys(data.colorBySpeed.gradientColor[gType[0]], data.colorBySpeed.gradientAlpha[gType[0]]);
                }
                else
                {
                    color.gradientMin = new Gradient();
                    color.gradientMin.SetKeys(data.colorBySpeed.gradientColor[gType[0]], data.colorBySpeed.gradientAlpha[gType[0]]);
                    color.gradientMax.SetKeys(data.colorBySpeed.gradientColor[gType[1]], data.colorBySpeed.gradientAlpha[gType[1]]);
                }
                colorBySpeed.color = color;
                colorBySpeed.range = data.colorBySpeed.range;
            }

            var inheritVelocity = particle.inheritVelocity;
            inheritVelocity.enabled = data.inheritVelocity.enabled;
            if (data.inheritVelocity.enabled)
            {
                main.simulationSpace = ParticleSystemSimulationSpace.World;
                inheritVelocity.mode = ParticleSystemInheritVelocityMode.Current;
                inheritVelocity.curve = GetMinMaxCurve(data.inheritVelocity.curve);
            }

            var velocityOverLifetime = particle.velocityOverLifetime;
            velocityOverLifetime.enabled = data.velocityOverLifetime.enabled;
            if (data.velocityOverLifetime.enabled)
            {
                velocityOverLifetime.x = GetMinMaxCurve(data.velocityOverLifetime.speed.x);
                velocityOverLifetime.y = GetMinMaxCurve(data.velocityOverLifetime.speed.y);
                velocityOverLifetime.z = GetMinMaxCurve(data.velocityOverLifetime.speed.z);
            }

            var limitVelocityOverLifetime = particle.limitVelocityOverLifetime;
            limitVelocityOverLifetime.enabled = data.limitVelocityOverLifetime.enabled;
            if (data.limitVelocityOverLifetime.enabled)
            {
                limitVelocityOverLifetime.separateAxes = true;
                limitVelocityOverLifetime.dampen = data.limitVelocityOverLifetime.dampen;
                limitVelocityOverLifetime.limitX = GetMinMaxCurve(data.limitVelocityOverLifetime.limit.x);
                limitVelocityOverLifetime.limitY = GetMinMaxCurve(data.limitVelocityOverLifetime.limit.y);
                limitVelocityOverLifetime.limitZ = GetMinMaxCurve(data.limitVelocityOverLifetime.limit.z);
            }

            var forceOverLifetime = particle.forceOverLifetime;
            forceOverLifetime.enabled = data.forceOverLifetime.enabled;
            if (data.forceOverLifetime.enabled)
            {
                forceOverLifetime.randomized = data.forceOverLifetime.randomized;
                forceOverLifetime.x = GetMinMaxCurve(data.forceOverLifetime.force.x);
                forceOverLifetime.y = GetMinMaxCurve(data.forceOverLifetime.force.y);
                forceOverLifetime.z = GetMinMaxCurve(data.forceOverLifetime.force.z);
            }

            var externalForces = particle.externalForces;
            externalForces.enabled = data.externalForces.enabled;
            if (data.externalForces.enabled)
            {
                externalForces.multiplier = data.externalForces.multiplier;
            }

            var sizeOverLifetime = particle.sizeOverLifetime;
            sizeOverLifetime.enabled = data.sizeOverLifetime.enabled;
            if (data.sizeOverLifetime.enabled)
            {
                sizeOverLifetime.separateAxes = true;
                sizeOverLifetime.x = GetMinMaxCurve(data.sizeOverLifetime.size.x);
                sizeOverLifetime.y = GetMinMaxCurve(data.sizeOverLifetime.size.y);
                sizeOverLifetime.z = GetMinMaxCurve(data.sizeOverLifetime.size.z);
            }

            var sizeBySpeed = particle.sizeBySpeed;
            sizeBySpeed.enabled = data.sizeBySpeed.enabled;
            if (data.sizeBySpeed.enabled)
            {
                sizeBySpeed.separateAxes = true;
                sizeBySpeed.x = GetMinMaxCurve(data.sizeBySpeed.size.x);
                sizeBySpeed.y = GetMinMaxCurve(data.sizeBySpeed.size.y);
                sizeBySpeed.z = GetMinMaxCurve(data.sizeBySpeed.size.z);
                sizeBySpeed.range = data.sizeBySpeed.range;
            }

            var rotationOverLifetime = particle.rotationOverLifetime;
            rotationOverLifetime.enabled = data.rotationOverLifetime.enabled;
            if (data.rotationOverLifetime.enabled)
            {
                rotationOverLifetime.separateAxes = true;
                rotationOverLifetime.x = GetMinMaxCurve(data.rotationOverLifetime.rotation.x);
                rotationOverLifetime.y = GetMinMaxCurve(data.rotationOverLifetime.rotation.y);
                rotationOverLifetime.z = GetMinMaxCurve(data.rotationOverLifetime.rotation.z);
            }

            var rotationBySpeed = particle.rotationBySpeed;
            rotationBySpeed.enabled = data.rotationBySpeed.enabled;
            if (data.rotationBySpeed.enabled)
            {
                rotationBySpeed.separateAxes = true;
                rotationBySpeed.x = GetMinMaxCurve(data.rotationBySpeed.rotation.x);
                rotationBySpeed.y = GetMinMaxCurve(data.rotationBySpeed.rotation.y);
                rotationBySpeed.z = GetMinMaxCurve(data.rotationBySpeed.rotation.z);
                rotationBySpeed.range = data.rotationBySpeed.range;
            }

            var collision = particle.collision;
            collision.enabled = data.collision.enabled;
            if (data.collision.enabled)
            {
                collision.dampen = GetMinMaxCurve(data.collision.dampen);
                collision.bounce = GetMinMaxCurve(data.collision.bounce);
                collision.lifetimeLoss = GetMinMaxCurve(data.collision.lifetimeLoss);
                collision.minKillSpeed = data.collision.minKillSpeed;
                collision.type = ParticleSystemCollisionType.World;
            }

            var noise = particle.noise;
            noise.enabled = data.noise.enabled;
            if (data.noise.enabled)
            {
                noise.separateAxes = true;
                noise.strengthX = GetMinMaxCurve(data.noise.strength.x);
                noise.strengthY = GetMinMaxCurve(data.noise.strength.y);
                noise.strengthZ = GetMinMaxCurve(data.noise.strength.z);
                noise.frequency = data.noise.frequency;
                noise.damping = data.noise.damping;
            }

            if (data.render.enabled)
            {
                var psr = data.particle.GetOrAddComponent<ParticleSystemRenderer>();
                psr.renderMode = data.render.mode;
            }

            return data.particle;
        }

        /// <summary>
        /// パーティクルカーブ取得
        /// </summary>
        private ParticleSystem.MinMaxCurve GetMinMaxCurve(Vector2 curve)
        {
            var m2Curve = new ParticleSystem.MinMaxCurve(curve.x, curve.y);
            m2Curve.mode = ParticleSystemCurveMode.TwoConstants;
            return m2Curve;
        }

        /// <summary>
        /// パーティクルカーブ取得（Vector2）
        /// </summary>
        private Vector2 GetMinMaxCurve(ParticleSystem.MinMaxCurve curve)
        {
            return new Vector2(curve.constantMin, curve.constantMax);
        }

        #endregion
    }

    /// <summary>
    /// ライト処理管理
    /// </summary>
    public class StageLightManager
    {
        public Dictionary<LightType, List<FreeLightSet>> LightData { get; set; }
        public FreeLightSet SubLight { get; set; }

        public int LightTypeIndex { get; set; }

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public StageLightManager()
        {
            LightData = new Dictionary<LightType, List<FreeLightSet>>();
        }

        /// <summary>
        /// メインライトコピー
        /// </summary>
        public void CopyMainLight(Light light)
        {
            var m = GameMain.Instance.MainLight.GetComponent<Light>();
            light.shadows = m.shadows;
            light.shadowStrength = m.shadowStrength;
            light.shadowBias = m.shadowBias;
            light.shadowNormalBias = m.shadowNormalBias;
            light.spotAngle = m.spotAngle;
            light.intensity = m.intensity;
            light.range = m.range;
            light.transform.rotation = m.transform.rotation;
        }

        /// <summary>
        /// メインライト取得
        /// </summary>
        public Light GetMainLight()
        {
            return GameMain.Instance.MainLight.GetComponent<Light>(); ;
        }

        /// <summary>
        /// メインライト設定
        /// </summary>
        public void SetMainLight(bool isOn)
        {
            GetMainLight().color = isOn ? MyHelper.SetColorWhite() : MyHelper.SetColorBlack();
        }

        /// <summary>
        /// サブライト作成
        /// </summary>
        public void CreateSubLight()
        {
            var s = new FreeLightSet();
            s.light = new GameObject("SubLight").GetOrAddComponent<Light>();
            s.light.type = LightType.Directional;
            CopyMainLight(s.light);
            s.color = MyHelper.SetColorWhite();
            s.shadowStrength = s.light.shadowStrength;
            s.intensity = s.light.intensity;
            SubLight = s;
        }

        /// <summary>
        /// 補助ライト作成
        /// </summary>
        public void CreateExtraLight(LightType type, FreeLightSet data)
        {
            var name = Enum.GetName(typeof(LightType), type);
            data.light = new GameObject(name).GetOrAddComponent<Light>();
            data.light.type = type;
            data.light.transform.position = data.position;
            data.light.transform.rotation = Quaternion.Euler(data.rotation);
            data.light.intensity = data.intensity;
            data.light.range = data.range;
            data.light.spotAngle = data.spotAngle;
            data.isFollowing = false;
            data.light.color = data.color;
            if (MyHelper.CheckNull(LightData[type]))
            {
                LightData[type] = new List<FreeLightSet>();
            }
            LightData[type].Add(data);
        }

        /// <summary>
        /// ライト破棄
        /// </summary>
        public void DestroyLight(Light light)
        {
            GameObject.Destroy(light);
        }

        /// <summary>
        /// ライト全破棄
        /// </summary>
        public void DestroyAllLight()
        {
            DestroyLight(SubLight.light);
            if (!MyHelper.CheckNull(LightData))
            {
                foreach (var type in MyConst.LIGHT_TYPE)
                {
                    if (LightData.ContainsKey(type) && !MyHelper.CheckNull(LightData[type]))
                    {
                        foreach (var d in LightData[type])
                        {
                            DestroyLight(d.light);
                        }
                        LightData[type] = null;
                    }
                }
            }
            LightData = new Dictionary<LightType, List<FreeLightSet>>();
        }

        /// <summary>
        /// メイド追従ライト位置設定
        /// </summary>
        public void SetLightFollowingPosition(LightType type, List<Maid> maids)
        {
            if (!MyHelper.CheckNull(maids))
            {
                for (int i = 0; i < LightData[type].Count(); i++)
                {
                    var data = LightData[type][i];
                    if (data.isFollowing && data.maidIndex < maids.Count())
                    {
                        var maid = maids[data.maidIndex];
                        var pos = maid.body0.Pelvis.position;
                        pos = new Vector3(pos.x, maid.transform.position.y, pos.z);
                        data.light.transform.position = data.position + pos;
                        data.light.color = data.color;
                        LightData[type][i] = data;
                    }
                }
            }
        }

        /// <summary>
        /// 最大スポットライト数設定
        /// </summary>
        public void SetPixelLightCount(int pixelLightCount)
        {
            if (MyConst.PIXELLIGHT_COUNT < pixelLightCount)
            {
                QualitySettings.pixelLightCount = pixelLightCount;
                MyHelper.GetCameraMain().renderingPath = RenderingPath.Forward;
            }
        }

        /// <summary>
        /// 最大スポットライト数初期化
        /// </summary>
        public void ResetPixelLightCount()
        {
            if (MyConst.PIXELLIGHT_COUNT < QualitySettings.pixelLightCount)
            {
                QualitySettings.pixelLightCount = MyConst.PIXELLIGHT_COUNT;
                MyHelper.GetCameraMain().renderingPath = RenderingPath.UsePlayerSettings;
            }
        }
    }

    /// <summary>
    /// タイムラインモーション親クラス
    /// </summary>
    public class Timeline
    {
        public Dictionary<string, bool> ItemDeletionDic { get; set; }
        public Dictionary<string, bool> ItemAddtionDic { get; set; }
        public Dictionary<string, bool> ItemNewFrameDic { get; set; }
        public int SelectedFrame { get; set; }
        public int CopiedFrame { get; set; }
        public int UpdateIndex { get; set; }
        public int GroupIndex { get; set; }
        public int StartKeyFrame { get; set; }
        public int MaxKeyFrame { get; set; }
        public string SelectedName { get; set; }

        protected Dictionary<int, Dictionary<int, List<MotionTimeLineSet>>> motionData;
        protected Dictionary<int, Dictionary<string, MotionPlaySet>> playData;
        protected Dictionary<int, float> playTimeData;
        private readonly bool isSong;
        private int slotNo;

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public Timeline(bool isSong)
        {
            ItemDeletionDic = new Dictionary<string, bool>();
            ItemAddtionDic = new Dictionary<string, bool>();
            ItemNewFrameDic = new Dictionary<string, bool>();
            playTimeData = new Dictionary<int, float>();
            slotNo = MyConst.PRE_INDEX;
            StartKeyFrame = 0;
            MaxKeyFrame = MyConst.MAX_KEY_FRAME;
            this.isSong = isSong;
        }

        /// <summary>
        /// 初期化
        /// </summary>
        public void Initialize(bool isMorph)
        {
            SelectedFrame = 0;
            UpdateIndex = 0;
            GroupIndex = 0;
            CopiedFrame = 0;
            motionData = new Dictionary<int, Dictionary<int, List<MotionTimeLineSet>>>();
            playData = new Dictionary<int, Dictionary<string, MotionPlaySet>>();
            SelectedName = isMorph ? MyConst.FACE_EYE_CLOSE : MyConst.BONE_ALL;
        }

        /// <summary>
        /// キーフレーム有無確認
        /// </summary>
        public bool ExistsKeyFrame(int slotNo)
        {
            return motionData[slotNo].ContainsKey(SelectedFrame);
        }

        /// <summary>
        /// キーフレーム取得
        /// </summary>
        public List<int> GetKeyFrame(int slotNo)
        {
            return GetTimeLineKeyFrame(motionData[slotNo].Keys.ToList());
        }

        /// <summary>
        /// タイムラインキーフレーム設定
        /// </summary>
        public int SetTimelineSelectedKeyFrame(int slotNo, TimeLineFrameSelectType selectType)
        {
            if (selectType != TimeLineFrameSelectType.Non)
            {
                return SetTimelineKeyFrame(motionData[slotNo].Keys.ToList(), selectType, false);
            }
            return SelectedFrame;
        }

        /// <summary>
        /// モーション値取得
        /// </summary>
        public Dictionary<int, List<string>> GetMotionKeyValue(int slotNo,List<int> keyFrame)
        {
            var data = new Dictionary<int, List<string>>();
            if (motionData.ContainsKey(slotNo))
            {
                foreach (var pair in motionData[slotNo])
                {
                    if (keyFrame.Exists(d => d == pair.Key))
                    {
                        data[pair.Key] = pair.Value.Select(d => d.name).ToList();
                    }
                }
            }
            return data;
        }

        /// <summary>
        /// メイドスロット番号有無確認
        /// </summary>
        public bool ContainsSlotNo(int slotNo)
        {
            var contains = false;
            if (!MyHelper.CheckNull(motionData))
            {
                if (motionData.ContainsKey(slotNo))
                {
                    if (!MyHelper.CheckNull(motionData[slotNo]))
                    {
                        contains = true;
                    }
                }
            }
            return contains;
        }

        /// <summary>
        /// 未追加ボーン項目除去
        /// </summary>
        public void SweepItemData(List<int> data)
        {
            foreach (var key in motionData.Keys.ToList())
            {
                if (!data.Exists(d => d == key))
                {
                    motionData.Remove(key);
                }
            }
        }

        /// <summary>
        /// 選択ボーン名保持
        /// </summary>
        public void SetSelectedItemName(int slotNo, int frame)
        {
            if (!motionData.ContainsKey(slotNo))
            {
                return;
            }
            var dic = motionData[slotNo];
            if (dic.ContainsKey(frame))
            {
                if (!dic[frame].Exists(d => d.name == SelectedName))
                {
                    SelectedName = dic[frame].FirstOrDefault().name;
                }
            }
        }

        /// <summary>
        /// 歌モードタイム設定
        /// </summary>
        public void SetSongPlatyTime(int slotNo, float time)
        {
            playTimeData[slotNo] = time;
        }

        /// <summary>
        /// カメラ位置調整
        /// </summary>
        public Vector3 AdjustedCameraosition(Vector3 position, Vector3 rotation, float distance)
        {
            var rotX = rotation.x * Mathf.Deg2Rad * -1;
            var rotY = rotation.y * Mathf.Deg2Rad;
            var pos = new Vector3(Mathf.Cos(rotX) * Mathf.Sin(rotY), Mathf.Sin(rotX), Mathf.Cos(rotX) * Mathf.Cos(rotY));
            return position + pos * distance * -1;
        }

        /// <summary>
        /// イージング処理後位置取得
        /// </summary>
        public float GetEasingPosition(float lerpTime, int type, float startValue, float endValue)
        {
            var t = new TimelineMotionEasing().MotionEasing(lerpTime, (EasingType)type);
            return Mathf.Lerp(startValue, endValue, t);
        }

        /// <summary>
        /// イージング処理後回転取得
        /// </summary>
        public Quaternion GetEasingRotation(float lerpTime, int type, Vector3 startValue, Vector3 endValue)
        {
            return GetEasingRotation(lerpTime, type, Quaternion.Euler(startValue), Quaternion.Euler(endValue));
        }

        protected Quaternion GetEasingRotation(float lerpTime, int type, Quaternion startValue, Quaternion endValue)
        {
            var t = new TimelineMotionEasing().MotionEasing(lerpTime, (EasingType)type);
            return Quaternion.Slerp(startValue, endValue, t);
        }

        /// <summary>
        /// 途中開始用フレーム取得
        /// </summary>
        protected int SetFromFrame(int slotNo, TimeLinePlaySet tlPlaySet)
        {
            var frame = MyConst.PRE_INDEX;
            if (0 < tlPlaySet.fromFrame && playTimeData[slotNo] <= tlPlaySet.fromFrame * MyConst.FRAME_CONVERSION_RATIO)
            {
                frame = tlPlaySet.fromFrame;
                playTimeData[slotNo] = frame * MyConst.FRAME_CONVERSION_RATIO;
            }
            return frame;
        }

        /// <summary>
        /// タイムラインキーフレーム設定
        /// </summary>
        protected int SetTimelineKeyFrame(List<int> frames, TimeLineFrameSelectType selectType, bool isCamera)
        {
            frames = GetTimeLineKeyFrame(frames);
            var frame = SelectedFrame;
            switch (selectType)
            {
                case TimeLineFrameSelectType.Min:
                    frame = frames.Min();
                    break;
                case TimeLineFrameSelectType.Before:
                    var data = frames.FindAll(d => d < frame);
                    if (!MyHelper.CheckNull(data))
                    {
                        frame = data.Max();
                    }
                    else
                    {
                        frame = frames.Min();
                    }
                    break;
                case TimeLineFrameSelectType.Next:
                    data = frames.FindAll(d => frame < d);
                    if (!MyHelper.CheckNull(data))
                    {
                        frame = data.Min();
                    }
                    else
                    {
                        frame = frames.Max();
                    }
                    break;
                case TimeLineFrameSelectType.Max:
                    frame = frames.Max();
                    break;
            }

            if(!isCamera)
            {
                SetSelectedItemName(slotNo, frame);
            }
            return frame;
        }

        /// <summary>
        /// タイムラインキーフレーム有無確認
        /// </summary>
        protected bool CheckTimeLineKeyFrame(int frame, List<int> frames)
        {
            frames = GetTimeLineKeyFrame(frames);
            var isOk = false;
            if (frames.Exists(d => d == frame))
            {
                Console.WriteLine("キーフレームが１以上存在するフレームは作成できません");
            }
            else if (MaxKeyFrame < frames.Count())
            {
                Console.WriteLine(string.Format("キーフレーム最大数は{0}です", MaxKeyFrame));
            }
            else
            {
                isOk = true;
            }
            return isOk;
        }

        /// <summary>
        /// コピーフレーム範囲内確認
        /// </summary>
        protected bool CheckCopyFrame(int slotNo, int copyFrame)
        {
            var data = GetTimeLineKeyFrame(motionData[slotNo].Keys.ToList());
            return data.Min() <= copyFrame;
        }

        /// <summary>
        /// インデックス変更
        /// </summary>
        protected bool ChangeIndex(ref MotionPlaySet data)
        {
            data.listIndex = MyConst.PRE_INDEX;
            for (int i = 0; i < data.motion.Count(); i++)
            {
                if (data.motion[i].stFrame <= SelectedFrame && SelectedFrame <= data.motion[i].edFrame)
                {
                    data.listIndex = i;
                    break;
                }
            }
            var isLast = false;
            if (data.listIndex == MyConst.PRE_INDEX)
            {
                data.listIndex = data.motion.Count() - 1;
                isLast = true;
            }
            return isLast;
        }

        /// <summary>
        /// フレームコピー
        /// </summary>
        protected bool CopyFrame(int slotNo, int copyFrame)
        {
            if (CheckCopyFrame(slotNo, copyFrame) && CheckKeyFrame(slotNo, copyFrame))
            {
                var data = new List<MotionTimeLineSet>(motionData[slotNo][SelectedFrame]);
                for (int i = 0; i < data.Count(); i++)
                {
                    var d = data[i];
                    d.frame = copyFrame;
                    data[i] = d;
                }
                motionData[slotNo][copyFrame] = data;
                return true;
            }
            return false;
        }

        /// <summary>
        /// フレーム削除
        /// </summary>
        protected bool DeleteFrame(int slotNo, string selectedName)
        {
            if (0 < SelectedFrame && !MyHelper.CheckNull(motionData))
            {
                if (motionData.ContainsKey(slotNo))
                {
                    if (motionData[slotNo][SelectedFrame].Exists(d => d.name == selectedName))
                    {
                        motionData[slotNo][SelectedFrame].RemoveAll(d => d.name == selectedName);
                        if (MyHelper.CheckNull(motionData[slotNo][SelectedFrame]))
                        {
                            motionData[slotNo].Remove(SelectedFrame);
                        }
                        return true;
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// タイムラインキーフレーム有無確認
        /// </summary>
        protected bool CheckKeyFrame(int slotNo, int frame)
        {
            return CheckTimeLineKeyFrame(frame, motionData[slotNo].Keys.ToList());
        }

        /// <summary>
        /// 範囲内キーフレーム取得
        /// </summary>
        protected List<int> GetTimeLineKeyFrame(List<int> frames)
        {
            var max = frames.Max();
            if (frames.Max() < StartKeyFrame)
            {
                StartKeyFrame = max;
            }
            frames = frames.FindAll(d => StartKeyFrame <= d).OrderBy(d => d).ToList();
            if (MaxKeyFrame < frames.Count())
            {
                frames = frames.GetRange(0, MaxKeyFrame);
            }
            return frames;
        }

        /// <summary>
        /// ループ再生用初期化
        /// </summary>
        protected void ResetLoopData(int slotNo)
        {
            if (!playData.ContainsKey(slotNo))
            {
                return;
            }
            var dic = playData[slotNo];
            foreach (var key in dic.Keys.ToList())
            {
                var data = dic[key];
                data.listIndex = 0;
                data.lerpFrame = 0;
                dic[key] = data;
            }
            playData[slotNo] = dic;
        }

        /// <summary>
        /// メイド変更時スロット番号保持
        /// </summary>
        protected bool SaveMaidSlotNo(int slotNo)
        {
            if (this.slotNo != slotNo)
            {
                this.slotNo = slotNo;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Gui用アイテム辞書設定
        /// </summary>
        protected void SetItemDic(int slotNo, string[] keys)
        {
            if (this.slotNo != slotNo)
            {
                return;
            }
            ItemDeletionDic = new Dictionary<string, bool>();
            ItemAddtionDic = new Dictionary<string, bool>();
            ItemNewFrameDic = new Dictionary<string, bool>();
            var dic = motionData[slotNo];
            foreach (var key in keys)
            {
                if (dic.ContainsKey(SelectedFrame))
                {
                    if (dic[SelectedFrame].Exists(d => d.name == key))
                    {
                        ItemDeletionDic[key] = false;
                    }
                    else
                    {
                        ItemAddtionDic[key] = false;
                    }
                }
                ItemNewFrameDic[key] = false;
            }
        }

        /// <summary>
        /// 歌モード判定
        /// </summary>
        protected bool IsSong()
        {
            return isSong;
        }
        
    }

    /// <summary>
    /// タイムラインボーンモーション処理管理
    /// </summary>
    public class TimelineBoneManager : Timeline
    {
        public AudioManager AudioMgr { get; set; }

        private readonly Dictionary<string, Dictionary<string, MotionPlaySet>> songData;
        private Vector3 resetPosition;
        private Vector3 resetRotation;

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public TimelineBoneManager(bool isSong) : base (isSong)
        {
            Initialize(false);
            AudioMgr = new AudioManager();
            songData = new Dictionary<string, Dictionary<string, MotionPlaySet>>();
        }

        /// <summary>
        /// ボーンデータファイル読み込み
        /// </summary>
        public void ReadBoneData(Maid maid, int slotNo, string fileName)
        {
            var dic = new Dictionary<int, List<MotionTimeLineSet>>();
            var filePath = new FileReader().GetFilePath(fileName, MyConst.FOLDER_TIMELINE);
            if (!string.IsNullOrEmpty(filePath))
            {
                var motion = new FileReader().ReadTimelineMotionFileData(filePath);
                if (!MyHelper.CheckNull(motion))
                {
                    foreach (var m in motion)
                    {
                        if (!dic.ContainsKey(m.frame))
                        {
                            dic[m.frame] = new List<MotionTimeLineSet>();
                        }
                        dic[m.frame].Add(m);
                    }
                }
                if (IsSong())
                {
                    motionData[slotNo] = dic;
                }
                else
                {
                    SetDefaultBoneData(maid, slotNo, dic);
                }
            }
        }

        /// <summary>
        /// ボーンデータファイル書き込み
        /// </summary>
        public void WriteBoneData(int slotNo, string fileName, bool isAllMaids)
        {
            if (!MyHelper.CheckNull(motionData) && !string.IsNullOrEmpty(fileName))
            {
                var data = new List<MotionTimeLineSet>();
                var frames = motionData[slotNo].Keys.OrderBy(d => d);

                foreach (var frame in frames)
                {
                    foreach (var name in MyConst.BONE_NAME_ALL.Keys)
                    {
                        var motion = motionData[slotNo][frame].FirstOrDefault(d => d.name == name);
                        if (!string.IsNullOrEmpty(motion.name))
                        {
                            var d = new MotionTimeLineSet();
                            d.frame = motion.frame;
                            d.name = motion.name;
                            d.rotation = motion.rotation;
                            d.easing = motion.easing;
                            if (d.name == MyConst.BONE_ALL)
                            {
                                d.position = motion.position;
                            }
                            data.Add(d);
                        }
                    }
                }
                fileName = (isAllMaids ? slotNo.ToString() + "_" : "") + fileName;
                new FileWriter().WriteMaidBone(data, fileName);
            }
        }

        /// <summary>
        /// ボーンデータ更新
        /// </summary>
        public void UpdateBoneData(MotionTimeLineSet motion, int slotNo)
        {
            var data = motionData[slotNo][SelectedFrame].FirstOrDefault(d => d.name == SelectedName);
            var isChanged = false;
            var isEasing = false;
            if (data.position != motion.position)
            {
                data.position = motion.position;
                isChanged = true;
            }
            if (data.rotation != motion.rotation)
            {
                data.rotation = motion.rotation;
                isChanged = true;
            }
            if (data.easing != motion.easing)
            {
                data.easing = motion.easing;
                isChanged = true;
                isEasing = true;
            }
            if (isChanged)
            {
                motionData[slotNo][SelectedFrame].RemoveAll(d => d.name == SelectedName);
                motionData[slotNo][SelectedFrame].Add(motion);
                if (isEasing)
                {
                    var dt = motionData[slotNo][SelectedFrame];
                    for (int i = 0; i < dt.Count(); i++)
                    {
                        var d = dt[i];
                        d.easing = motion.easing;
                        dt[i] = d;
                    }
                    motionData[slotNo][SelectedFrame] = dt;
                }
                SetPlayBoneData(slotNo);
            }
        }

        /// <summary>
        /// 再生時ボーンデータ更新
        /// </summary>
        public void UpdatePlayBone(Maid maid, int slotNo, TimeLinePlaySet tlPlaySet)
        {
            if (!playData.ContainsKey(slotNo))
            {
                return;
            }
            var isContinue = false;
            var dic = playData[slotNo];
            var frame = SetFromFrame(slotNo, tlPlaySet);
            foreach (var key in dic.Keys.ToList())
            {
                var data = dic[key];
                if (data.motion.Count == 0) continue;

                if (frame != MyConst.PRE_INDEX)
                {
                    for (int i = data.listIndex; i < data.motion.Count(); i++)
                    {
                        if (playTimeData[slotNo] <= data.motion[data.listIndex].edFrame * MyConst.FRAME_CONVERSION_RATIO)
                        {
                            break;
                        }
                        data.listIndex++;
                    }
                    if (data.motion.Count() <= data.listIndex)
                    {
                        data.listIndex = MyConst.PRE_INDEX;
                    }
                }
                if (data.listIndex == MyConst.PRE_INDEX)
                {
                    continue;
                }
                isContinue = true;
                if (playTimeData[slotNo] <= data.motion[data.listIndex].edFrame * MyConst.FRAME_CONVERSION_RATIO)
                {
                    UpdateMaidBone(maid, key, frame, false, ref data);
                }
                else
                {
                    data.lerpFrame = 0;
                    data.listIndex++;
                    if (data.motion.Count() <= data.listIndex)
                    {
                        data.listIndex = MyConst.PRE_INDEX;
                    }
                }
                dic[key] = data;
            }
            if (!isContinue && tlPlaySet.isLoop)
            {
                SetPlayingBone(maid, slotNo, tlPlaySet.isLoop);
                if (tlPlaySet.isLoop)
                {
                    playTimeData[slotNo] += Time.deltaTime;
                }
            }
            else
            {
                playData[slotNo] = dic;
                playTimeData[slotNo] += Time.deltaTime;
            }
        }        

        /// <summary>
        /// フレーム移動時ボーンデータ更新
        /// </summary>
        public void UpdateFrameBone(Maid maid, int slotNo)
        {
            if (!playData.ContainsKey(slotNo))
            {
                return;
            }
            var dic = playData[slotNo];
            foreach (var key in dic.Keys.ToList())
            {
                var data = dic[key];
                var isLast = ChangeIndex(ref data);
                UpdateMaidBone(maid, key, SelectedFrame, isLast, ref data);
                dic[key] = data;
            }
            playData[slotNo] = dic;
            SetItemDic(slotNo, MyConst.BONE_NAME_ALL.Keys.ToArray());
        }

        /// <summary>
        /// 再生用ボーンデータ設定
        /// </summary>
        public void SetPlayingBone(Maid maid, int slotNo, bool isLoop)
        {
            SelectedFrame = 0;
            playTimeData[slotNo] = 0f;
            if (isLoop)
            {
                ResetLoopData(slotNo);
            }
            else
            {
                SetPlayBoneData(slotNo);
                if (playData.ContainsKey(slotNo))
                {
                    SetZeroBone(maid, slotNo);
                }
            }
        }

        /// <summary>
        /// タイムライン新規フレーム作成
        /// </summary>
        public void CreateNewFrame(Maid maid, int slotNo, int frame)
        {
            if (CheckKeyFrame(slotNo, frame))
            {
                var data = new List<MotionTimeLineSet>();
                foreach (var pair in ItemNewFrameDic)
                {
                    if (pair.Value)
                    {
                        data.Add(GetCurrentBone(maid, pair.Key, frame));
                    }
                }
                if (!MyHelper.CheckNull(data))
                {
                    motionData[slotNo][frame] = data;
                    SetSelectedItemName(slotNo, frame);
                    SetPlayBoneData(slotNo);
                    SetResetValue(slotNo);
                }
            }
        }

        /// <summary>
        /// タイムラインへアイテム追加
        /// </summary>
        public void AddTimeLineItem(Maid maid, int slotNo)
        {
            var isChecked = false;
            foreach (var pair in ItemAddtionDic)
            {
                if (pair.Value && !motionData[slotNo][SelectedFrame].Exists(d => d.name == pair.Key))
                {
                    motionData[slotNo][SelectedFrame].Add(GetCurrentBone(maid, pair.Key, SelectedFrame));
                    isChecked = true;
                }
            }
            if (isChecked)
            {
                SetPlayBoneData(slotNo);
            }
        }

        /// <summary>
        /// タイムラインからアイテム削除
        /// </summary>
        public void DeleteTimeLineItem(int slotNo)
        {
            var isChecked = false;
            foreach (var pair in ItemDeletionDic)
            {
                if (pair.Value)
                {
                    motionData[slotNo][SelectedFrame].RemoveAll(d => d.name == pair.Key);
                    isChecked = true;
                }
            }
            if (isChecked)
            {
                if (MyHelper.CheckNull(motionData[slotNo][SelectedFrame]))
                {
                    motionData[slotNo].Remove(SelectedFrame);
                }
                SetPlayBoneData(slotNo);
            }
        }

        /// <summary>
        /// フレームコピー
        /// </summary>
        public void CopySelectedFrame(int slotNo, int copyFrame)
        {
            if (CopyFrame(slotNo, copyFrame))
            {
                SetPlayBoneData(slotNo);
            }
        }

        /// <summary>
        /// フレーム削除
        /// </summary>
        public void DeleteSelectedFrame(int slotNo)
        {
            if (DeleteFrame(slotNo, SelectedName))
            {
                SetPlayBoneData(slotNo);
            }
        }

        /// <summary>
        /// 初期ボーン値設定
        /// </summary>
        public void SetDefaultBone(Maid maid, int slotNo)
        {
            var dic = new Dictionary<int, List<MotionTimeLineSet>>();
            SetDefaultBoneData(maid, slotNo, dic);
            SetResetValue(slotNo);
        }

        /// <summary>
        /// メイド変更時スロット番号保持
        /// </summary>
        public void ChangeMaidSlotNo(Maid maid, int slotNo)
        {
            if (SaveMaidSlotNo(slotNo))
            {
                UpdateFrameBone(maid, slotNo);
            }
        }

        /// <summary>
        /// 初期値設定
        /// </summary>
        private void SetDefaultBoneData(Maid maid, int slotNo, Dictionary<int, List<MotionTimeLineSet>> dic)
        {
            SelectedFrame = 0;
            SelectedName = MyConst.BONE_ALL;
            if (MyHelper.CheckNull(dic))
            {
                dic[SelectedFrame] = new List<MotionTimeLineSet>();
                foreach (var key in MyConst.BONE_NAME_ALL.Keys)
                {
                    var data = GetCurrentBone(maid, key, SelectedFrame);
                    data.rotation = Vector3.zero;
                    if (MyConst.BONE_DEFAULT_ROTATION.ContainsKey(key))
                    {
                        data.rotation = MyConst.BONE_DEFAULT_ROTATION[key];
                    }
                    if (key == MyConst.BONE_ALL)
                    {
                        data.position = MyConst.BONE_DEFAULT_POSITON[key];
                    }
                    dic[SelectedFrame].Add(data);
                }
            }
            else
            {
                if (!dic.ContainsKey(SelectedFrame))
                {
                    dic[SelectedFrame] = new List<MotionTimeLineSet>();
                }
                foreach (var key in MyConst.BONE_NAME_ALL.Keys)
                {
                    if (!dic[SelectedFrame].Exists(d => d.name == key))
                    {
                        dic[SelectedFrame].Add(GetCurrentBone(maid, key, SelectedFrame));
                    }
                }
            }
            motionData[slotNo] = dic;
            SetZeroBone(maid, slotNo);
            SetPlayBoneData(slotNo);
        }

        /// <summary>
        /// 線形補間値算出
        /// </summary>
        private float CalcLerp(int frame, bool isLast, MotionPlayLoopSet motion, float lerpFrame)
        {
            if (motion.deltaFrame == 0)
            {
                lerpFrame = 0;
            }
            else if (isLast)
            {
                lerpFrame = 1;
            }
            else if (frame == MyConst.PRE_INDEX)
            {
                lerpFrame += Mathf.Clamp01(1 / (float)motion.deltaFrame * Time.deltaTime * MyConst.BASE_FRAME);
            }
            else
            {
                lerpFrame = (frame - motion.stFrame) / (float)motion.deltaFrame;
            }
            return lerpFrame;
        }

        /// <summary>
        /// ボーン値更新
        /// </summary>
        private void UpdateMaidBone(Maid maid, string boneName, int frame, bool isLast, ref MotionPlaySet data)
        {
            var motion = data.motion[data.listIndex];
            data.lerpFrame = CalcLerp(frame, isLast, motion, data.lerpFrame);
            var bone = maid.body0.GetBone(boneName);

            if (IsSong())
            {
                bone.transform.localRotation = GetEasingRotation(data.lerpFrame, motion.easing, motion.transform.stQua, motion.transform.edQua);
            }
            else
            {
                bone.transform.localRotation = GetEasingRotation(data.lerpFrame, motion.easing, motion.transform.stRot, motion.transform.edRot);
            }
            if (boneName == MyConst.BONE_ALL)
            {
                var x = GetEasingPosition(data.lerpFrame, motion.easing, motion.transform.stPos.x, motion.transform.edPos.x);
                var y = GetEasingPosition(data.lerpFrame, motion.easing, motion.transform.stPos.y, motion.transform.edPos.y);
                var z = GetEasingPosition(data.lerpFrame, motion.easing, motion.transform.stPos.z, motion.transform.edPos.z);
                bone.transform.localPosition = new Vector3(x, y, z);
            }
        }

        /// <summary>
        /// 再生用ボーン値設定
        /// </summary>
        private void SetPlayBoneData(int slotNo)
        {
            if (MyHelper.CheckNull(motionData))
            {
                return;
            }
            if (!motionData.ContainsKey(slotNo))
            {
                return;
            }
            var dic = new Dictionary<string, MotionPlaySet>();
            foreach (var key in MyConst.BONE_NAME_ALL.Keys)
            {
                var mm = new MotionPlaySet();
                mm.motion = new List<MotionPlayLoopSet>();
                dic[key] = mm;
            }

            foreach (var frame in motionData[slotNo].Keys.OrderBy(d => d))
            {
                foreach (var d in motionData[slotNo][frame])
                {
                    var loop = new MotionPlayLoopSet();
                    loop.stFrame = d.frame;
                    loop.edFrame = loop.stFrame;
                    loop.transform.stRot = d.rotation;
                    loop.transform.edRot = d.rotation;
                    loop.transform.stQua = Quaternion.Euler(d.rotation);
                    loop.transform.edQua = loop.transform.stQua;

                    if (d.name == MyConst.BONE_ALL)
                    {
                        loop.transform.stPos = d.position;
                        loop.transform.edPos = d.position;
                    }
                    dic[d.name].motion.Add(loop);

                    if (frame != 0)
                    {
                        var idx = dic[d.name].motion.Count() - 2;
                        var m = dic[d.name].motion[idx];
                        m.edFrame = d.frame;
                        m.deltaFrame = m.edFrame - m.stFrame;
                        m.easing = d.easing;
                        m.transform.edRot = d.rotation;
                        m.transform.edQua = Quaternion.Euler(d.rotation);

                        if (d.name == MyConst.BONE_ALL)
                        {
                            m.transform.edPos = d.position;
                        }
                        dic[d.name].motion[idx] = m;
                    }
                }
            }
            if (!MyHelper.CheckNull(dic))
            {
                playData[slotNo] = dic;
            }
            if (!IsSong())
            {
                SetItemDic(slotNo, MyConst.BONE_NAME_ALL.Keys.ToArray());
            }
        }

        /// <summary>
        /// 0フレームボーン値設定
        /// </summary>
        private void SetZeroBone(Maid maid, int slotNo)
        {
            var frame = 0;
            if (motionData[slotNo].ContainsKey(frame))
            {
                foreach (var data in motionData[slotNo][frame])
                {
                    var bone = maid.body0.GetBone(data.name);
                    if (data.name == MyConst.BONE_ALL)
                    {
                        bone.transform.localPosition = data.position;
                    }
                    bone.transform.localEulerAngles = data.rotation;
                }
            }
        }

        /// -------------------------------------------------------------------------

        /// <summary>
        /// 位置値取得
        /// </summary>
        public Vector3 GetPosition(int slotNo)
        {
            return motionData[slotNo][SelectedFrame].FirstOrDefault(d => d.name == SelectedName).position;
        }

        /// <summary>
        /// 回転値取得
        /// </summary>
        public Vector3 GetRotation(int slotNo)
        {
            return motionData[slotNo][SelectedFrame].FirstOrDefault(d => d.name == SelectedName).rotation;
        }

        /// <summary>
        /// リセット値取得
        /// </summary>
        public void GetResetValue(ref Vector3 position, ref Vector3 rotation)
        {
            position = resetPosition;
            rotation = resetRotation;
        }

        /// <summary>
        /// イージング値取得
        /// </summary>
        public int GetEasingData(int slotNo)
        {
            return motionData[slotNo][SelectedFrame].FirstOrDefault(d => d.name == SelectedName).easing;
        }

        /// <summary>
        /// リセット値取得
        /// </summary>
        public void SetResetValue(int slotNo)
        {
            resetPosition = GetPosition(slotNo);
            resetRotation = GetRotation(slotNo);
        }

        /// <summary>
        /// 現在ボーン値設定
        /// </summary>
        public void SetCurrentBone(Maid maid, int slotNo)
        {
            if (!playData.ContainsKey(slotNo))
            {
                return;
            }
            var boneNames = motionData[slotNo][SelectedFrame].Select(d => d.name);
            var data = new List<MotionTimeLineSet>();
            foreach (var boneName in boneNames)
            {
                data.Add(GetCurrentBone(maid, boneName, SelectedFrame));
            }
            if (!MyHelper.CheckNull(data))
            {
                motionData[slotNo].Remove(SelectedFrame);
                motionData[slotNo][SelectedFrame] = data;
                SetSelectedItemName(slotNo, SelectedFrame);
                SetPlayBoneData(slotNo);
            }
        }

        /// <summary>
        /// アニメーションファイル作成
        /// </summary>
        public void CreateAnimationFile(Maid maid, int slotNo, string fileName)
        {
            var cacheDic = GetCacheData(maid, slotNo);
            if (!MyHelper.CheckNull(cacheDic))
            {
                var anmBinary = CreateBinaryData(cacheDic);
                new FileWriter().WriteAnimationFile(anmBinary, fileName);
            }
        }

        /// <summary>
        /// 歌モードデータ設定
        /// </summary>
        public void SetSongData(string folder, string fileName, int slotNo)
        {
            if (!songData.ContainsKey(fileName))
            {
                var path = new FileReader().GetFilePath(fileName, Path.Combine(MyConst.FOLDER_TIMELINE, folder));
                if (!string.IsNullOrEmpty(path))
                {
                    ReadBoneData(null, slotNo, path);
                    SetPlayBoneData(slotNo);
                    songData[fileName] = playData[slotNo];
                }
            }
            else
            {
                var dic = new Dictionary<string, MotionPlaySet>();
                foreach (var pair in songData[fileName])
                {
                    var data = new MotionPlaySet();
                    data.motion = new List<MotionPlayLoopSet>(pair.Value.motion);
                    dic[pair.Key] = data;
                }
                playData[slotNo] = dic;
            }
            playTimeData[slotNo] = 0f;
        }

        /// <summary>
        /// 歌モードフェードデータ設定
        /// </summary>
        public void SetSongFadeData(Maid maid, int slotNo, string motion, float fadeTime)
        {
            motionData[slotNo] = new Dictionary<int, List<MotionTimeLineSet>>();
            var data = new List<MotionTimeLineSet>();
            foreach (var name in MyConst.BONE_NAME_ALL.Keys)
            {
                data.Add(GetCurrentBone(maid, name, 0));
            }
            motionData[slotNo][0] = data;

            var frame = MyHelper.ConvertFrame(fadeTime);
            data = new List<MotionTimeLineSet>();
            foreach (var pair in songData[motion])
            {
                var m = pair.Value.motion.FirstOrDefault(d => d.stFrame == 0);
                var t = new MotionTimeLineSet();
                t.frame = frame;
                t.name = pair.Key;
                t.position = m.transform.stPos;
                t.rotation = m.transform.stRot;
                t.easing = m.easing;
                data.Add(t);
            }
            motionData[slotNo][frame] = data;
            SetPlayBoneData(slotNo);
            playTimeData[slotNo] = 0f;
        }

        /// <summary>
        /// 歌モードデータ変更
        /// </summary>
        public void ChangeSongData(int slotNo, string motion, float speed)
        {
            playData[slotNo] = new Dictionary<string, MotionPlaySet>(songData[motion]);
            if (speed != MyConst.NORMAL_ANIMATION_SPEED)
            {
                foreach (var key in playData[slotNo].Keys.ToList())
                {
                    var data = new MotionPlaySet();
                    data.motion = new List<MotionPlayLoopSet>();
                    foreach (var m in playData[slotNo][key].motion)
                    {
                        var d = new MotionPlayLoopSet();
                        d.stFrame = (int)(m.stFrame * (1f / speed));
                        d.edFrame = (int)(m.edFrame * (1f / speed));
                        d.deltaFrame = d.edFrame - d.stFrame;
                        d.transform = m.transform;
                        d.easing = m.easing;
                        data.motion.Add(d);
                    }
                    playData[slotNo][key] = data;
                }
            }
            playTimeData[slotNo] = 0f;
        }

        /// <summary>
        /// 現在ボーン値取得
        /// </summary>
        private MotionTimeLineSet GetCurrentBone(Maid maid, string boneName, int frame)
        {
            var bone = maid.body0.GetBone(boneName);
            var data = new MotionTimeLineSet();
            data.frame = frame;
            data.name = boneName;
            if (boneName == MyConst.BONE_ALL)
            {
                data.position = bone.transform.localPosition;
            }
            data.rotation = bone.transform.localEulerAngles;
            data.easing = (int)EasingType.Linear;
            return data;
        }

        /// <summary>
        /// アニメーションファイル作成用ボーン値
        /// </summary>
        private struct BoneCache
        {
            public string bonePath;
            public float time;
            public float[] array;
        }

        /// <summary>
        /// メイドポジション値
        /// </summary>
        private struct MaidAnimationSet
        {
            public string boneName;
            public Vector3 localPosition;
            public Quaternion localRotation;
        }

        /// <summary>
        /// ボーン値保持
        /// </summary>
        private Dictionary<string, List<BoneCache>> GetCacheData(Maid maid, int slotNo)
        {
            var cacheDic = new Dictionary<string, List<BoneCache>>();
            foreach (var frame in motionData[slotNo].Keys)
            {
                SelectedFrame = frame;
                var anmData = GetTransform(maid, slotNo);

                foreach (var path in MyConst.BONE_PATH)
                {
                    var name = path.Split(MyConst.DELIMITER_PATH).Last();

                    Vector3 localPosition;
                    Quaternion localRotation;
                    if (maid != null)
                    {
                        var bone = maid.body0.GetBone(name);
                        localPosition = bone.localPosition;
                        localRotation = bone.localRotation;
                    }
                    else
                    {
                        var bone = anmData.FirstOrDefault(d => d.boneName == name);
                        if (string.IsNullOrEmpty(bone.boneName))
                        {
                            continue;
                        }
                        localPosition = bone.localPosition;
                        localRotation = bone.localRotation;
                    }
                    var data = new BoneCache();
                    data.bonePath = path;
                    data.time = frame * MyConst.FRAME_CONVERSION_RATIO;
                    if (name == MyConst.BONE_ALL)
                    {
                        data.array = new float[]
                        {
                            localRotation.x,
                            localRotation.y,
                            localRotation.z,
                            localRotation.w,
                            localPosition.x,
                            localPosition.y,
                            localPosition.z
                        };
                    }
                    else
                    {
                        data.array = new float[]
                        {
                            localRotation.x,
                            localRotation.y,
                            localRotation.z,
                            localRotation.w
                        };
                    }
                    if (!cacheDic.ContainsKey(path))
                    {
                        cacheDic[path] = new List<BoneCache>();
                    }
                    cacheDic[path].Add(data);
                }
            }
            return cacheDic;
        }

        /// <summary>
        /// 座標取得
        /// </summary>
        private List<MaidAnimationSet> GetTransform(Maid maid, int slotNo)
        {
            if (!playData.ContainsKey(slotNo))
            {
                return null;
            }
            var anmData = new List<MaidAnimationSet>();
            var dic = playData[slotNo];
            foreach (var key in dic.Keys.ToList())
            {
                var data = dic[key];
                var isLast = ChangeIndex(ref data);

                if (maid != null)
                {
                    UpdateMaidBone(maid, key, SelectedFrame, isLast, ref data);
                }
                else
                {
                    var motion = data.motion[data.listIndex];
                    data.lerpFrame = CalcLerp(SelectedFrame, isLast, motion, data.lerpFrame);

                    var anm = new MaidAnimationSet();
                    anm.boneName = key;
                    anm.localRotation = GetEasingRotation(data.lerpFrame, motion.easing, motion.transform.stRot, motion.transform.edRot);
                    if (key == MyConst.BONE_ALL)
                    {
                        var x = GetEasingPosition(data.lerpFrame, motion.easing, motion.transform.stPos.x, motion.transform.edPos.x);
                        var y = GetEasingPosition(data.lerpFrame, motion.easing, motion.transform.stPos.y, motion.transform.edPos.y);
                        var z = GetEasingPosition(data.lerpFrame, motion.easing, motion.transform.stPos.z, motion.transform.edPos.z);
                        anm.localPosition = new Vector3(x, y, z);
                    }
                    anmData.Add(anm);
                }
                dic[key] = data;
            }
            playData[slotNo] = dic;
            return anmData;
        }

        /// <summary>
        /// アニメーションファイル値作成
        /// </summary>
        private byte[] CreateBinaryData(Dictionary<string, List<BoneCache>> cacheDic)
        {
            var memoryStream = new MemoryStream();
            var binaryWriter = new BinaryWriter(memoryStream);
            binaryWriter.Write(MyConst.HEADER_ANIMATION_NAME);
            binaryWriter.Write(MyConst.HEADER_ANIMATION_VERSION);

            foreach (var pair in cacheDic)
            {
                binaryWriter.Write((byte)1);
                byte[] bonePath = Encoding.UTF8.GetBytes(pair.Key);
                if (bonePath.Length < 128)
                {
                    binaryWriter.Write((byte)bonePath.Length);
                }
                else
                {
                    binaryWriter.Write(new byte[] { (byte)(bonePath.Length % 128 + 128), (byte)(bonePath.Length / 128) });
                }
                binaryWriter.Write(bonePath);
                var values = pair.Value;
                
                for (int i = 0; i < values[0].array.Length; i++)
                {
                    binaryWriter.Write((byte)(100 + i));
                    binaryWriter.Write(values.Count());

                    foreach (var data in values)
                    {
                        binaryWriter.Write(data.time);
                        binaryWriter.Write(data.array[i]);
                        binaryWriter.Write(0);
                        binaryWriter.Write(0);
                    }
                }

                /*
                for (int i = 0; i < values[0].array.Length; i++)
                {
                    binaryWriter.Write((byte)(100 + i));
                    binaryWriter.Write(values.Count());


                    for (int j = 0; j < values.Count(); j++)
                    {
                        var x = values[j].time;
                        var y = values[j].array[i];
                        var join_rad = 0f;

                        if (1 < values.Count())
                        {
                            var prev_x = 0f;
                            var prev_y = 0f;
                            var next_x = 0f;
                            var next_y = 0f;

                            if (j == 0)
                            {
                                prev_x = x - (values[j + 1].time - x);
                                prev_y = y - (values[j + 1].array[i] - y);
                                next_x = values[j + 1].time;
                                next_y = values[j + 1].array[i];
                            }
                            else if (j == values.Count() - 1)
                            {
                                prev_x = values[j - 1].time;
                                prev_y = values[j - 1].array[i];
                                next_x = x + (x - values[j - 1].time);
                                next_y = y + (y - values[j - 1].array[i]);
                            }
                            else
                            {
                                prev_x = values[j - 1].time;
                                prev_y = values[j - 1].array[i];
                                next_x = values[j + 1].time;
                                next_y = values[j + 1].array[i];
                            }

                            var prev_rad = (prev_y - y) / (prev_x - x);
                            var next_rad = (next_y - y) / (next_x - x);
                            join_rad = (prev_rad + next_rad) / 2;

                        }
                        binaryWriter.Write(x);
                        binaryWriter.Write(y);
                        binaryWriter.Write(join_rad);
                        binaryWriter.Write(join_rad);
                    }
                }
                */
            }

            binaryWriter.Write(0);
            binaryWriter.Close();
            memoryStream.Close();
            var anmBinary = memoryStream.ToArray();
            memoryStream.Dispose();
            return anmBinary;
        }

    }

    /// <summary>
    /// タイムライン表情モーション処理管理（カスタム）
    /// </summary>
    public class TimelineMorphManager : Timeline
    {
        public int SelectedFacial { get; set; }
        public string MouthText { get; set; }

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public TimelineMorphManager(bool isSong) : base(isSong)
        {
            Initialize(true);
            MouthText = "";
        }

        /// <summary>
        /// 表情データファイル読み込み
        /// </summary>
        public void ReadMorphData(int slotNo, string fileName)
        {
            var subFoleder = fileName.StartsWith(MyConst.FOLDER_TIMELINE) ? "" : MyConst.FOLDER_TIMELINE;
            var filePath = new FileReader().GetFilePath(fileName, subFoleder);
            if (string.IsNullOrEmpty(filePath))
            {
                return;
            }
            var morph = new FileReader().ReadTimelineMorphFileData(filePath);
            if (!MyHelper.CheckNull(morph))
            {
                var dic = new Dictionary<int, List<MotionTimeLineSet>>();
                foreach (var m in morph)
                {
                    if (!dic.ContainsKey(m.frame))
                    {
                        dic[m.frame] = new List<MotionTimeLineSet>();
                    }
                    dic[m.frame].Add(m);
                }
                if (IsSong())
                {
                    motionData[slotNo] = dic;
                    SetPlayMorphData(slotNo);
                }
                else
                {
                    SetDefaultMorphData(slotNo, dic);
                }
            }
        }

        /// <summary>
        /// 表情データファイル書き込み
        /// </summary>
        public void WriteMorphData(int slotNo, string fileName, bool isAllMaids)
        {
            if (!MyHelper.CheckNull(motionData) && !string.IsNullOrEmpty(fileName))
            {
                if (motionData.ContainsKey(slotNo))
                {
                    var data = new List<MotionTimeLineSet>();
                    var frames = motionData[slotNo].Keys.OrderBy(d => d);
                    foreach (var frame in frames)
                    {
                        data.AddRange(motionData[slotNo][frame]);
                    }
                    if (!MyHelper.CheckNull(data))
                    {
                        fileName = (isAllMaids ? slotNo.ToString() + "_" : "") + fileName;
                        new FileWriter().WriteMaidMorph(data, fileName);
                    }
                }
            }
        }

        /// <summary>
        /// 表情データ更新
        /// </summary>
        public void UpdateMorphData(MotionTimeLineSet morph, int slotNo, string name)
        {
            var data = motionData[slotNo][SelectedFrame].FirstOrDefault(d => d.name == name);
            if (data.morphValue != morph.morphValue)
            {
                motionData[slotNo][SelectedFrame].RemoveAll(d => d.name == name);
                motionData[slotNo][SelectedFrame].Add(morph);
                SetPlayMorphData(slotNo);
            }
        }

        /// <summary>
        /// カスタム表情データ更新
        /// </summary>
        public void SetCustomFacialData(string label, int slotNo)
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_CUSTOM_FACE, "");
            if (!string.IsNullOrEmpty(path))
            {
                var morph = fReader.ReadMaidCustomMorphData(path, label, SelectedFrame);
                if (!MyHelper.CheckNull(morph))
                {
                    motionData[slotNo][SelectedFrame] = morph;
                    SetPlayMorphData(slotNo);
                }
            }
        }

        /// <summary>
        /// 再生時表情データ更新
        /// </summary>
        public void UpdatePlayMorph(Maid maid, int slotNo, TimeLinePlaySet tlPlaySet)
        {
            if (!playData.ContainsKey(slotNo))
            {
                return;
            }
            var isContinue = false;
            var dic = playData[slotNo];
            var frame = SetFromFrame(slotNo, tlPlaySet);
            var morph = new Dictionary<string, float>();
            foreach (var key in dic.Keys.ToList())
            {
                var data = dic[key];
                if (frame != MyConst.PRE_INDEX)
                {
                    for (int i = data.listIndex; i < data.motion.Count(); i++)
                    {
                        if (playTimeData[slotNo] <= data.motion[data.listIndex].edFrame * MyConst.FRAME_CONVERSION_RATIO)
                        {
                            break;
                        }
                        data.listIndex++;
                    }
                    if (data.motion.Count() <= data.listIndex)
                    {
                        data.listIndex = MyConst.PRE_INDEX;
                    }
                }
                if (data.listIndex == MyConst.PRE_INDEX)
                {
                    continue;
                }
                isContinue = true;
                if (playTimeData[slotNo] <= data.motion[data.listIndex].edFrame * MyConst.FRAME_CONVERSION_RATIO)
                {
                    var d = data.motion[data.listIndex];
                    data.lerpFrame = CalcLerp(frame, d, false, data.lerpFrame);
                    morph[key] = Lerp(d.startValue, d.endValue, data.lerpFrame, key);
                }
                else
                {
                    data.lerpFrame = 0;
                    data.listIndex++;
                    if (data.motion.Count() <= data.listIndex)
                    {
                        data.listIndex = MyConst.PRE_INDEX;
                    }
                }
                dic[key] = data;
            }
            SetMorphValue(maid, morph);

            if (!isContinue)
            {
                if (tlPlaySet.isLoop && !IsSong())
                {
                    SetPlayingMorph(maid, slotNo, tlPlaySet.isLoop);
                    playTimeData[slotNo] += Time.deltaTime;
                }
            }
            else
            {
                playData[slotNo] = dic;
                playTimeData[slotNo] += Time.deltaTime;
            }
        }

        /// <summary>
        /// フレーム移動時表情データ更新(Lastupdate用)
        /// </summary>
        public void UpdateFrameMorph(Maid maid, int slotNo, bool isUpdateDic)
        {
            if (!playData.ContainsKey(slotNo))
            {
                return;
            }
            var morph = new Dictionary<string, float>();
            var dic = playData[slotNo];
            foreach (var key in dic.Keys.ToList())
            {
                var data = dic[key];
                var isLast = ChangeIndex(ref data);
                var d = data.motion[data.listIndex];
                data.lerpFrame = CalcLerp(SelectedFrame, d, isLast, data.lerpFrame);
                morph[key] = Lerp(d.startValue, d.endValue, data.lerpFrame, key);
                dic[key] = data;
            }
            playData[slotNo] = dic;
            SetMorphValue(maid, morph);
            if (isUpdateDic)
            {
                SetItemDic(slotNo, MyConst.ALL_FACIAL_MORPH.Keys.ToArray());
            }
        }

        /// <summary>
        /// 再生用表情データ設定
        /// </summary>
        public void SetPlayingMorph(Maid maid, int slotNo, bool isLoop)
        {
            SelectedFrame = 0;
            playTimeData[slotNo] = 0f;
            if (isLoop)
            {
                ResetLoopData(slotNo);
            }
            else
            {
                SetPlayMorphData(slotNo);
            }
            if (playData.ContainsKey(slotNo))
            {
                SetZeroMorph(maid, slotNo);
            }
        }

        /// <summary>
        /// タイムライン新規フレーム作成
        /// </summary>
        public void CreateNewFrame(Maid maid, int slotNo, int frame)
        {
            if (CheckKeyFrame(slotNo, frame))
            {
                var morph = new List<MotionTimeLineSet>();
                foreach (var pair in ItemNewFrameDic)
                {
                    if (pair.Value)
                    {
                        morph.Add(GetCurrentMorph(maid, frame, pair.Key));
                    }
                }
                if (!MyHelper.CheckNull(morph))
                {
                    motionData[slotNo][frame] = morph;
                    SetSelectedItemName(slotNo, frame);
                    SetPlayMorphData(slotNo);
                }
            }
        }

        /// <summary>
        /// タイムラインへアイテム追加
        /// </summary>
        public void AddTimeLineItem(Maid maid, int slotNo)
        {
            var isChecked = false;
            foreach (var pair in ItemAddtionDic)
            {
                if (pair.Value && !motionData[slotNo][SelectedFrame].Exists(d => d.name == pair.Key))
                {
                    motionData[slotNo][SelectedFrame].Add(GetCurrentMorph(maid, SelectedFrame, pair.Key));
                    isChecked = true;
                }
            }
            if (isChecked)
            {
                SetPlayMorphData(slotNo);
            }
        }

        /// <summary>
        /// タイムラインからアイテム削除
        /// </summary>
        public void DeleteTimeLineItem(int slotNo)
        {
            var isChecked = false;
            foreach (var pair in ItemDeletionDic)
            {
                if (pair.Value)
                {
                    motionData[slotNo][SelectedFrame].RemoveAll(d => d.name == pair.Key);
                    isChecked = true;
                }
            }
            if (isChecked)
            {
                if (MyHelper.CheckNull(motionData[slotNo][SelectedFrame]))
                {
                    motionData[slotNo].Remove(SelectedFrame);
                }
                SetPlayMorphData(slotNo);
            }
        }

        /// <summary>
        /// フレームコピー
        /// </summary>
        public void CopySelectedFrame(int slotNo, int copyFrame)
        {
            if (CopyFrame(slotNo, copyFrame))
            {
                SetPlayMorphData(slotNo);
            }
        }

        /// <summary>
        /// フレーム削除
        /// </summary>
        public void DeleteSelectedFrame(int slotNo)
        {
            if (DeleteFrame(slotNo, SelectedName))
            {
                SetPlayMorphData(slotNo);
            }
        }

        /// <summary>
        /// 初期表情値設定
        /// </summary>
        public void SetDefaultMorph(int slotNo)
        {
            var dic = new Dictionary<int, List<MotionTimeLineSet>>();
            SetDefaultMorphData(slotNo, dic);
        }

        /// <summary>
        /// メイド変更時スロット番号保持
        /// </summary>
        public void ChangeMaidSlotNo(Maid maid, int slotNo)
        {
            if (SaveMaidSlotNo(slotNo))
            {
                UpdateFrameMorph(maid, slotNo, true);
            }
        }

        /// <summary>
        /// 初期値設定
        /// </summary>
        private void SetDefaultMorphData(int slotNo, Dictionary<int, List<MotionTimeLineSet>> dic)
        {
            SelectedFrame = 0;
            if (MyHelper.CheckNull(dic))
            {
                dic = new Dictionary<int, List<MotionTimeLineSet>>();
                dic[SelectedFrame] = new List<MotionTimeLineSet>();
                foreach (var key in MyConst.ALL_FACIAL_MORPH.Keys)
                {
                    var data = new MotionTimeLineSet();
                    data.name = key;
                    if (key == MyConst.FACE_MOUTH_UP)
                    {
                        data.morphValue = MyConst.MOUTH_UP;
                    }
                    dic[SelectedFrame].Add(data);
                }
            }
            motionData[slotNo] = dic;
            SetPlayMorphData(slotNo);
        }

        /// <summary>
        /// 線形補間値計算
        /// </summary>
        private float CalcLerp(int frame, MotionPlayLoopSet data, bool isLast, float lerpFrame)
        {
            if (data.deltaFrame == 0)
            {
                lerpFrame = 0;
            }
            else if (isLast)
            {
                lerpFrame = 1;
            }
            else if (frame == MyConst.PRE_INDEX)
            {
                lerpFrame += Mathf.Clamp01(1 / (float)data.deltaFrame * Time.deltaTime * MyConst.BASE_FRAME);
            }
            else
            {
                lerpFrame = (frame - data.stFrame) / (float)data.deltaFrame;
            }
            return lerpFrame;
        }

        /// <summary>
        /// 再生用表情値設定
        /// </summary>
        private void SetPlayMorphData(int slotNo)
        {
            if (MyHelper.CheckNull(motionData))
            {
                return;
            }
            if (!motionData.ContainsKey(slotNo))
            {
                return;
            }
            var dic = new Dictionary<string, MotionPlaySet>();
            foreach (var key in MyConst.ALL_FACIAL_MORPH.Keys)
            {
                var mm = new MotionPlaySet();
                mm.motion = new List<MotionPlayLoopSet>();
                dic[key] = mm;
            }

            foreach (var frame in motionData[slotNo].Keys.OrderBy(d => d))
            {
                foreach (var d in motionData[slotNo][frame])
                {
                    var loop = new MotionPlayLoopSet();
                    loop.stFrame = d.frame;
                    loop.edFrame = loop.stFrame;
                    loop.startValue = d.morphValue;
                    loop.endValue = d.morphValue;
                    dic[d.name].motion.Add(loop);

                    if (frame != 0)
                    {
                        var idx = dic[d.name].motion.Count() - 2;
                        var m = dic[d.name].motion[idx];
                        m.edFrame = d.frame;
                        m.deltaFrame = m.edFrame - m.stFrame;
                        m.endValue = d.morphValue;
                        dic[d.name].motion[idx] = m;
                    }
                }
            }
            if (!MyHelper.CheckNull(dic))
            {
                playData[slotNo] = dic;
            }
            if (!IsSong())
            {
                SetItemDic(slotNo, MyConst.ALL_FACIAL_MORPH.Keys.ToArray());
            }
        }

        /// <summary>
        /// 0フレーム表情値設定
        /// </summar
        private void SetZeroMorph(Maid maid, int slotNo)
        {
            var frame = 0;
            var dic = new Dictionary<string, float>();
            if (motionData[slotNo].ContainsKey(frame))
            {
                foreach (var data in motionData[slotNo][frame])
                {
                    dic[data.name] = data.morphValue;
                }
            }
            SetMorphValue(maid, dic);
        }

        /// -------------------------------------------------------------------------

        /// <summary>
        /// 公式表情更新
        /// </summary>
        public void UpdateOfficialFaceData(Maid maid, int slotNo, int frame)
        {
            if (!motionData.ContainsKey(slotNo))
            {
                return;
            }
            AddMorphData(maid, slotNo, frame);
            SetPlayMorphData(slotNo);
        }

        /// <summary>
        /// 線形補間値取得
        /// </summary>
        private float Lerp(float startValue, float endValue, float lerpFrame, string morphName)
        {
            if (MyConst.FACE_OPTION_MORPH.ContainsKey(morphName))
            {
                if (lerpFrame < 0.99f)
                {
                    lerpFrame = 0f;
                }
            }
            return Mathf.Lerp(startValue, endValue, lerpFrame);
        }

        /// <summary>
        /// 表情追加更新
        /// </summary>
        private void AddMorphData(Maid maid, int slotNo, int frame)
        {
            var morph = new List<MotionTimeLineSet>();
            foreach (var morphName in MyConst.ALL_FACIAL_MORPH.Keys)
            {
                morph.Add(GetCurrentMorph(maid, frame, morphName));
            }
            motionData[slotNo][frame] = morph;
        }

        /// <summary>
        /// 現在表情取得
        /// </summary>
        private MotionTimeLineSet GetCurrentMorph(Maid maid, int frame, string morphName)
        {
            var data = new MotionTimeLineSet();
            data.frame = frame;
            data.name = morphName;
            data.morphValue = new MaidManager().GetMorphValue(maid, morphName);
            return data;
        }

        /// <summary>
        /// 表情値設定
        /// </summary>
        private void SetMorphValue(Maid maid, Dictionary<string, float> morph)
        {
            if (!MyHelper.CheckNull(morph))
            {
                new MaidManager().SetMorphValue(maid, morph);
            }
        }
    }

    /// <summary>
    /// タイムライン表情モーション処理管理（公式ダンス）
    /// </summary>
    public class TimelineFaceManager : Timeline
    {
        public int SelectedFacialIndex { get; set; }

        private readonly Dictionary<int, Dictionary<int, MotionTimeLineSet>> faceData;

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public TimelineFaceManager(bool isSong) : base(isSong)
        {
            faceData = new Dictionary<int, Dictionary<int, MotionTimeLineSet>>();
        }

        /// <summary>
        /// 表情データファイル読み込み
        /// </summary>
        public void ReadFaceData(int slotNo, string fileName, Maid maid)
        {
            var subFoleder = fileName.StartsWith(MyConst.FOLDER_TIMELINE) ? "" : MyConst.FOLDER_TIMELINE;
            var filePath = new FileReader().GetFilePath(fileName, subFoleder);
            if (string.IsNullOrEmpty(filePath))
            {
                return;
            }
            var face = new FileReader().ReadDanceFaceData(filePath);
            SetFaceData(face, slotNo, maid);
        }

        /// <summary>
        /// 表情データ設定
        /// </summary>
        public void SetFaceData(List<DanceFaceSet> face, int slotNo, Maid maid)
        {
            if (!MyHelper.CheckNull(face))
            {
                int frame;
                var dic = new Dictionary<int, MotionTimeLineSet>();
                foreach (var f in face)
                {
                    if(f.frame == MyConst.PRE_INDEX)
                    {
                        frame = MyHelper.ConvertFrame(f.time);
                    }
                    else
                    {
                        frame = f.frame;
                    }
                    var data = new MotionTimeLineSet();
                    data.frame = frame;
                    data.name = f.face;
                    data.blend = f.blend;
                    data.eyeMoveType = f.eyeMoveType;
                    dic[frame] = data;
                }
                frame = 0;
                if (!dic.ContainsKey(frame))
                {
                    var data = new MotionTimeLineSet();
                    data.frame = frame;
                    data.name = MyConst.DANCE_FACE_EYE_CLOSE;
                    data.blend = "";
                    data.eyeMoveType = Maid.EyeMoveType.目だけ向ける;
                    dic[frame] = data;
                }
                new MaidManager().UpdateFaceAnime(maid, dic[frame].name);
                faceData[slotNo] = dic;
            }
        }

        /// <summary>
        /// 表情データファイル書き込み
        /// </summary>
        public void WriteCameraData(int slotNo, string fileName)
        {
            if (MyHelper.CheckNull(faceData) || string.IsNullOrEmpty(fileName) || !ContainsSlotNo(slotNo))
            {
                return;
            }
            var data = new List<DanceFaceSet>();
            foreach (var value in faceData[slotNo].Values)
            {
                var d = new DanceFaceSet();
                d.time = value.frame * MyConst.FRAME_CONVERSION_RATIO;
                d.face = value.name;
                d.blend = value.blend;
                d.eyeMoveType = value.eyeMoveType;
                d.frame = value.frame;
                data.Add(d);
            }
            new FileWriter().WriteMaidFace(data.OrderBy(d => d.time).ToList(), fileName);
        }

        /// <summary>
        /// フレーム移動時表情データ更新
        /// </summary>
        public void UpdateFrameFace(int slotNo, Maid maid, int frame, bool isLastUpdate)
        {
            if (!ContainsSlotNo(slotNo))
            {
                return;
            }
            var time = frame * MyConst.FRAME_CONVERSION_RATIO;
            var mgr = new MaidManager();
            if (!faceData[slotNo].ContainsKey(frame))
            {
                frame = faceData[slotNo].Keys.ToList().FindAll(d => d < frame).Max();
            }
            var data = faceData[slotNo][frame];
            if (!maid.boFaceAnime)
            {
                mgr.UpdateFaceAnime(maid, data.name); 
            }
            if ((int)data.eyeMoveType != MyConst.PRE_INDEX)
            {
                mgr.SetEyeToCamera(maid, data.eyeMoveType);
            }
            data.blend = string.IsNullOrEmpty(data.blend) ? "" : data.blend;
            if (isLastUpdate)
            {
                var dicMorph = new Dictionary<string, float>();
                foreach (var pair in MyConst.FACE_OPTION_MORPH)
                {
                    if (data.blend.Contains(pair.Value.Substring(2)))
                    {
                        dicMorph[pair.Key] = 1f;
                    }
                    else
                    {
                        dicMorph[pair.Key] = 0f;
                    }
                }
                mgr.SetMorphValue(maid, dicMorph);
            }
            maid.FoceKuchipakuUpdate(time);
        }

        /// <summary>
        /// 表情データ更新
        /// </summary>
        public void UpdateFaceData(int slotNo, string face, string blend, int frame, Maid.EyeMoveType eyeMoveType)
        {
            var data = new MotionTimeLineSet();
            data.frame = frame;
            data.name = face;
            data.blend = blend;
            data.eyeMoveType = eyeMoveType;
            faceData[slotNo][frame] = data;
        }

        /// <summary>
        /// キーフレーム有無確認
        /// </summary>
        public new bool ExistsKeyFrame(int slotNo)
        {
            return faceData[slotNo].ContainsKey(SelectedFrame);
        }

        /// <summary>
        /// キーフレーム取得
        /// </summary>
        public List<int> GetFaceKeyFrame(int slotNo)
        {
            return GetTimeLineKeyFrame(faceData[slotNo].Keys.ToList());
        }

        /// <summary>
        /// タイムラインキーフレーム設定
        /// </summary>
        public new int SetTimelineSelectedKeyFrame(int slotNo,TimeLineFrameSelectType selectType)
        {
            if (selectType != TimeLineFrameSelectType.Non)
            {
                return SetTimelineKeyFrame(faceData[slotNo].Keys.ToList(), selectType, true);
            }
            return SelectedFrame;
        }

        /// <summary>
        /// タイムライン新規フレーム作成
        /// </summary>
        public void CreateNewFrame(int slotNo, int frame)
        {
            if (CheckTimeLineKeyFrame(frame, faceData[slotNo].Keys.ToList()))
            {
                UpdateFaceData(slotNo, MyConst.DEFAULT_FACE, "", frame, (Maid.EyeMoveType)MyConst.PRE_INDEX);
            }
        }

        /// <summary>
        /// フレームコピー
        /// </summary>
        public void CopySelectedFrame(int copyFrame, int slotNo)
        {
            if (CheckTimeLineKeyFrame(copyFrame, faceData[slotNo].Keys.ToList()))
            {
                var d = faceData[slotNo][SelectedFrame];
                UpdateFaceData(slotNo, d.name, d.blend, copyFrame, d.eyeMoveType);
            }
        }

        /// <summary>
        /// フレーム削除
        /// </summary>
        public void DeleteSelectedFrame(int slotNo)
        {
            if (0 < SelectedFrame && !MyHelper.CheckNull(faceData[slotNo]))
            {
                faceData[slotNo].Remove(SelectedFrame);
            }
        }

        /// <summary>
        /// 初期表情値設定
        /// </summary>
        public void SetDefaultFace(int slotNo)
        {
            faceData[slotNo] = new Dictionary<int, MotionTimeLineSet>();
            UpdateFaceData(slotNo, MyConst.DEFAULT_FACE, "", 0, (Maid.EyeMoveType)MyConst.PRE_INDEX);
        }

        /// -------------------------------------------------------------------------

        /// <summary>
        /// メイドスロット番号有無確認
        /// </summary>
        public new bool ContainsSlotNo(int slotNo)
        {
            var contains = false;
            if (!MyHelper.CheckNull(faceData))
            {
                if (faceData.ContainsKey(slotNo))
                {
                    if (!MyHelper.CheckNull(faceData[slotNo]))
                    {
                        contains = true;
                    }
                }
            }
            return contains;
        }

        /// <summary>
        /// 表情名取得
        /// </summary>
        public string GetFaceName(int slotNo)
        {
            return faceData[slotNo][SelectedFrame].name;
        }

        /// <summary>
        /// 表情オプション取得
        /// </summary>
        public string GetFaceOption(int slotNo)
        {
            return faceData[slotNo][SelectedFrame].blend;
        }

        /// <summary>
        /// メイド目線取得
        /// </summary>
        public Maid.EyeMoveType GetEyeMoveType(int slotNo)
        {
            return faceData[slotNo][SelectedFrame].eyeMoveType;
        }
    }

    /// <summary>
    /// タイムラインカメラモーション処理管理
    /// </summary>
    public class TimelineCameraManager : Timeline
    {
        private Dictionary<int, MotionTimeLineSet> cameraData;
        private new MotionPlaySet playData;

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public TimelineCameraManager(bool isSong) : base(isSong)
        {
            cameraData = new Dictionary<int, MotionTimeLineSet>();
            playData = new MotionPlaySet();
            playTimeData[MyConst.CAMERA_MAIN] = 0f;
        }

        /// <summary>
        /// カメラデータファイル読み込み
        /// </summary>
        public bool ReadCameraData(string fileName, string folderName)
        {
            var fReader = new FileReader();
            var filePath = fReader.GetFilePath(fileName, folderName);
            if (!string.IsNullOrEmpty(filePath))
            {
                cameraData = new Dictionary<int, MotionTimeLineSet>();
                var camera = fReader.ReadTimelineCameraFileData(filePath);
                foreach (var data in camera)
                {
                    cameraData[data.frame] = data;
                }
                SelectedFrame = 0;
                SetPlayCameraData();
                return true;
            }
            return false;
        }

        /// <summary>
        /// カメラデータファイル読み込み（公式ダンス）
        /// </summary>
        public bool ReadOfficialDanceCameraData(string fileName)
        {
            var fReader = new FileReader();
            var filePath = fReader.GetFilePath(fileName, MyConst.FOLDER_MOTION);
            if (string.IsNullOrEmpty(filePath))
            {
                return false;
            }
            var data = fReader.ReadCameraMotionData(filePath, 0f, false);
            cameraData = new Dictionary<int, MotionTimeLineSet>();
            var frame = 0;
            var pos = Vector3.zero;
            var rot = Vector3.zero;
            foreach (var d in data)
            {
                var c = new MotionTimeLineSet();
                if (d.stTime == 0 || d.transform.stPos != pos || d.transform.stRot != rot)
                {
                    if (d.stTime != 0)
                    {
                        c = cameraData[frame];
                        c.frame--;
                        cameraData[c.frame] = c;
                        c = new MotionTimeLineSet();
                    }
                    c.frame = MyHelper.ConvertFrame(d.stTime);
                    c.position = d.transform.stPos;
                    c.rotation = d.transform.stRot;
                    c.easing = d.easingType;
                    c.distance = d.transform.stSca.x;
                    c.viewAngle = d.transform.stSca.y;
                    cameraData[c.frame] = c;
                }
                c = new MotionTimeLineSet();
                c.frame = MyHelper.ConvertFrame(d.edTime);
                c.position = d.transform.edPos;
                c.rotation = d.transform.edRot;
                c.easing = d.easingType;
                c.distance = d.transform.edSca.x;
                c.viewAngle = d.transform.edSca.y;
                if (cameraData.ContainsKey(c.frame))
                {
                    c.frame++;
                }
                cameraData[c.frame] = c;

                frame = c.frame;
                pos = c.position;
                rot = c.rotation;
            }
            SelectedFrame = 0;
            SetPlayCameraData();
            return true;
        }

        /// <summary>
        /// カメラデータファイル書き込み
        /// </summary>
        public void WriteCameraData(string fileName)
        {
            if (!MyHelper.CheckNull(cameraData) && !string.IsNullOrEmpty(fileName))
            {
                var data = new List<MotionTimeLineSet>();
                foreach (var value in cameraData.Values)
                {
                    data.Add(value);
                }
                new FileWriter().WriteMaidCamera(data.OrderBy(d => d.frame).ToList(), fileName);
            }
        }

        /// <summary>
        /// カメラデータ更新
        /// </summary>
        public bool UpdateCameraData(MotionTimeLineSet camera)
        {
            var data = cameraData[SelectedFrame];
            if (data.position != camera.position ||
                data.rotation != camera.rotation ||
                data.distance != camera.distance ||
                data.viewAngle != camera.viewAngle ||
                data.easing != camera.easing)
            {
                cameraData[SelectedFrame] = camera;
                SetPlayCameraData();
                return true;
            }
            return false;
        }

        /// <summary>
        /// 再生時カメラデータ更新
        /// </summary>
        public void UpdatePlayCamera(TimeLinePlaySet tlPlaySet, bool isAdjusted)
        {
            if (playData.listIndex == MyConst.PRE_INDEX)
            {
                return;
            }
            if (playData.motion.Count() <= playData.listIndex)
            {
                SetPlayingCamera(tlPlaySet.isLoop);
                if (!tlPlaySet.isLoop)
                {
                    playData.listIndex = MyConst.PRE_INDEX;
                }
            }
            else
            {
                if (isAdjusted)
                {
                    playData.listIndex = 0;
                }
                var slotNo = MyConst.CAMERA_MAIN;
                var frame = SetFromFrame(slotNo, tlPlaySet);
                while (playData.listIndex < playData.motion.Count())
                {
                    if (playTimeData[slotNo] <= playData.motion[playData.listIndex].edFrame * MyConst.FRAME_CONVERSION_RATIO)
                    {
                        UpdateCamera(frame, false);
                        break;
                    }
                    else
                    {
                        playData.lerpFrame = 0;
                        playData.listIndex++;
                    }
                }
                playTimeData[slotNo] += Time.deltaTime;
            }
        }

        /// <summary>
        /// フレーム移動時カメラデータ更新
        /// </summary>
        public void UpdateFrameCamera()
        {
            playData.listIndex = MyConst.PRE_INDEX;
            for (int i = 0; i < playData.motion.Count(); i++)
            {
                if (playData.motion[i].stFrame <= SelectedFrame && SelectedFrame <= playData.motion[i].edFrame)
                {
                    playData.listIndex = i;
                    break;
                }
            }
            var isLast = false;
            if (playData.listIndex == MyConst.PRE_INDEX)
            {
                playData.listIndex = playData.motion.Count() - 1;
                isLast = true;
            }
            UpdateCamera(SelectedFrame, isLast);
        }

        /// <summary>
        /// 再生用カメラデータ設定
        /// </summary>
        public void SetPlayingCamera(bool isLoop)
        {
            SelectedFrame = 0;
            playTimeData[MyConst.CAMERA_MAIN] = 0f;
            if (isLoop)
            {
                playData.listIndex = 0;
                playData.lerpFrame = 0f;
            }
            else
            {
                SetPlayCameraData();
            }
        }

        /// <summary>
        /// フレームコピー
        /// </summary>
        public void CopySelectedFrame(int copyFrame)
        {
            if (CheckTimeLineKeyFrame(copyFrame, cameraData.Keys.ToList()))
            {
                var data = new MotionTimeLineSet();
                var d = cameraData[SelectedFrame];
                data.frame = copyFrame;
                data.position = d.position;
                data.rotation = d.rotation;
                data.distance = d.distance;
                data.viewAngle = d.viewAngle;
                data.easing = d.easing;
                cameraData[copyFrame] = data;
                SetPlayCameraData();
            }
        }

        /// <summary>
        /// フレーム削除
        /// </summary>
        public void DeleteSelectedFrame()
        {
            if (0 < SelectedFrame && !MyHelper.CheckNull(cameraData))
            {
                cameraData.Remove(SelectedFrame);
                SetPlayCameraData();
            }
        }

        /// <summary>
        /// 初期カメラ値設定
        /// </summary>
        public void SetDefaultCamera()
        {
            SelectedFrame = 0;
            var cameraMgr = new CameraManager();
            var data = new MotionTimeLineSet();
            data.position = cameraMgr.GetPositionResetValue();
            data.rotation = cameraMgr.GetRotationResetValue();
            data.viewAngle = MyConst.ZOOM_DEFAULT;
            cameraData = new Dictionary<int, MotionTimeLineSet>();
            cameraData[data.frame] = data;
            SetPlayCameraData();
        }

        /// <summary>
        /// キーフレーム有無確認
        /// </summary>
        public new bool ExistsKeyFrame(int frame)
        {
            return cameraData.ContainsKey(frame);
        }

        /// <summary>
        /// キーフレーム取得
        /// </summary>
        public List<int> GetCameraKeyFrame()
        {
            return GetTimeLineKeyFrame(cameraData.Keys.ToList());
        }

        /// <summary>
        /// タイムラインキーフレーム設定
        /// </summary>
        public int SetTimelineSelectedKeyFrame(TimeLineFrameSelectType selectType)
        {
            if (selectType != TimeLineFrameSelectType.Non)
            {
                return SetTimelineKeyFrame(cameraData.Keys.ToList(), selectType, true);
            }
            return SelectedFrame;
        }

        /// <summary>
        /// カメラ値更新
        /// </summary>
        private void UpdateCamera(int frame, bool isLast)
        {
            var camera = playData.motion[playData.listIndex];
            if (camera.deltaFrame == 0)
            {
                playData.lerpFrame = 0;
            }
            else if (isLast)
            {
                playData.lerpFrame = 1;
            }
            else if (frame == MyConst.PRE_INDEX)
            {
                playData.lerpFrame += Mathf.Clamp01(1 / (float)camera.deltaFrame * Time.deltaTime * MyConst.BASE_FRAME);
            }
            else
            {
                playData.lerpFrame = (frame - camera.stFrame) / (float)camera.deltaFrame;
            }
        }

        /// <summary>
        /// 再生用カメラ値設定
        /// </summary>
        private void SetPlayCameraData()
        {
            if (!MyHelper.CheckNull(cameraData))
            {
                playData = new MotionPlaySet();
                playData.motion = new List<MotionPlayLoopSet>();
                foreach (var d in cameraData.OrderBy(d => d.Key))
                {
                    var loop = new MotionPlayLoopSet();
                    loop.stFrame = d.Value.frame;
                    loop.edFrame = d.Value.frame;
                    loop.transform.stPos = d.Value.position;
                    loop.transform.edPos = d.Value.position;
                    loop.transform.stRot = d.Value.rotation;
                    loop.transform.edRot = d.Value.rotation;
                    loop.transform.stSca = new Vector3(d.Value.distance, d.Value.viewAngle, 0f);
                    loop.transform.edSca = loop.transform.stSca;
                    playData.motion.Add(loop);

                    if (d.Value.frame != 0)
                    {
                        var idx = playData.motion.Count() - 2;
                        var m = playData.motion[idx];
                        if (d.Value.frame - m.stFrame == 1)
                        {
                            var frame = m.stFrame;
                            playData.motion.Remove(m);
                            m = playData.motion[idx];
                            m.stFrame = frame;
                            m.edFrame = frame;
                        }
                        else
                        {
                            m.edFrame = d.Value.frame;
                            m.deltaFrame = m.edFrame - m.stFrame;
                            m.transform.edPos = d.Value.position;
                            m.transform.edRot = d.Value.rotation;
                            m.transform.edSca = new Vector3(d.Value.distance, d.Value.viewAngle, 0f);
                            m.easing = d.Value.easing;
                        }
                        playData.motion[idx] = m;
                    }
                }
            }
        }

        /// -------------------------------------------------------------------------

        /// <summary>
        /// タイムラインカメラデータ取得
        /// </summary>
        public MotionTimeLineSet GetCameraTimeLineData()
        {
            return cameraData[SelectedFrame];
        }

        /// <summary>
        /// 現在キーフレーム座標取得
        /// </summary>
        public void GetSelectedFrameTransform(ref Vector3 position, ref Vector3 rotation, ref float viewAngle)
        {
            position = GetSelectedFramePosition();
            rotation = GetSelectedFrameRotation();
            var distance = GetDistance();
            position = AdjustedCameraosition(position, rotation, distance);
            viewAngle = GetViewAngle();
        }

        /// <summary>
        /// 新規キーフレーム作成
        /// </summary>
        public void CreateNewFrame(Vector3 position, Vector3 rotation)
        {
            if (CheckTimeLineKeyFrame(SelectedFrame, cameraData.Keys.ToList()))
            {
                var data = new MotionTimeLineSet();
                data.frame = SelectedFrame;
                data.position = position;
                data.rotation = rotation;
                data.viewAngle = MyConst.ZOOM_DEFAULT;
                cameraData[SelectedFrame] = data;
                SetPlayCameraData();
            }
        }

        /// <summary>
        /// 歌モードタイム設定
        /// </summary>
        public bool SetSongPlatyTime(float time)
        {
            var isAdjusted = 1 < Mathf.Abs(playTimeData[MyConst.CAMERA_MAIN] - time);
            playTimeData[MyConst.CAMERA_MAIN] = time;
            return isAdjusted;
        }

        /// <summary>
        /// 現在キーフレーム位置取得
        /// </summary>
        private Vector3 GetSelectedFramePosition()
        {
            var camera = GetCurrentPlayData();
            var x = GetEasingPosition(playData.lerpFrame, camera.easing, camera.transform.stPos.x, camera.transform.edPos.x);
            var y = GetEasingPosition(playData.lerpFrame, camera.easing, camera.transform.stPos.y, camera.transform.edPos.y);
            var z = GetEasingPosition(playData.lerpFrame, camera.easing, camera.transform.stPos.z, camera.transform.edPos.z);
            return new Vector3(x, y, z);
        }

        /// <summary>
        /// 現在キーフレーム回転取得
        /// </summary>
        private Vector3 GetSelectedFrameRotation()
        {
            var camera = GetCurrentPlayData();
            return GetEasingRotation(playData.lerpFrame, camera.easing, camera.transform.stRot, camera.transform.edRot).eulerAngles;
        }

        /// <summary>
        /// 距離取得
        /// </summary>
        private float GetDistance()
        {
            var camera = GetCurrentPlayData();
            return GetEasingPosition(playData.lerpFrame, camera.easing, camera.transform.stSca.x, camera.transform.edSca.x);
        }

        /// <summary>
        /// 視野角取得
        /// </summary>
        private float GetViewAngle()
        {
            var camera = GetCurrentPlayData();
            return GetEasingPosition(playData.lerpFrame, camera.easing, camera.transform.stSca.y, camera.transform.edSca.y);
        }

        /// <summary>
        /// 現在カメラデータ取得取得
        /// </summary>
        private MotionPlayLoopSet GetCurrentPlayData()
        {
            var index = playData.listIndex;
            if (playData.listIndex == MyConst.PRE_INDEX || playData.motion.Count() <= playData.listIndex)
            {
                index = playData.motion.Count() - 1;
            }
            return playData.motion[index];
        }

        /// <summary>
        /// 公式ダンスカメラモーション変換
        /// </summary>
        public List<CameraTransformSet> ConvertDanceCameraData(List<MotionTimeLineSet> motion)
        {
            var frame = 0;
            var camera = new List<CameraTransformSet>();
            foreach (var d in motion.OrderBy(d => d.frame))
            {
                var data = new CameraTransformSet();
                data.stTime = d.frame * MyConst.FRAME_CONVERSION_RATIO;
                data.edTime = data.stTime;
                data.transform.stPos = d.position;
                data.transform.edPos = d.position;
                data.transform.stRot = d.rotation;
                data.transform.edRot = d.rotation;
                data.transform.stSca = new Vector3(d.distance, d.viewAngle, 0f);
                data.transform.edSca = data.transform.stSca;
                camera.Add(data);

                if (d.frame != 0)
                {
                    var idx = camera.Count() - 2;
                    var c = camera[idx];
                    if (d.frame - frame == 1)
                    {
                        camera.Remove(c);
                        c = camera[idx];
                        c.stTime = frame * MyConst.FRAME_CONVERSION_RATIO;
                        c.edTime = c.stTime;
                    }
                    else
                    {
                        c.edTime = d.frame * MyConst.FRAME_CONVERSION_RATIO;
                        c.deltaTime = c.edTime - c.stTime;
                        c.transform.edPos = d.position;
                        c.transform.edRot = d.rotation;
                        c.transform.edSca = new Vector3(d.distance, d.viewAngle, 0f);
                        c.easingType = d.easing;
                    }
                    camera[idx] = c;
                }
                frame = d.frame;
            }
            return camera;
        }

    }

    /// <summary>
    /// 補完カーブ処理管理
    /// https://qiita.com/pixelflag/items/e5ddf0160781170b671b
    /// https://github.com/pixelflag/EasingTest
    /// </summary>
    public class TimelineMotionEasing
    {
        public float MotionEasing(float t, EasingType tyep)
        {
            var min = 0f;
            var max = 1f;
            var ration = min;
            var totaltime = max;

            switch (tyep)
            {
                case EasingType.Linear:
                    ration = Linear(t, totaltime, min, max);
                    break;
                case EasingType.SineIn:
                    ration = SineIn(t, totaltime, min, max);
                    break;
                case EasingType.SineOut:
                    ration = SineOut(t, totaltime, min, max);
                    break;
                case EasingType.SineInOut:
                    ration = SineInOut(t, totaltime, min, max);
                    break;
                case EasingType.QuadIn:
                    ration = QuadIn(t, totaltime, min, max);
                    break;
                case EasingType.QuadOut:
                    ration = QuadOut(t, totaltime, min, max);
                    break;
                case EasingType.QuadInOut:
                    ration = QuadInOut(t, totaltime, min, max);
                    break;
                case EasingType.CubicIn:
                    ration = CubicIn(t, totaltime, min, max);
                    break;
                case EasingType.CubicOut:
                    ration = CubicOut(t, totaltime, min, max);
                    break;
                case EasingType.CubicInOut:
                    ration = CubicInOut(t, totaltime, min, max);
                    break;
                case EasingType.QuartIn:
                    ration = QuartIn(t, totaltime, min, max);
                    break;
                case EasingType.QuartOut:
                    ration = QuartOut(t, totaltime, min, max);
                    break;
                case EasingType.QuartInOut:
                    ration = QuartInOut(t, totaltime, min, max);
                    break;
                case EasingType.QuintIn:
                    ration = QuintIn(t, totaltime, min, max);
                    break;
                case EasingType.QuintOut:
                    ration = QuintOut(t, totaltime, min, max);
                    break;
                case EasingType.QuintInOut:
                    ration = QuintInOut(t, totaltime, min, max);
                    break;
                case EasingType.ExpIn:
                    ration = ExpIn(t, totaltime, min, max);
                    break;
                case EasingType.ExpOut:
                    ration = ExpOut(t, totaltime, min, max);
                    break;
                case EasingType.ExpInOut:
                    ration = ExpInOut(t, totaltime, min, max);
                    break;
                case EasingType.CircIn:
                    //ration = CircIn(t, totaltime, min, max);
                    break;
                case EasingType.CircOut:
                    ration = CircOut(t, totaltime, min, max);
                    break;
                case EasingType.CircInOut:
                    ration = CircInOut(t, totaltime, min, max);
                    break;
            }
            return Mathf.Clamp01(ration);
        }

        private float SineIn(float t, float totaltime, float min, float max)
        {
            max -= min;
            return -max * Mathf.Cos(t * (Mathf.PI * 90f / 180f) / totaltime) + max + min;
        }

        private float SineOut(float t, float totaltime, float min, float max)
        {
            max -= min;
            return max * Mathf.Sin(t * (Mathf.PI * 90f / 180f) / totaltime) + min;
        }

        private float SineInOut(float t, float totaltime, float min, float max)
        {
            max -= min;
            return -max / 2f * (Mathf.Cos(t * Mathf.PI / totaltime) - 1f) + min;
        }

        private float QuadIn(float t, float totaltime, float min, float max)
        {
            max -= min;
            t /= totaltime;
            return max * t * t + min;
        }

        private float QuadOut(float t, float totaltime, float min, float max)
        {
            max -= min;
            t /= totaltime;
            return -max * t * (t - 2f) + min;
        }

        private float QuadInOut(float t, float totaltime, float min, float max)
        {
            max -= min;
            t /= totaltime / 2f;
            if (t < 1) return max / 2 * t * t + min;

            t -= 1;
            return -max / 2f * (t * (t - 2f) - 1f) + min;
        }

        private float CubicIn(float t, float totaltime, float min, float max)
        {
            max -= min;
            t /= totaltime;
            return max * t * t * t + min;
        }

        private float CubicOut(float t, float totaltime, float min, float max)
        {
            max -= min;
            t = t / totaltime - 1f;
            return max * (t * t * t + 1) + min;
        }

        private float CubicInOut(float t, float totaltime, float min, float max)
        {
            max -= min;
            t /= totaltime / 2f;
            if (t < 1) return max / 2f * t * t * t + min;

            t -= 2f;
            return max / 2f * (t * t * t + 2f) + min;
        }

        private float QuartIn(float t, float totaltime, float min, float max)
        {
            max -= min;
            t /= totaltime;
            return max * t * t * t * t + min;
        }

        private float QuartOut(float t, float totaltime, float min, float max)
        {
            max -= min;
            t = t / totaltime - 1f;
            return -max * (t * t * t * t - 1f) + min;
        }

        private float QuartInOut(float t, float totaltime, float min, float max)
        {
            max -= min;
            t /= totaltime / 2f;
            if (t < 1) return max / 2f * t * t * t * t + min;

            t -= 2f;
            return -max / 2f * (t * t * t * t - 2f) + min;
        }

        private float QuintIn(float t, float totaltime, float min, float max)
        {
            max -= min;
            t /= totaltime;
            return max * t * t * t * t * t + min;
        }

        private float QuintOut(float t, float totaltime, float min, float max)
        {
            max -= min;
            t = t / totaltime - 1f;
            return max * (t * t * t * t * t + 1) + min;
        }

        private float QuintInOut(float t, float totaltime, float min, float max)
        {
            max -= min;
            t /= totaltime / 2f;
            if (t < 1) return max / 2f * t * t * t * t * t + min;

            t -= 2f;
            return max / 2f * (t * t * t * t * t + 2f) + min;
        }

        private float ExpIn(float t, float totaltime, float min, float max)
        {
            max -= min;
            return t == 0.0 ? min : max * Mathf.Pow(2f, 10f * (t / totaltime - 1f)) + min;
        }

        private float ExpOut(float t, float totaltime, float min, float max)
        {
            max -= min;
            return t == totaltime ? max + min : max * (-Mathf.Pow(2f, -10f * t / totaltime) + 1f) + min;
        }

        private float ExpInOut(float t, float totaltime, float min, float max)
        {
            if (t == 0.0f) return min;
            if (t == totaltime) return max;
            max -= min;
            t /= totaltime / 2f;

            if (t < 1) return max / 2 * Mathf.Pow(2f, 10f * (t - 1)) + min;

            t -= 1f;
            return max / 2f * (-Mathf.Pow(2f, -10f * t) + 2f) + min;

        }

        /*
        private float CircIn(float t, float totaltime, float min, float max)
        {
            max -= min;
            t /= totaltime;
            return -max * (Mathf.Sqrt(1f - t * t) - 1f) + min;
        }
        */

        private float CircOut(float t, float totaltime, float min, float max)
        {
            max -= min;
            t = t / totaltime - 1f;
            return max * Mathf.Sqrt(1f - t * t) + min;
        }

        private float CircInOut(float t, float totaltime, float min, float max)
        {
            max -= min;
            t /= totaltime / 2f;
            if (t < 1f) return -max / 2f * (Mathf.Sqrt(1f - t * t) - 1f) + min;

            t -= 2f;
            return max / 2f * (Mathf.Sqrt(1f - t * t) + 1f) + min;
        }

        private float Linear(float t, float totaltime, float min, float max)
        {
            return (max - min) * t / totaltime + min;
        }

    }

    /// <summary>
    /// メイドモーションキャプチャー処理管理
    /// </summary>
    public class MaidMotionCaptureManager
    {
        public Dictionary<string, Dictionary<string, MaidPoseeBoneSet>> PoseBoneDic { get; set; }
        public Dictionary<string, bool> SelectedBoneDic { get; set; }
        public int PoseDicIndex { get; set; }
        public int PoseListIndex { get; set; }
        public bool IsOldAnimation { get; set; }
        public bool IsMotionCapture { get; set; }
        public bool IsAnimationCapture { get; set; }
        public bool IsLoopMotion { get; set; }
        public bool IsMyPose { get; set; }
        public bool IsToe { get; set; }
        public bool IsInterpolationOff { get; set; }
        public bool IsReset { get; set; }
        public string AnimationFileName { get; set; }
        public string SaveFileName { get; set; }

        private Dictionary<string, MotionTimeLineSet> boneComparison;
        private Dictionary<string, MotionTimeLineSet> morphComparison;
        private List<MotionTimeLineSet> boneData;
        private List<MotionTimeLineSet> morphData;
        private int caputureFrame;
        private float caputureTime;
        private float deltaTime;

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public MaidMotionCaptureManager()
        {
            SelectedBoneDic = new Dictionary<string, bool>();
            foreach(var key in MyConst.BONE_NAME_ALL.Keys)
            {
                SelectedBoneDic[key] = true;
            }
            IsMyPose = true;
            IsToe = true;
            IsInterpolationOff = true;
        }        

        /// <summary>
        /// 公式アニメーション再生
        /// </summary>
        public void PlayOfficialAnimation(Maid maid)
        {
            var anm = AnimationFileName.Contains(MyConst.EXTENSION_ANM) ? AnimationFileName : AnimationFileName + MyConst.EXTENSION_ANM;
            new MaidManager().CrossFadeAnimation(maid, anm, true, IsOldAnimation, MyConst.ANIMATION_FADE_TIME);
        }

        /// <summary>
        /// マイポーズアニメーション再生
        /// </summary>
        public void PlayMyPoseAnimation(Maid maid)
        {
            var fReader = new FileReader();
            var path = Path.Combine(MyHelper.RootFolder, MyConst.FOLDER_MYPOSE);
            path = Path.Combine(path, AnimationFileName);
            if (!path.Contains(MyConst.EXTENSION_ANM))
            {
                path += MyConst.EXTENSION_ANM;
            }
            path = fReader.CheckFilePath(path);
            if (!string.IsNullOrEmpty(path))
            {
                var poseData = new FileReader().ReadBinary(path);
                new MaidManager().CrossFadeMyPose(maid, AnimationFileName, poseData, true, MyConst.ANIMATION_FADE_TIME);
            }
        }

        /// <summary>
        /// アニメーションキャプチャー設定
        /// </summary>
        public void SetAnimationCapture(Maid maid)
        {
            var mgr = new MaidManager();
            var anm = AnimationFileName.Contains(MyConst.EXTENSION_ANM) ? AnimationFileName : AnimationFileName + MyConst.EXTENSION_ANM;
            mgr.CrossFadeAnimation(maid, anm, false, IsOldAnimation, MyConst.ANIMATION_NO_FADE_TIME);

            var state = mgr.GetAnimationState(maid);
            IsAnimationCapture = false;
            IsMotionCapture = false;
            if (state != null)
            {
                IsAnimationCapture = true;
                state.speed = 0f;
                boneComparison = new Dictionary<string, MotionTimeLineSet>();
                boneData = new List<MotionTimeLineSet>();
                caputureFrame = MyConst.PRE_INDEX;
            }
        }

        /// <summary>
        /// マイポーズ変換
        /// </summary>
        public void ConvertMyPoseFile()
        {
            var pose = GetMyPoseData();
            ExportTimelineData(pose);
        }

        /// <summary>
        /// マイポーズファイル調整
        /// </summary>
        public void AdjustMyPoseFile()
        {
            var pose = GetMyPoseData();
            if (IsToe)
            {
                pose = AdjustMyPoseToe(pose);
            }
            AdjustMyPose(pose);
        }

        /// <summary>
        /// モーションキャプチャー設定
        /// 모션 캡쳐 설정
        /// </summary>
        public void SetMotionCapture()
        {
            IsMotionCapture = true;
            IsAnimationCapture = false;
            boneComparison = new Dictionary<string, MotionTimeLineSet>();
            morphComparison = new Dictionary<string, MotionTimeLineSet>();
            boneData = new List<MotionTimeLineSet>();
            morphData = new List<MotionTimeLineSet>();
            caputureFrame = 0;
            caputureTime = 0f;
            deltaTime = 0f;
        }

        /// <summary>
        /// アニメーションキャプチャー
        /// 애니메이션 캡처
        /// </summary>
        public void CaptureAnimation(Maid maid, MaidMotionSet motionDelta)
        {
            var mgr = new MaidManager();
            var state = mgr.GetAnimationState(maid);
            if (state != null)
            {
                if (caputureFrame == MyConst.PRE_INDEX)
                {
                    caputureFrame++;
                }
                else
                {
                    var length = state.length;
                    caputureTime = caputureFrame * MyConst.FRAME_CONVERSION_RATIO;
                    state.time = length < caputureTime ? length : caputureTime;
                    GetCaptureBoneData(maid, motionDelta);

                    if (state.time == length)
                    {
                        EndCapture(true, maid);
                    }
                    else
                    {
                        caputureFrame++;
                    }
                }
            }
        }

        /// <summary>
        /// モーションキャプチャー
        /// </summary>
        public void CaptureMotion(Maid maid, MaidMotionSet motionDelta)
        {
            if (MyConst.MAX_MOTION_FRAME < caputureFrame)
            {
                EndCapture(false, null);
            }
            else if (caputureTime == 0 || motionDelta.time <= deltaTime)
            {
                GetCaptureBoneData(maid, motionDelta);
                GetCaptureMorphData(maid, motionDelta.morphValue);
                deltaTime = 0f;
                caputureFrame++;
            }
            caputureTime += Time.deltaTime;
            deltaTime += Time.deltaTime;
        }

        /// <summary>
        /// マイポーズ変換値
        /// </summary>
        private struct MyPoseData
        {
            public string boneName;
            public Dictionary<int, List<KeyFrameData>> keyFrame;
        }

        /// <summary>
        /// キーフレーム値
        /// </summary>
        private struct KeyFrameData
        {
            public float time;
            public float value;
            public float rad;
        }

        /// <summary>
        /// 座標調整値
        /// </summary>
        private struct TransformAdjustmentData
        {
            public Vector3 position;
            public Quaternion rotation;
        }

        /// <summary>
        /// マイポーズバイナリーデータ取得
        /// </summary>
        private List<MyPoseData> GetMyPoseData()
        {
            var fReader = new FileReader();
            var path = Path.Combine(MyHelper.RootFolder, MyConst.FOLDER_MYPOSE);
            path = Path.Combine(path, AnimationFileName);
            if (!path.Contains(MyConst.EXTENSION_ANM))
            {
                path += MyConst.EXTENSION_ANM;
            }
            path = fReader.CheckFilePath(path);
            if (string.IsNullOrEmpty(path))
            {
                return null;
            }

            var pose = new List<MyPoseData>();
            using (FileStream fs = new FileStream(path, FileMode.Open, FileAccess.Read))
            {
                var bin = new BinaryReader(fs);
                bin.ReadString(); //title
                bin.ReadInt32(); //version

                while (true)
                {
                    if (bin.ReadByte() == 0) break;
                    var data = new MyPoseData();
                    data.boneName = bin.ReadString();
                    data.keyFrame = new Dictionary<int, List<KeyFrameData>>();

                    for (int i = 100; i <= 106; i++)
                    {
                        var chanel = bin.ReadByte();
                        if (i != chanel)
                        {
                            i = chanel;
                        }
                        data.keyFrame[i] = new List<KeyFrameData>();
                        var count = bin.ReadInt32();
                        for (int j = 0; j < count; j++)
                        {
                            var kf = new KeyFrameData();
                            kf.time = bin.ReadSingle();
                            kf.value = bin.ReadSingle();
                            kf.rad = bin.ReadSingle();
                            bin.ReadSingle(); //rad
                            data.keyFrame[i].Add(kf);
                        }
                    }
                    pose.Add(data);
                }
                bin.Close();
            }
            return pose;
        }

        /// <summary>
        /// マイポーズ⇒タイムライン変換データ出力
        /// </summary>
        private void ExportTimelineData(List<MyPoseData> pose)
        {
            var bone = new List<MotionTimeLineSet>();
            foreach (var p in pose)
            {
                var tl = new Dictionary<int, TransformAdjustmentData>();
                foreach (var pair in p.keyFrame)
                {
                    foreach (var v in pair.Value)
                    {
                        var t = new TransformAdjustmentData();
                        var frame = (int)(v.time / MyConst.FRAME_CONVERSION_RATIO);
                        if (tl.ContainsKey(frame))
                        {
                            t = tl[frame];
                        }

                        switch (pair.Key)
                        {
                            case 100:
                                t.rotation.x = v.value;
                                break;
                            case 101:
                                t.rotation.y = v.value;
                                break;
                            case 102:
                                t.rotation.z = v.value;
                                break;
                            case 103:
                                t.rotation.w = v.value;
                                break;
                            case 104:
                                t.position.x = v.value;
                                break;
                            case 105:
                                t.position.y = v.value;
                                break;
                            case 106:
                                t.position.z = v.value;
                                break;
                        }
                        tl[frame] = t;
                    }
                }
                foreach (var pair in tl)
                {
                    var d = new MotionTimeLineSet();
                    d.frame = pair.Key;
                    d.name = p.boneName.Split(MyConst.DELIMITER_PATH).Last();
                    d.position = pair.Value.position;
                    d.rotation = pair.Value.rotation.eulerAngles;
                    if (SelectedBoneDic.ContainsKey(d.name) && SelectedBoneDic[d.name])
                    {
                        bone.Add(d);
                    }
                }
            }

            var bip = bone.FindAll(d => d.name == MyConst.BONE_ALL).OrderBy(d => d.frame).ToList();
            bone.RemoveAll(d => d.name == MyConst.BONE_ALL);
            var rotation = Vector3.zero;
            foreach (var b in bip)
            {
                var conv = b;
                if (rotation != Vector3.zero && conv.rotation == Vector3.zero)
                {
                    conv.rotation = rotation;
                }
                bone.Add(conv);
                rotation = conv.rotation;
            }
            var fileWriter = new FileWriter();
            var fileName = MyConst.HEADER_CAPTURE_BONE + SaveFileName;
            fileWriter.WriteMaidBone(bone, MyHelper.EndsWith(fileName, MyConst.EXTENSION_CSV));
        }

        /// <summary>
        /// Blenderファイル調整
        /// </summary>
        private List<MyPoseData> AdjustMyPoseToe(List<MyPoseData> pose)
        {
            foreach (var key in MyConst.BONE_NAME_TOES.Keys)
            {
                pose.RemoveAll(d => d.boneName.Split(MyConst.DELIMITER_PATH).Last() == key);
                var p = new MyPoseData();
                p.keyFrame = new Dictionary<int, List<KeyFrameData>>();
                foreach (var s in MyConst.BONE_PATH)
                {
                    if (s.Split(MyConst.DELIMITER_PATH).Last() == key)
                    {
                        p.boneName = s;
                        break;
                    }
                }
                var q = new Quaternion(0f, 0f, 0f, 0f);
                if (MyConst.BONE_DEFAULT_ROTATION.ContainsKey(key))
                {
                    q = Quaternion.Euler(MyConst.BONE_DEFAULT_ROTATION[key]);
                }
                var k = new KeyFrameData();
                for (int i = 100; i <= 106; i++)
                {
                    switch (i)
                    {
                        case 100:
                            k.value = q.x;
                            break;
                        case 101:
                            k.value = q.y;
                            break;
                        case 102:
                            k.value = q.z;
                            break;
                        case 103:
                            k.value = q.w;
                            break;
                    }
                    p.keyFrame[i] = new List<KeyFrameData>();
                    p.keyFrame[i].Add(k);
                }
                if (!string.IsNullOrEmpty(p.boneName))
                {
                    pose.Add(p);
                }
            }
            return pose;
        }

        private List<MyPoseData> AdjustMyPoseToe2(List<MyPoseData> pose)
        {
            foreach (var key in MyConst.BONE_NAME_TOES.Keys)
            {
                pose.RemoveAll(d => d.boneName.Split(MyConst.DELIMITER_PATH).Last() == key);
                var p = new MyPoseData();
                p.keyFrame = new Dictionary<int, List<KeyFrameData>>();
                foreach (var s in MyConst.BONE_PATH)
                {
                    if (s.Split(MyConst.DELIMITER_PATH).Last() == key)
                    {
                        p.boneName = s;
                        break;
                    }
                }
                var q = new Quaternion(0f, 0f, 0f, 0f);
                if (MyConst.BONE_DEFAULT_ROTATION.ContainsKey(key))
                {
                    q = Quaternion.Euler(MyConst.BONE_DEFAULT_ROTATION[key]);
                }
                var k = new KeyFrameData();
                for (int i = 100; i <= 106; i++)
                {
                    switch (i)
                    {
                        case 100:
                            k.value = q.x;
                            break;
                        case 101:
                            k.value = q.y;
                            break;
                        case 102:
                            k.value = q.z;
                            break;
                        case 103:
                            k.value = q.w;
                            break;
                    }
                    p.keyFrame[i] = new List<KeyFrameData>();
                    p.keyFrame[i].Add(k);
                }
                if (!string.IsNullOrEmpty(p.boneName))
                {
                    pose.Add(p);
                }
            }
            return pose;
        }

        /// <summary>
        /// Blenderファイル調整
        /// </summary>
        private void AdjustMyPose(List<MyPoseData> pose)
        {
            var memoryStream = new MemoryStream();
            var binaryWriter = new BinaryWriter(memoryStream);
            binaryWriter.Write(MyConst.HEADER_ANIMATION_NAME);
            binaryWriter.Write(MyConst.HEADER_ANIMATION_VERSION);
            WriteBinary(binaryWriter, pose);
            binaryWriter.Write(0);
            binaryWriter.Close();
            memoryStream.Close();
            var anmBinary = memoryStream.ToArray();
            memoryStream.Dispose();
            new FileWriter().WriteAnimationFile(anmBinary, MyConst.HEADER_ANM_ADJUSTMENT + AnimationFileName);
        }

        /// <summary>
        /// Blenderファイル調整
        /// </summary>
        private void WriteBinary(BinaryWriter binaryWriter, List<MyPoseData> pose)
        {
            foreach (var p in pose)
            {
                byte[] bonePath = Encoding.UTF8.GetBytes(p.boneName);
                var name = p.boneName.Split(MyConst.DELIMITER_PATH).Last();
                if (!SelectedBoneDic.ContainsKey(name))
                {
                    continue;
                }
                if (!SelectedBoneDic[name])
                {
                    continue;
                }

                binaryWriter.Write((byte)1);
                if (bonePath.Length < 128)
                {
                    binaryWriter.Write((byte)bonePath.Length);
                }
                else
                {
                    binaryWriter.Write(new byte[] { (byte)(bonePath.Length % 128 + 128), (byte)(bonePath.Length / 128) });
                }
                binaryWriter.Write(bonePath);

                foreach (var pair in p.keyFrame)
                {
                    var count = pair.Value.Count();
                    binaryWriter.Write((byte)(pair.Key));
                    binaryWriter.Write(count);

                    for (int j = 0; j < count; j++)
                    {
                        var x = pair.Value[j].time;
                        var y = pair.Value[j].value;
                        var rad = pair.Value[j].rad;

                        if (IsInterpolationOff)
                        {
                            rad = 0f;
                        }
                        else if (1 < count)
                        {
                            rad = CreateJoinRad(pair.Value, x, y, count, j);
                        }
                        binaryWriter.Write(x);
                        binaryWriter.Write(y);
                        binaryWriter.Write(rad);
                        binaryWriter.Write(rad);
                    }
                }
            }
        }

        /// <summary>
        /// 補完値作成
        /// </summary>
        private float CreateJoinRad(List<KeyFrameData> data, float x, float y, int count, int index)
        {
            var prev_x = 0f;
            var prev_y = 0f;
            var next_x = 0f;
            var next_y = 0f;

            if (index == 0)
            {
                prev_x = x - (data[index + 1].time - x);
                prev_y = y - (data[index + 1].value - y);
                next_x = data[index + 1].time;
                next_y = data[index + 1].value;
            }
            else if (index == count - 1)
            {
                prev_x = data[index - 1].time;
                prev_y = data[index - 1].value;
                next_x = x + (x - data[index - 1].time);
                next_y = y + (y - data[index - 1].value);
            }
            else
            {
                prev_x = data[index - 1].time;
                prev_y = data[index - 1].value;
                next_x = data[index + 1].time;
                next_y = data[index + 1].value;
            }
            var prev_rad = (prev_y - y) / (prev_x - x);
            var next_rad = (next_y - y) / (next_x - x);
            return (prev_rad + next_rad) / 2;
        }

        /// <summary>
        /// ボーンキャプチャーデータ取得
        /// </summary>
        private void GetCaptureBoneData(Maid maid, MaidMotionSet motionDelta)
        {
            foreach (var key in MyConst.BONE_NAME_ALL.Keys)
            {
                var d1 = GetCurrentBone(maid, key);
                if (caputureTime == 0)
                {
                    boneData.Add(d1);
                    boneComparison[key] = d1;
                }
                else
                {
                    var d2 = boneComparison[key];
                    if (motionDelta.rotation <= MyHelper.CalculateDelta(d1.rotation.x, d2.rotation.x) ||
                        motionDelta.rotation <= MyHelper.CalculateDelta(d1.rotation.y, d2.rotation.y) ||
                        motionDelta.rotation <= MyHelper.CalculateDelta(d1.rotation.z, d2.rotation.z) ||
                        key == MyConst.BONE_ALL &&
                       (motionDelta.position <= MyHelper.CalculateDelta(d1.position.x, d2.position.x) ||
                        motionDelta.position <= MyHelper.CalculateDelta(d1.position.y, d2.position.y) ||
                        motionDelta.position <= MyHelper.CalculateDelta(d1.position.z, d2.position.z)))
                    {
                        boneData.Add(d1);
                        boneComparison[key] = d1;
                    }
                }
            }
        }

        /// <summary>
        /// 表情キャプチャーデータ取得
        /// </summary>
        private void GetCaptureMorphData(Maid maid, float morphValue)
        {
            if (caputureTime == 0)
            {
                foreach (var key in MyConst.FACE_OPTION_MORPH.Keys)
                {
                    GetMorphData(maid, morphValue, key);
                }
            }
            foreach (var key in MyConst.FACE_MORPH.Keys)
            {
                GetMorphData(maid, morphValue, key);
            }
            foreach (var key in MyConst.MOUTH_MORPH.Keys)
            {
                GetMorphData(maid, morphValue, key);
            }
        }

        private void GetMorphData(Maid maid, float morphValue, string key)
        {
            var d1 = GetCurrentMorph(maid, key);
            if (caputureTime == 0)
            {
                morphData.Add(d1);
                morphComparison[key] = d1;
            }
            else
            {
                var d2 = morphComparison[key];
                if (morphValue <= MyHelper.CalculateDelta(d1.morphValue, d2.morphValue))
                {
                    morphData.Add(d1);
                    morphComparison[key] = d1;
                }
            }
        }

        /// <summary>
        /// キャプチャー終了処理
        /// </summary>
        public void EndCapture(bool isAnimation, Maid maid)
        {
            WriteFile();
            MyHelper.ClearDictionary(boneComparison);
            MyHelper.ClearDictionary(morphComparison);
            MyHelper.ClearList(boneData);
            MyHelper.ClearList(morphData);
            IsAnimationCapture = false;
            IsMotionCapture = false;
            if (isAnimation)
            {
                new MaidManager().ResetAnimation(maid, MyConst.ANIMATION_FADE_TIME);
            }
        }

        /// <summary>
        /// 現在ボーン取得
        /// </summary>
        private MotionTimeLineSet GetCurrentBone(Maid maid, string boneName)
        {
            var bone = maid.body0.GetBone(boneName);
            var data = new MotionTimeLineSet();
            data.frame = MyHelper.ConvertFrame(caputureTime);
            data.name = boneName;
            if (boneName == MyConst.BONE_ALL)
            {
                data.position = bone.transform.localPosition;
            }
            data.rotation = bone.transform.localEulerAngles;
            data.easing = (int)EasingType.Linear;
            return data;
        }

        /// <summary>
        /// 現在表情取得
        /// </summary>
        private MotionTimeLineSet GetCurrentMorph(Maid maid, string morphName)
        {
            var morph = maid.body0.Face.morph;
            var data = new MotionTimeLineSet();
            data.frame = MyHelper.ConvertFrame(caputureTime);
            data.name = morphName;
            data.morphValue = morph.GetBlendValues((int)morph.hash[morphName]);
            return data;
        }

        /// <summary>
        /// キャプチャーデータ書き込み
        /// </summary>
        private void WriteFile()
        {
            if (IsAnimationCapture && IsLoopMotion)
            {
                var frame = boneData.Max(d => d.frame) + 1;
                foreach (var data in boneData.FindAll(d => d.frame == 0))
                {
                    var d = new MotionTimeLineSet();
                    d.frame = frame;
                    d.name = data.name;
                    d.position = data.position;
                    d.rotation = data.rotation;
                    d.easing = data.easing;
                    boneData.Add(d);
                }
            }
            var fileWriter = new FileWriter();
            var fileName = MyConst.HEADER_CAPTURE_BONE + SaveFileName;
            fileWriter.WriteMaidBone(boneData, MyHelper.EndsWith(fileName, MyConst.EXTENSION_CSV));
            if (IsMotionCapture)
            {
                fileName = MyConst.HEADER_CAPTURE_MORPH + SaveFileName;
                fileWriter.WriteMaidMorph(morphData, MyHelper.EndsWith(fileName, MyConst.EXTENSION_CSV));
            }
        }

    }

    /// <summary>
    /// 動くメイド処理管理
    /// </summary>
    public class MovingMaidManager
    {
        public bool IsEnabled { get; set; }
        public bool IsAutoForward { get; set; }
        public bool IsAutoRound { get; set; }
        public bool IsAll { get; set; }
        public bool IsMove { get; set; }
        public float SpeedForward { get; set; }
        public float SpeedRotation { get; set; }
        public float SpeedUpDown { get; set; }

        private List<MaidMovingSet> moveData;
        private Dictionary<string, byte[]> myPoseData;
        private int moveIndex = 0;
        private int animationIndex = 0;
        private float animationTime = 0f;

        public MovingMaidManager(MoveSpeedSet set)
        {
            SpeedForward = set.maidForward;
            SpeedRotation = set.maidRotation;
            SpeedUpDown = set.maidUpDown;
        }

        public bool GetMyPoseData(string label)
        {
            var isGot = false;
            IsEnabled = false;
            ReadMovingData(label);
            if (!MyHelper.CheckNull(moveData))
            {
                var data = moveData.FindAll(m => m.animationType == (int)SongPoseType.MyPose);
                if (!MyHelper.CheckNull(data))
                {
                    myPoseData = new Dictionary<string, byte[]>();
                    foreach (var d in data)
                    {
                        foreach (var anm in d.animationData)
                        {
                            ReadMyPoseData(d.folder, anm.animation);
                        }
                        SpeedForward = d.forwardSpeed;
                    }
                }
                moveIndex = (int)MaidMovingType.Wait;
                animationIndex = MyConst.PRE_INDEX;
                animationTime = 0f;
                isGot = true;
            }
            return isGot;
        }

        public void ChangeMyPose(List<Maid> maids, int maidIndex, int moveIndex)
        {
            if (!MyHelper.CheckNull(moveData))
            {
                if (moveIndex != this.moveIndex)
                {
                    animationIndex = MyConst.PRE_INDEX;
                    animationTime = 0f;
                }
                var data = moveData[moveIndex];
                if (animationIndex == MyConst.PRE_INDEX ||
                    data.animationData[animationIndex].fadeTime + data.animationData[animationIndex].waitTime <= animationTime && data.animationData.Count() > 1)
                {
                    animationTime = 0f;
                    animationIndex++;
                    if (data.animationData.Count() <= animationIndex)
                    {
                        animationIndex = 0;
                    }
                    var anm = data.animationData[animationIndex];

                    var maidMgr = new MaidManager();
                    if (data.animationType == (int)SongPoseType.MyPose)
                    {
                        if (IsAll)
                        {
                            foreach (var maid in maids)
                            {
                                maidMgr.CrossFadeMyPose(maid, anm.animation, myPoseData[anm.animation], true, anm.fadeTime);
                            }
                        }
                        else
                        {
                            maidMgr.CrossFadeMyPose(maids[maidIndex], anm.animation, myPoseData[anm.animation], true, anm.fadeTime);
                        }
                    }
                    else
                    {
                        var isLoop = true;
                        var isCM3D2D = false;

                        if (data.animationType == (int)SongPoseType.AnimationNoLoop || data.animationType == (int)SongPoseType.OldAnimationNoLoop)
                        {
                            isLoop = false;
                        }
                        if (data.animationType == (int)SongPoseType.OldAnimation || data.animationType == (int)SongPoseType.OldAnimationNoLoop)
                        {
                            isCM3D2D = true;
                        }

                        if (IsAll)
                        {
                            foreach (var maid in maids)
                            {
                                maidMgr.CrossFadeAnimation(maid, anm.animation, isLoop, isCM3D2D, anm.fadeTime);
                            }
                        }
                        else
                        {
                            maidMgr.CrossFadeAnimation(maids[maidIndex], anm.animation, isLoop, isCM3D2D, anm.fadeTime);
                        }
                    }
                    this.moveIndex = moveIndex;
                }
                else
                {
                    animationTime += Time.deltaTime;
                }
            }
        }

        /// <summary>
        /// メイド座標設定(Y軸回転)
        /// </summary
        public void SetMaidMovingRotationY(List<Maid> maids, int maidIndex, float y)
        {
            if (IsAll)
            {
                foreach (var maid in maids)
                {
                    var rot = maid.transform.eulerAngles;
                    rot.y += y;
                    maid.SetRot(rot);
                }
            }
            else
            {
                var maid = maids[maidIndex];
                var rot = maid.transform.eulerAngles;
                rot.y += y;
                maid.SetRot(rot);
            }
        }

        /// <summary>
        /// メイド座標設定(Y軸位置)
        /// </summary
        public void SetMaidMovingPositionY(List<Maid> maids, int maidIndex, float h)
        {
            if (IsAll)
            {
                foreach (var maid in maids)
                {
                    var pos = maid.transform.position;
                    pos.y += h;
                    maid.SetPos(pos);
                }
            }
            else
            {
                var maid = maids[maidIndex];
                var pos = maid.transform.position;
                pos.y += h;
                maid.SetPos(pos);
            }
        }

        /// <summary>
        /// メイド座標設定(Z軸前位置)
        /// </summary
        public void SetMaidMovingPositionZ(List<Maid> maids, int maidIndex, float z)
        {
            if (IsAll)
            {
                foreach (var maid in maids)
                {
                    var pos = maid.transform.position + maid.transform.forward * z;
                    maid.SetPos(pos);
                }
            }
            else
            {
                var maid = maids[maidIndex];
                var pos = maid.transform.position + maid.transform.forward * z;
                maid.SetPos(pos);
            }
        }

        /// <summary>
        /// マイポーズデータクリア
        /// </summary
        public void ClearMyPoseData(List<Maid> maids)
        {
            var maidMgr = new MaidManager();
            foreach (var maid in maids)
            {
                maidMgr.RemoveAnimationClip(maid);
            }
            MyHelper.ClearDictionary(myPoseData);
            MyHelper.ClearList(moveData);
        }

        /// <summary>
        /// 動くメイドデータ読み込み
        /// </summary
        private void ReadMovingData(string label)
        {
            var fReader = new FileReader();
            var path = fReader.GetFilePath(MyConst.FILE_MAID_MOVING, "");
            if (!string.IsNullOrEmpty(path))
            {
                moveData = fReader.ReadMaidMovingData(path, label);
            }
            else
            {
                moveData = null;
            }
        }

        /// <summary>
        /// マイポーズデータ読み込み
        /// </summary
        private void ReadMyPoseData(string folder, string key)
        {
            if (!myPoseData.ContainsKey(key))
            {
                var path = new FileReader().GetFilePath(key, Path.Combine(MyConst.FOLDER_MYPOSE, folder));
                if (!string.IsNullOrEmpty(path))
                {
                    myPoseData[key] = new FileReader().ReadBinary(path);
                }
            }
        }
    }

    /// <summary>
    /// 映像処理管理
    /// </summary>
    public class VideoManager
    {
        public string VideoName { get; set; }
        public float SeekTime { get; set; }
        public float Volume { get; set; }
        public bool IsLooping { get; set; }
        public bool IsMuted { get; set; }
        public bool IsTransparent { get; set; }

        private MediaPlayer player;
        private GameObject gameObject;
        private bool isPlaying;
        private bool isPaused;

        /// <summary>
        /// コンストラクタ
        /// </summary
        public VideoManager(bool isTrue)
        {
            VideoName = "";
            IsLooping = isTrue;
            IsMuted = isTrue;
        }

        /// <summary>
        /// 公式ダンス映像読み込み
        /// </summary
        public void LoadOfficialDanceVideo(List<GameObject> obj, string fileName)
        {
            var fullPath = MyHelper.RootFolder.Replace(MyConst.FOLDER_SYBARIS, MyConst.FOLDER_GAMEDATA);
            fullPath = new FileReader().CheckFilePath(Path.Combine(fullPath, fileName));
            if (!string.IsNullOrEmpty(fullPath))
            {
                LoadVideo(fullPath);
                foreach(var o in obj)
                {
                    ApplyMaterial(o, false);
                }
            }
        }

        /// <summary>
        /// 歌モード映像読み込み
        /// </summary
        public void LoadSongModeVideo(GameObject obj, string filePath)
        {
            ClearFlag();
            LoadVideo(filePath);
            ApplyMaterial(obj, false);
        }

        /// <summary>
        /// 舞台道具映像読み込み
        /// </summary
        public void LoadStageObjectVideo(GameObject obj, bool isCurved)
        {
            var filePath = new FileReader().GetFilePath(VideoName, MyConst.FOLDER_VIDEO);
            if (!string.IsNullOrEmpty(filePath))
            {
                ClearFlag();
                LoadVideo(filePath);
                ApplyMaterial(obj, isCurved);
            }
        }

        /// <summary>
        /// 映像読み込み・再生
        /// </summary
        private void LoadVideo(string filePath)
        {
            gameObject = new GameObject();
            player = gameObject.GetOrAddComponent<MediaPlayer>();
            player.m_VideoLocation = MediaPlayer.FileLocation.AbsolutePathOrURL;
            player.m_VideoPath = filePath;
            player.m_Loop = IsLooping;
            player.m_Muted = IsMuted;
            if (!IsMuted)
            {
                player.m_Volume = Volume;
            }
            if (player.OpenVideoFromFile(MediaPlayer.FileLocation.AbsolutePathOrURL, player.m_VideoPath, false))
            {
                if (player.VideoOpened)
                {
                    player.Play();
                    isPlaying = true;
                }
            }
        }

        /// <summary>
        /// オブジェクトへ映像設定
        /// </summary
        private void ApplyMaterial(GameObject obj, bool isCurved)
        {
            var shaderName = IsTransparent ? MyConst.SHADER_PARTICLE : MyConst.SHADER_UNLIGHT;
            var material = obj.GetComponent<MeshRenderer>().material;
            material.shader = Shader.Find(shaderName);
            var atm = obj.GetOrAddComponent<ApplyToMaterial>();
            atm._media = player;
            if (isCurved)
            {
                atm._scale = new Vector2(MyConst.CURVED_TEXTURE_SCALE, MyConst.CURVED_TEXTURE_SCALE);
            }
            atm._material = material;
        }

        /// <summary>
        /// 映像再生終了
        /// </summary
        public void EndVideo()
        {
            if (CheckPlayer())
            {
                player.Stop();
                player.CloseVideo();
            }
            GameObject.Destroy(player);
            GameObject.Destroy(gameObject);
            ClearFlag();
        }

        /// <summary>
        /// 映像位置設定
        /// </summary
        public void SeekVideo(float time)
        {
            if (CheckPlayer())
            {
                player.Control.Seek(time * 1000f);
            }
        }

        /// <summary>
        /// 映像現在タイム取得
        /// </summary
        public float GetCurrentTime()
        {
            if (CheckPlayer())
            {
                return player.Control.GetCurrentTimeMs() / 1000f;
            }
            return 0f;
        }

        /// <summary>
        /// 映像一時停止・再開
        /// </summary
        public void PauseVideo(bool isPaused)
        {
            if (CheckPlayer())
            {
                if (isPaused)
                {
                    player.Pause();
                    player.m_Muted = true;
                }
                else
                {
                    player.Play();
                    player.m_Muted = IsMuted;
                }
                this.isPaused = isPaused;
            }
        }

        /// <summary>
        /// 映像再生判定
        /// </summary
        public bool IsPlayed()
        {
            return isPlaying;
        }

        /// <summary>
        /// 映像一時停止判定
        /// </summary
        public bool IsPause()
        {
            return isPaused;
        }

        /// <summary>
        /// フラグ初期化
        /// </summary
        private void ClearFlag()
        {
            isPlaying = false;
            isPaused = false;
        }

        /// <summary>
        /// 映像オブジェクト状態判定
        /// </summary
        private bool CheckPlayer()
        {
            if (player != null)
            {
                if (player.VideoOpened)
                {
                    return true;
                }
            }
            return false;
        }
    }

    /// <summary>
    /// VMDファイル処理管理
    /// </summary>
    public class VMDManager
    {
        /// <summary>
        /// 表情モーション変換
        /// </summary>
        public void ConvertMorphData(string fileName, bool isNoMouth)
        {
            var filePath = new FileReader().GetFilePath(fileName, MyConst.FOLDER_TIMELINE);
            if (!string.IsNullOrEmpty(filePath))
            {
                var morphData = ConvertMorph(filePath, isNoMouth);
                if (!MyHelper.CheckNull(morphData))
                {
                    AddLastMorphData(ref morphData);
                    filePath = filePath.Replace(MyConst.EXTENSION_VMD, MyConst.EXTENSION_CSV);
                    new FileWriter().WriteMaidMorph(morphData, filePath);
                }
            }
        }

        /// <summary>
        /// 表情モーション変換
        /// </summary>
        private List<MotionTimeLineSet> ConvertMorph(string filePath, bool isNoMouth)
        {
            var morphData = new List<MotionTimeLineSet>();
            using (var reader = new BinaryReader(File.Open(filePath, FileMode.Open)))
            {
                //ヘッダ[50]
                //モーションデータ数[4]
                //モーションデータ[111]
                //表情データ数[4]
                //表情名[15]
                //フレーム番号[4]
                //表情の設定値[4]
                //カメラデータ数[4]
                //フレーム番号[4]
                //照明データ数[4]

                reader.ReadBytes(50);
                var dataCountMax = reader.ReadInt32();
                if (0 < dataCountMax)
                {
                    reader.ReadBytes(dataCountMax * 111);
                }
                dataCountMax = reader.ReadInt32();
                var dataCount = 0;
                while (dataCount < dataCountMax)
                {
                    var keys = new List<byte>();
                    foreach (var b in reader.ReadBytes(15))
                    {
                        if (b != 253 && b != 0)
                        {
                            keys.Add(b);
                        }
                    }
                    var frame = reader.ReadInt32();
                    var value = reader.ReadSingle();
                    var key = BitConverter.ToString(keys.ToArray());
                    if (MyConst.VMD_MORPH_CONVERT.ContainsKey(key))
                    {
                        var name = MyConst.VMD_MORPH_CONVERT[key];
                        if (!isNoMouth || isNoMouth && !MyConst.MOUTH_MORPH.ContainsKey(name))
                        {
                            var data = new MotionTimeLineSet();
                            data.frame = frame;
                            data.name = name;
                            data.morphValue = value * GetRatio(name);
                            morphData.Add(data);
                        }
                    }
                    dataCount++;
                }
            }
            if (!MyHelper.CheckNull(morphData))
            {
                AddZeroFrameData(MyConst.FACE_OPTION_MORPH.Keys.ToList(), ref morphData);
                AddZeroFrameData(MyConst.FACE_MORPH.Keys.ToList(), ref morphData);
                AddZeroFrameData(MyConst.MOUTH_MORPH.Keys.ToList(), ref morphData);
            }
            return morphData.OrderBy(d => d.frame).ToList();
        }

        /// <summary>
        /// モーション変換掛け目取得
        /// </summary>
        private float GetRatio(string name)
        {
            var val = 1f;
            switch (name)
            {
                case MyConst.FACE_MOUTH_A:
                case MyConst.FACE_MOUTH_C:
                    val = MyConst.MOUTH_RATIO_MIDDLE;
                    break;
                case MyConst.FACE_MOUTH_I:
                    val = MyConst.MOUTH_RATIO_SMALL;
                    break;
            }
            return val;
        }

        /// <summary>
        /// 表情モーション変換
        /// </summary>
        private void AddLastMorphData(ref List<MotionTimeLineSet> morph)
        {
            foreach(var name in MyConst.ALL_FACIAL_MORPH.Keys)
            {
                var data = morph.FindAll(d => d.name == name);
                var max = data.Max(d => d.frame);
                if(0 < max)
                {
                    var dt = data.FirstOrDefault(d => d.frame == max);
                    dt.frame = max + 1;
                    morph.Add(dt);
                }
            }
        }

        /// <summary>
        /// 不足0フレームデータ追加
        /// </summary>
        private void AddZeroFrameData(List<string> keys, ref List<MotionTimeLineSet> morphData)
        {
            foreach (var key in keys)
            {
                if (!morphData.Exists(d => d.frame == 0 && d.name == key))
                {
                    var data = new MotionTimeLineSet();
                    data.frame = 0;
                    data.name = key;
                    data.morphValue = 0f;
                    morphData.Add(data);
                }
            }
        }

        /// <summary>
        /// カメラモーション変換
        /// 카메라 모션 변환
        /// </summary>
        public void ConvertCameraData(string fileName)
        {
            var filePath = new FileReader().GetFilePath(fileName, MyConst.FOLDER_TIMELINE);
            if (!string.IsNullOrEmpty(filePath))
            {
                var cameraData = ConvertCamera(filePath);
                if (!MyHelper.CheckNull(cameraData))
                {
                    filePath = filePath.Replace(MyConst.EXTENSION_VMD, MyConst.EXTENSION_CSV);
                    new FileWriter().WriteMaidCamera(cameraData, filePath);
                }
            }
        }

        /// <summary>
        /// カメラモーション変換
        /// </summary>
        private List<MotionTimeLineSet> ConvertCamera(string filePath)
        {
            var cameraData = new List<MotionTimeLineSet>();
            using (var reader = new BinaryReader(File.Open(filePath, FileMode.Open)))
            {
                //ヘッダ[50]
                //モーションデータ数[4]
                //表情データ数[4]
                //カメラデータ数[4]
                //フレーム番号[4]
                //距離[4]
                //位置[4*3]
                //回転[4*3] X軸は符号が反転
                //補完[24] x y z q d v
                //視野角[4]
                //パースペクティブ[8]
                //照明データ数[4]

                reader.ReadBytes(58);
                var dataCountMax = reader.ReadInt32();
                var dataCount = 0;
                while (dataCount < dataCountMax)
                {
                    var data = new MotionTimeLineSet();
                    data.frame = reader.ReadInt32();
                    data.distance = reader.ReadSingle() / MyConst.POSITION_CONVERSION_RATIO * -1;
                    data.position = new Vector3(reader.ReadSingle() * -1, reader.ReadSingle(), reader.ReadSingle() * -1) / MyConst.POSITION_CONVERSION_RATIO;
                    data.rotation = new Vector3(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle()) * Mathf.Rad2Deg * -1;
                    data.rotation = new Vector3(Mathf.Repeat(data.rotation.x, 360f), Mathf.Repeat(data.rotation.y + 180f, 360f), Mathf.Repeat(data.rotation.z, 360f));
                    reader.ReadBytes(12);
                    var bezier = reader.ReadBytes(4);
                    var isIn = 60 <= bezier[0] && bezier[2] <= 20;
                    var isOut = bezier[1] <= 67 && 107 <= bezier[3];
                    if (isIn && isOut)
                    {
                        data.easing = (int)EasingType.CubicInOut;
                    }
                    else if (isIn)
                    {
                        data.easing = (int)EasingType.CubicIn;
                    }
                    else if (isOut)
                    {
                        data.easing = (int)EasingType.CubicOut;
                    }
                    reader.ReadBytes(8);
                    data.viewAngle = reader.ReadInt32();
                    reader.ReadBytes(1);
                    cameraData.Add(data);
                    dataCount++;
                }
            }
            return cameraData.OrderBy(d => d.frame).ToList();
        }

        /// <summary>
        /// VMD指ボーンモーション変換
        /// </summary>
        public void ConvertVMDFingerBoneData(string vmdFile)
        {
            var vmdPath = new FileReader().GetFilePath(vmdFile, MyConst.FOLDER_TIMELINE);
            if (string.IsNullOrEmpty(vmdPath))
            {
                return;
            }
            //Console.WriteLine("タイムラインボーンデータ調整中");
            var boneData = ConvertFingerBone(vmdPath);
            if (!MyHelper.CheckNull(boneData))
            {
                foreach(var key in MyConst.BONE_NAME_FINGERS.Keys)
                {
                    if (!boneData.Exists(d => d.name == key))
                    {
                        var d = new MotionTimeLineSet();
                        d.name = key;
                        if (MyConst.BONE_DEFAULT_ROTATION.ContainsKey(key))
                        {
                            d.rotation = MyConst.BONE_DEFAULT_ROTATION[key];
                        }
                        boneData.Add(d);
                    }
                }
                var name = vmdFile.Replace(MyConst.EXTENSION_VMD, MyConst.EXTENSION_CSV);
                new FileWriter().WriteMaidBone(boneData, name);
            }
            //Console.WriteLine("タイムラインボーンデータ調整完了");
        }

        /// <summary>
        /// 指ボーンモーション変換
        /// </summary>
        public List<MotionTimeLineSet> ConvertFingerBone(string vmdPath)
        {
            var vmdData = new List<MotionTimeLineSet>();
            using (var reader = new BinaryReader(File.Open(vmdPath, FileMode.Open)))
            {
                //ヘッダ[50]
                //モーションデータ数[4]
                //ボーン名[15]
                //フレーム番号[4]
                //位置[4*3]
                //回転[4*4]
                //補完[64]
                reader.ReadBytes(50);
                var dataCountMax = reader.ReadInt32();
                var dataCount = 0;
                while (dataCount < dataCountMax)
                {
                    var keys = new List<byte>();
                    foreach (var b in reader.ReadBytes(15))
                    {
                        if (b != 253 && b != 0)
                        {
                            keys.Add(b);
                        }
                    }
                    var key = BitConverter.ToString(keys.ToArray());
                    var frame = reader.ReadInt32();
                    reader.ReadBytes(12);
                    var quaternion = new Quaternion(reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle(), reader.ReadSingle());
                    var rotation = quaternion.eulerAngles;

                    var name = "";
                    if (MyConst.VMD_BONE_FINGER.ContainsKey(key))
                    {
                        rotation.x = quaternion.eulerAngles.x;
                        rotation.y = quaternion.eulerAngles.y;
                        rotation.z = quaternion.eulerAngles.z;
                        name = MyConst.VMD_BONE_FINGER[key];
                        if (name.StartsWith(MyConst.BONE_RIGHT))
                        {
                            rotation.z *= -1;
                        }
                        rotation.y *= -1;
                        if (MyConst.BONE_DEFAULT_ROTATION.ContainsKey(name))
                        {
                            rotation += MyConst.BONE_DEFAULT_ROTATION[name];
                        }
                    }
                    rotation.x = Mathf.Repeat(rotation.x, 360f);
                    rotation.y = Mathf.Repeat(rotation.y, 360f);
                    rotation.z = Mathf.Repeat(rotation.z, 360f);

                    if (15 < name.Length)
                    {
                        rotation.x = 0f;
                        rotation.y = 0f;
                    }
                    reader.ReadBytes(64);
                    if (!string.IsNullOrEmpty(name))
                    {
                        var d = new MotionTimeLineSet();
                        d.frame = frame;
                        d.name = name;
                        d.rotation = rotation;
                        d.easing = 0;
                        vmdData.Add(d);
                    }
                    dataCount++;
                }
            }
            return vmdData;
        }

        /*
        /// <summary>
        /// ボーンモーション変換
        /// </summary>
        private List<MotionTimeLineSet> ConvertBone2(string vmdPath, string bonePath)
        {
            var tlData = new List<MotionTimeLineSet>();
            var vmdData = new List<MotionTimeLineSet>();
            using (var reader = new BinaryReader(File.Open(vmdPath, FileMode.Open)))
            {
                //ヘッダ[50]
                //モーションデータ数[4]
                //ボーン名[15]
                //フレーム番号[4]
                //位置[4*3]
                //回転[4*4]
                //補完[64]
                reader.ReadBytes(50);
                var dataCountMax = reader.ReadInt32();
                var dataCount = 0;
                while (dataCount < dataCountMax)
                {
                    var keys = new List<byte>();
                    foreach (var b in reader.ReadBytes(15))
                    {
                        if (b != 253 && b != 0)
                        {
                            keys.Add(b);
                        }
                    }
                    var frame = reader.ReadInt32();
                    reader.ReadBytes(12);
                    reader.ReadBytes(16);
                    var bezier = reader.ReadBytes(64);
                    var isIn = 60 <= bezier[3] && bezier[7] <= 20;
                    var isOut = bezier[11] <= 67 && 107 <= bezier[15];
                    var easing = 0;
                    if (isIn && isOut)
                    {
                        easing = (int)EasingType.CubicInOut;
                    }
                    else if (isIn)
                    {
                        easing = (int)EasingType.CubicIn;
                    }
                    else if (isOut)
                    {
                        easing = (int)EasingType.CubicOut;
                    }
                    var key = BitConverter.ToString(keys.ToArray());
                    if (MyConst.VMD_BONE_CONVERT.ContainsKey(key))
                    {
                        var d = new MotionTimeLineSet();
                        d.frame = frame;
                        d.name = MyConst.VMD_BONE_CONVERT[key];
                        d.easing = easing;
                        vmdData.Add(d);
                    }
                    dataCount++;
                }
            }

            var boneData = new FileReader().ReadMaidMotionFileData(bonePath);
            var names = vmdData.Select(d => d.name).Distinct().ToList();
            foreach (var name in names)
            {
                var vmdFrames = vmdData.FindAll(d => d.name == name).Select(d => d.frame).OrderBy(d => d).ToList();
                var boneFrames = boneData.FindAll(d => d.name == name).Select(d => d.frame).OrderBy(d => d).ToList();
                foreach (var frame in vmdFrames)
                {
                    var isMatching = false;
                    for (int i = 0; i <= 10; i++)
                    {
                        for (int j = 0; j <= 1; j++)
                        {
                            var adjustedFrame = frame + i * (j == 0 ? 1 : -1);
                            if (boneFrames.Exists(d => d == adjustedFrame))
                            {
                                var vmd = vmdData.FirstOrDefault(d => d.name == name && d.frame == adjustedFrame);
                                var bone = boneData.FirstOrDefault(d => d.name == name && d.frame == adjustedFrame);
                                bone.easing = vmd.easing;
                                if (!tlData.Exists(d => d.name == name && d.frame == adjustedFrame))
                                {
                                    tlData.Add(bone);
                                }
                                isMatching = true;
                                break;
                            }
                        }
                        if (isMatching) break;
                    }

                    if (!isMatching && CheckBone(name))
                    {
                        var adjustedFrame = boneFrames.FindAll(d => d < frame).Max();
                        var bone = boneData.FirstOrDefault(d => d.name == name && d.frame == adjustedFrame);
                        if (!tlData.Exists(d => d.name == name && d.frame == adjustedFrame))
                        {
                            tlData.Add(bone);
                        }
                    }
                }
            }
            foreach (var bone in boneData)
            {
                if (!names.Exists(d => d == bone.name) && CheckBone(bone.name))
                {
                    tlData.Add(bone);
                }
            }
            foreach (var key in MyConst.BONE_NAME.Keys)
            {
                if (!tlData.Exists(d => d.name == key && d.frame == 0))
                {
                    tlData.Add(boneData.FirstOrDefault(d => d.name == key && d.frame == 0));
                }
            }
            return tlData;
        }

        /// <summary>
        /// 除外ボーン名チェック
        /// </summary>
        private bool CheckBone(string name)
        {
            return !name.Contains(MyConst.BONE_FINGER) && !name.Contains(MyConst.BONE_TOE);
        }
        */
    }

    /// <summary>
    /// Gui処理管理
    /// </summary>
    public class GuiManager
    {
        public TransformSliderSet TransformSlider { get; set; }
        public DanceAnimationSyncSet DanceSyncSet { get; set; }
        public Texture2D GuiBackgroundTexture { get; set; }

        public int FreeDanceOptionIndex { get; set; }
        public int AppearanceIndex { get; set; }
        public int FacialIndex { get; set; }
        public int MotionProcTypeIndex { get; set; }
        public int DanceMovieTypeIndex { get; set; }
        public float LimitY { get; set; }
        public bool IsLimitY { get; set; }
        public bool IsFacialEnabled { get; set; }
        public bool IsKuchipakuDisabled { get; set; }
        public bool IsMaidAll { get; set; }
        public bool IsMaidAppearanceAll { get; set; }
        public bool IsFreeEffectOff { get; set; }
        public bool IsFreeMotionOff { get; set; }
        public bool IsChangeDressOff { get; set; }
        public bool IsChangingLightOff { get; set; }
        public bool IsChangingBgOff { get; set; }
        public bool IsOfficialUiOff { get; set; }
        public bool IsOfficialGearOff { get; set; }
        public bool IsOfficialFpsOff { get; set; }
        public bool IsMaidVisibledOff { get; set; }
        public bool IsDanceSliderOn { get; set; }
        public bool IsDanceListSort { get; set; }
        public bool IsRandomDress { get; set; }
        public bool IsFreeRepeatOn { get; set; }
        public bool IsExtraAll { get; set; }
        public bool IsBukkakeList { get; set; }
        public bool IsMovieTransparent { get; set; }
        public string BackgroundLabel { get; set; }
        public string CustomFaceLabel { get; set; }
        public string SwicherLabel { get; set; }
        public string DressLabel { get; set; }
        public string HairMenuLabel { get; set; }
        public string AutoCameraLabel { get; set; }
        //public string BodyMenu { get; set; }

        private readonly MyGuiStyle guiStyle;

        public GuiManager(MyGuiStyle guiStyle)
        {
            this.guiStyle = guiStyle;
            DanceMovieTypeIndex = (int)DanceMovieType.LiveStage;
            IsMaidAll = true;
        }

        public void HideOfficialUi(bool isUiOff)
        {
            var root = GameObject.Find("/UI Root");
            var ui = root.transform.Find("Camera").gameObject;
            if (ui != null)
            {
                ui.SetActive(!isUiOff);
                IsOfficialUiOff = isUiOff;
            }
        }

        public void HideOfficialGear(bool isUiOff)
        {
            var ui = UTY.GetChildObject(GameMain.Instance.gameObject, "SystemUI Root/SystemShortcut", false);
            if (ui != null)
            {
                ui.SetActive(!isUiOff);
                IsOfficialGearOff = isUiOff;
            }
        }

        public void HideOfficialFps(bool isUiOff)
        {
            var ui = UTY.GetChildObject(GameMain.Instance.gameObject, "SystemUI Root/FpsCounter", false);
            if (ui != null)
            {
                ui.SetActive(!isUiOff);
                IsOfficialFpsOff = isUiOff;
            }
        }

        public void MakeGuiBackgroundTexture(Vector4 backgroundColor)
        {
            var color = new Color32((byte)backgroundColor.x,
                                    (byte)backgroundColor.y,
                                    (byte)backgroundColor.z,
                                    (byte)backgroundColor.w);
            var width = 2;
            var height = 2;
            Color[] pix = new Color[width * height];
            for (int i = 0; i < pix.Length; ++i)
            {
                pix[i] = color;
            }
            GuiBackgroundTexture = new Texture2D(width, height);
            GuiBackgroundTexture.SetPixels(pix);
            GuiBackgroundTexture.Apply();
        }

        public int SetSelectedMaidButton(int baseRow, List<Maid> maids, int maidIndex, MaidManager maidMgr)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "対象メイド", guiStyle.gsLabel);

            if (maids.Count() <= maidIndex)
            {
                maidIndex = 0;
            }
            SetIndexChangedButton(ref rect, maids.Count(), ref maidIndex);
            var name = maidMgr.GetMaidFullName(maids[maidIndex]);
            SetIndexChangedLabel(rect, name);
            return maidIndex;
        }

        public void SetZoomSlider(int baseRow, ref CameraManager cameraMgr)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width = 125f;
            var isZoom = cameraMgr.IsZoom;
            var zoomSlider = cameraMgr.ZoomSlider;
            cameraMgr.IsZoom = GUI.Toggle(rect, cameraMgr.IsZoom, "カメラズーム", guiStyle.gsToggle);
            rect.x += rect.width;
            rect.width = 50f;
            if (GUI.Button(rect, "VR値", guiStyle.gsButton))
            {
                zoomSlider = MyConst.ZOOM_DEFAULT_VR;
            }
            rect.x += 75f;
            if (cameraMgr.IsZoom)
            {
                rect.y += rect.height / 3;
                rect.width = MyConst.GUI_WIDTH * 2;
                rect.height /= 2;
                zoomSlider = GUI.HorizontalSlider(rect, zoomSlider, MyConst.ZOOM_MIN, MyConst.ZOOM_MAX);
            }
            else if(isZoom != cameraMgr.IsZoom)
            {
                zoomSlider = MyConst.ZOOM_DEFAULT;
            }

            if (!cameraMgr.IsCustome &&
                (zoomSlider != cameraMgr.ZoomSlider || isZoom != cameraMgr.IsZoom))
            {
                cameraMgr.ZoomCamera(zoomSlider);
                
            }
            cameraMgr.ZoomSlider = zoomSlider;
        }

        public void SetNumberField(Rect rect, int defaultVal, ref int numVal)
        {
            rect.width *= MyConst.GUI_TEXT_WIDTH_RATIO;
            int i;
            var text = numVal.ToString();
            text = GUI.TextField(rect, text, MyConst.MAX_LENGTH_NUMBER, guiStyle.gsNumberText);
            numVal = int.TryParse(text, out i) ? i : defaultVal;
        }

        public void SetNumberField(Rect rect, float defaultVal, ref float numVal)
        {
            rect.width *= MyConst.GUI_TEXT_WIDTH_RATIO;
            float f;
            var text = numVal.ToString(MyConst.DECIMAL_FORMAT);
            text = GUI.TextField(rect, text, MyConst.MAX_LENGTH_NUMBER, guiStyle.gsNumberText);
            numVal = float.TryParse(text, out f) ? f : defaultVal;
        }

        public void SetNumberField(Rect rect, byte defaultVal, ref byte numVal)
        {
            rect.width *= MyConst.GUI_TEXT_WIDTH_RATIO;
            byte b;
            var text = numVal.ToString();
            text = GUI.TextField(rect, text, MyConst.MAX_LENGTH_NUMBER, guiStyle.gsNumberText);
            numVal = byte.TryParse(text, out b) ? b : defaultVal;
        }

        public string SetTextField(Rect rect, string text)
        {
            rect.width *= MyConst.GUI_TEXT_WIDTH_RATIO;
            text = string.IsNullOrEmpty(text) ? "" : text;
            return GUI.TextField(rect, text, MyConst.MAX_LENGTH_STRING, guiStyle.gsText);
        }

        public bool SetSaveField(int baseRow, ref string saveName)
        {
            return SetSaveField(baseRow, "リスト表示名", "リスト追加", ref saveName);
        }

        public bool SetSaveField(int baseRow, string label, string button, ref string saveName)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, label, guiStyle.gsLabel);
            rect.x += rect.width;
            var width = rect.width + rect.width * MyConst.GUI_TEXT_WIDTH_RATIO;
            rect.width = width;
            var text = string.IsNullOrEmpty(saveName) ? "" : saveName;
            saveName = SetTextField(rect, text);
            rect.width = MyConst.GUI_WIDTH;
            rect.x += rect.width * 2;
            return GUI.Button(rect, button, guiStyle.gsButton);
        }

        public void SetPositionSlider(int baseRow, ref Vector3 position, Vector3 resetValue)
        {
            var st = new Vector3(TransformSlider.positionMin.x, TransformSlider.positionMin.y, TransformSlider.positionMin.z);
            var ed = new Vector3(TransformSlider.positionMax.x, TransformSlider.positionMax.y, TransformSlider.positionMax.z);
            var lalel = new string[] { "P.x", "P.y", "P.z" };
            SetSlider(baseRow, ref position, MyConst.GUI_ONE_SLIDER_SMALL, st, ed, resetValue, lalel);
        }

        public void SetRotationSlider(int baseRow, ref Vector3 rotation, Vector3 resetValue)
        {
            var st = new Vector3(TransformSlider.rotationMin.x, TransformSlider.rotationMin.y, TransformSlider.rotationMin.z);
            var ed = new Vector3(TransformSlider.rotationMax.x, TransformSlider.rotationMax.y, TransformSlider.rotationMax.z);
            var lalel = new string[] { "R.x", "R.y", "R.z" };
            SetSlider(baseRow, ref rotation, MyConst.GUI_ONE_SLIDER_NORMAL, st, ed, resetValue, lalel);
        }

        public void SetBoneSlider(int baseRow, ref Vector3 rotation, Vector3 resetValue)
        {
            MyHelper.AdjustRotation(ref rotation.x);
            MyHelper.AdjustRotation(ref rotation.y);
            MyHelper.AdjustRotation(ref rotation.z);
            var st = new Vector3(TransformSlider.boneRotationMin.x, TransformSlider.boneRotationMin.y, TransformSlider.boneRotationMin.z);
            var ed = new Vector3(TransformSlider.boneRotationMax.x, TransformSlider.boneRotationMax.y, TransformSlider.boneRotationMax.z);
            var lalel = new string[] { "R.x", "R.y", "R.z" };
            SetSlider(baseRow, ref rotation, MyConst.GUI_ONE_SLIDER_NORMAL, st, ed, resetValue, lalel);

            if(rotation.x < TransformSlider.boneRotationMin.x)
            {
                rotation.x = TransformSlider.boneRotationMin.x;
            }
            else if (TransformSlider.boneRotationMax.x < rotation.x)
            {
                rotation.x = TransformSlider.boneRotationMax.x;
            }
        }

        public void SetBoneSlider(int baseRow, ref Quaternion quaternion, Vector4 resetValue)
        {
            var lalel = new string[] { "Q.x", "Q.y", "Q.z", "Q.w" };
            var reset = MyConst.GUI_ONE_SLIDER_SMALL;
            var index = 0;
            quaternion.x = SetSlider(baseRow + index, quaternion.x, reset, -1f, 1f, resetValue.x, lalel[index]);
            index++;
            quaternion.y = SetSlider(baseRow + index, quaternion.y, reset, -1f, 1f, resetValue.y, lalel[index]);
            index++;
            quaternion.z = SetSlider(baseRow + index, quaternion.z, reset, -1f, 1f, resetValue.z, lalel[index]);
            index++;
            quaternion.w = SetSlider(baseRow + index, quaternion.w, reset, -1f, 1f, resetValue.w, lalel[index]);
        }

        public void SetScaleSlider(int baseRow, ref Vector3 scale)
        {
            var st = new Vector3(TransformSlider.scaleMin.x, TransformSlider.scaleMin.y, TransformSlider.scaleMin.z);
            var ed = new Vector3(TransformSlider.scaleMax.x, TransformSlider.scaleMax.y, TransformSlider.scaleMax.z);
            var resetValue = new Vector3(MyConst.SCALE_DEFAULT, MyConst.SCALE_DEFAULT, MyConst.SCALE_DEFAULT);
            var lalel = new string[] { "S.x", "S.y", "S.z" };
            SetSlider(baseRow, ref scale, MyConst.GUI_ONE_SLIDER_SMALL, st, ed, resetValue, lalel);
        }

        public void SetColorSlider(int baseRow, ref Color32 color, bool isAlpha)
        {
            var min = MyConst.COLOR_MIN;
            var max = MyConst.COLOR_MAX;
            var reset = MyConst.COLOR_MAX;
            var distance = MyConst.GUI_ONE_SLIDER_NORMAL;

            color.r = (byte)SetSliderArrow(baseRow, distance, min, max, color.r, "R");
            color.r = (byte)SetSliderText(baseRow, color.r);
            color.r = (byte)SetSliderReset(baseRow, color.r, reset);
            color.r = (byte)SetSliderSlider(baseRow, min, max, color.r);

            baseRow++;
            color.g = (byte)SetSliderArrow(baseRow, distance, min, max, color.g, "G");
            color.g = (byte)SetSliderText(baseRow, color.g);
            color.g = (byte)SetSliderReset(baseRow, color.g, reset);
            color.g = (byte)SetSliderSlider(baseRow, min, max, color.g);

            baseRow++;
            color.b = (byte)SetSliderArrow(baseRow, distance, min, max, color.b, "B");
            color.b = (byte)SetSliderText(baseRow, color.b);
            color.b = (byte)SetSliderReset(baseRow, color.b, reset);
            color.b = (byte)SetSliderSlider(baseRow, min, max, color.b);

            if (isAlpha)
            {
                baseRow++;
                SetAlphaSlider(baseRow, ref color);
            }
        }

        public void SetAlphaSlider(int baseRow, ref Color32 color)
        {
            var min = MyConst.COLOR_MIN;
            var max = MyConst.COLOR_MAX;
            var reset = MyConst.COLOR_MAX;
            var distance = MyConst.GUI_ONE_SLIDER_NORMAL;

            color.a = (byte)SetSliderArrow(baseRow, distance, min, max, color.a, "A");
            color.a = (byte)SetSliderText(baseRow, color.a);
            color.a = (byte)SetSliderReset(baseRow, color.a, reset);
            color.a = (byte)SetSliderSlider(baseRow, min, max, color.a);
        }

        public float SetOneLineSlider(string label, int baseRow,
                                      float currentValue, float minValue, float maxValue, float defaultValue, float adjustmentValue)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, label, guiStyle.gsLabel);

            rect.x += rect.width;
            rect.width /= 5;
            if (GUI.Button(rect, "<", guiStyle.gsButton))
            {
                currentValue -= adjustmentValue;
                currentValue = (currentValue < minValue) ? minValue : currentValue;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, ">", guiStyle.gsButton))
            {
                currentValue += adjustmentValue;
                currentValue = (maxValue < currentValue) ? maxValue : currentValue;
            }

            rect.x += rect.width * 4 + MyConst.GUI_WIDTH;
            rect.width = MyConst.GUI_WIDTH * 2 / 3;
            SetNumberField(rect, currentValue, ref currentValue);

            rect.x += rect.width;
            rect.width = MyConst.GUI_WIDTH * 1 / 3;
            if (GUI.Button(rect, "R", guiStyle.gsButton))
            {
                currentValue = defaultValue;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            var width = rect.width / 5;
            rect.x += rect.width + width * 3;
            rect.y += rect.height / 3;
            rect.width = width * 6;
            rect.height /= 2;
            var slider = currentValue;
            slider = GUI.HorizontalSlider(rect, slider, minValue, maxValue);
            currentValue = (currentValue != slider) ? slider : currentValue;
            return currentValue;
        }

        public int SetSelectionGrid(int baseRow, List<string> labelList,
                                    float viewRectHeight, ref Vector2 scrollPosition)
        {
            var listIndex = 0;
            if (!MyHelper.CheckNull(labelList))
            {
                listIndex = labelList.Count() - 1;
                var rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow;
                rect.width *= 4;
                rect.height = (float)Math.Ceiling(((double)labelList.Count() / (double)MyConst.GUI_GRID_COLUMN)) * rect.height;
                var viewRect = rect;
                viewRect.height = viewRectHeight;
                guiStyle.gsButton.margin = new RectOffset(0, 0, 0, 0);
                scrollPosition = GUI.BeginScrollView(viewRect, scrollPosition, rect, false, true);
                listIndex = GUI.SelectionGrid(rect, listIndex, labelList.ToArray(), MyConst.GUI_GRID_COLUMN, guiStyle.gsCombo);
                GUI.EndScrollView();
            }
            return listIndex;
        }

        public int SetCommboList(int baseRow, List<string> labelList,
                                 ref Vector2 scrollPosition, ref bool isComboOn)
        {
            var s = new List<string>(labelList);
            s.Add("");
            string[] list = s.ToArray();
            var maxIndex = s.Count() - 1;

            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            var viewRect = rect;
            rect.width *= 5;
            rect.height *= list.GetLength(0);
            viewRect.width *= 4;
            viewRect.height *= MyConst.GUI_WINDOW_ROW - baseRow - 1;
            guiStyle.gsButton.margin = new RectOffset(0, 0, 0, 0);
            scrollPosition = GUI.BeginScrollView(viewRect, scrollPosition, rect, true, true);
            var listIndex = maxIndex;
            listIndex = GUI.SelectionGrid(rect, listIndex, list, 1, guiStyle.gsCombo);
            GUI.EndScrollView();

            if (listIndex != maxIndex)
            {
                isComboOn = false;
            }
            return listIndex;
        }

        public void SetIndexChangedButton(ref Rect rect, int count, ref int index)
        {
            rect.x += rect.width;
            rect.width /= 4;
            if (GUI.Button(rect, "<", guiStyle.gsButton))
            {
                index--;
                if (0 > index)
                {
                    index = count - 1;
                }
            }
            rect.x += rect.width;
            if (GUI.Button(rect, ">", guiStyle.gsButton))
            {
                index++;
                if (index >= count)
                {
                    index = 0;
                }
            }
        }

        public void SetIndexChangedLabel(Rect rect, string label)
        {
            rect.x += rect.width;
            rect.width = MyConst.GUI_WIDTH * 2;
            GUI.Label(rect, label, guiStyle.gsLabel);
        }

        private void SetSlider(int baseRow, ref Vector3 data, float distance,
                               Vector3 st, Vector3 ed, Vector3 reset, string[] lalel)
        {
            var index = 0;
            data.x = SetSlider(baseRow + index, data.x, distance, st.x, ed.x, reset.x, lalel[index]);
            index++;
            data.y = SetSlider(baseRow + index, data.y, distance, st.y, ed.y, reset.y, lalel[index]);
            index++;
            data.z = SetSlider(baseRow + index, data.z, distance, st.z, ed.z, reset.z, lalel[index]);
        }

        private float SetSlider(int baseRow, float value, float distance, float min, float max, float reset, string lalel)
        {
            value = SetSliderArrow(baseRow, distance, min, max, value, lalel);
            value = SetSliderText(baseRow, value);
            value = SetSliderReset(baseRow, value, reset);
            value = SetSliderSlider(baseRow, min, max, value);
            return value;
        }

        private float SetSliderArrow(int baseRow, float distance, float min, float max, float value, string lalel)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width /= 4;
            GUI.Label(rect, lalel, guiStyle.gsLabel);
            rect.x += rect.width;
            if (GUI.Button(rect, "<", guiStyle.gsButton))
            {
                var pos = value - distance;
                value = (min > pos) ? min : pos;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, ">", guiStyle.gsButton))
            {
                var pos = value + distance;
                value = (max < pos) ? max : pos;
            }
            return value;
        }

        private float SetSliderText(int baseRow, int value)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.x += rect.width * 3;
            rect.width = rect.width * 2 / 3;
            SetNumberField(rect, value, ref value);
            return value;
        }

        private float SetSliderText(int baseRow, float value)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.x += rect.width * 3;
            rect.width = rect.width * 2 / 3;
            SetNumberField(rect, value, ref value);
            return value;
        }

        private float SetSliderReset(int baseRow, float value, float reset)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.x += rect.width * 3 + rect.width * 2 / 3;
            rect.width /= 3;
            if (GUI.Button(rect, "R", guiStyle.gsButton))
            {
                value = reset;
            }
            return value;
        }

        private float SetSliderSlider(int baseRow, float min, float max, float value)
        {
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.y += rect.height / 3;
            var width = rect.width / 5;
            rect.x += rect.width;
            rect.width = rect.width * 2 - width;
            rect.height /= 2;
            value = GUI.HorizontalSlider(rect, value, min, max);
            return value;
        }

    }

    /// <summary>
    /// Guiタイムラインウィンドウ管理
    /// </summary>
    public class GuiTimeLineWindowManager
    {
        public Rect WindowRect { get; set; }
        public bool IsGuiOn { get; set; }
        public bool IsEnabled { get; set; }
        public int TimeLineTypeIndex { get; set; }

        private readonly GuiManager guiMgr;
        private readonly MyGuiStyle guiStyle;
        private Vector2 scrollItem;
        private Vector2 scrollFrame;
        private Vector2 scrollTimeLine;
        private Vector2 scrollDanceList;
        private Vector2 scrollFace;

        /// <summary>
        /// コンストラクタ
        /// </summary>
        public GuiTimeLineWindowManager(GuiManager guiMgr, MyGuiStyle guiStyle)
        {
            WindowRect = MyConst.MOTION_WINDOW_RECT;
            this.guiMgr = guiMgr;
            this.guiStyle = guiStyle;
        }

        /// <summary>
        /// タイトルエリア設定
        /// </summary>
        public void SetTitleArea()
        {
            int baseRow = 0;
            var rect = MyConst.DEFAULT_RECT;
            rect.x = MyConst.MOTION_WINDOW_DRAG_RECT.width;
            rect.y *= baseRow;
            rect.width = rect.height;
            if (GUI.Button(rect, "x", guiStyle.gsButton))
            {
                IsGuiOn = false;
            }
        }

        /// <summary>
        /// ボーングループ取得
        /// </summary>
        public Dictionary<string, string> GetBoneGroup()
        {
            if (TimeLineTypeIndex == (int)MotionTimeLineType.BoneFinger)
            {
                return MyConst.BONE_NAME_FT;
            }
            else 
            {
                return MyConst.BONE_NAME_MAIN;
            }
        }

        /// <summary>
        /// トップエリア設定
        /// </summary>
        public void SetTopeArea(bool isPlay, bool isOfficialDance, string maidName, ref bool isWrite)
        {
            int baseRow = 1;
            var rect = MyConst.MENU_RECT;
            rect.y *= baseRow;
            var _IsEnabled = IsEnabled;
            IsEnabled = GUI.Toggle(rect, IsEnabled, "有効", guiStyle.gsToggle);
            if(_IsEnabled != IsEnabled)
            {
                isWrite = false;
            }
            rect.x += rect.width;
            rect.width *= 4;
            GUI.Label(rect, string.Format("(対象：{0})", maidName), guiStyle.gsLabel);

            if (IsEnabled && !isPlay)
            {
                rect = MyConst.MENU_RECT;
                rect.y *= baseRow + 1;
                GUI.Label(rect, "フレーム操作", guiStyle.gsLabel);

                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 1;
                for(int i = 0; i < MyConst.TIME_LINE_LABEL.Count(); i++)
                {
                    if( i == 1)
                    {
                        rect.width *= 3f / 4f; 
                    }
                    if(isOfficialDance && 
                      (i == (int)MotionTimeLineType.BoneBody || i == (int)MotionTimeLineType.BoneFinger))
                    {
                        continue;
                    }
                    var isSelected = GUI.Toggle(rect, i== TimeLineTypeIndex, MyConst.TIME_LINE_LABEL[i], guiStyle.gsToggle);
                    if (isSelected)
                    {
                        if(i != TimeLineTypeIndex)
                        {
                            scrollItem = Vector2.zero;
                            scrollFrame = Vector2.zero;
                            scrollTimeLine = Vector2.zero;
                        }
                        TimeLineTypeIndex = i;
                    }
                    rect.x += rect.width;
                }
            }
        }

        /// <summary>
        /// モーションエリア設定
        /// </summary>
        public bool SetMotionArea(ref TimeLinePlaySet tlPlaySet)
        {
            int baseRow = 3;
            var rect = MyConst.MENU_RECT;
            rect.y *= baseRow;
            if (!tlPlaySet.isOfficialDance)
            {
                GUI.Label(rect, "ボーン(.csv)", guiStyle.gsLabel);
            }
            rect.y += rect.height;
            GUI.Label(rect, "表情(.csv)", guiStyle.gsLabel);
            rect.y += rect.height;
            GUI.Label(rect, "カメラ(.csv)", guiStyle.gsLabel);
            rect.y += rect.height;
            if (!tlPlaySet.isOfficialDance)
            {
                GUI.Label(rect, "楽曲(.ogg,.wav)", guiStyle.gsLabel);
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            var text = string.IsNullOrEmpty(tlPlaySet.boneFile) ? "" : tlPlaySet.boneFile;
            if (!tlPlaySet.isOfficialDance)
            {
                tlPlaySet.boneFile = guiMgr.SetTextField(rect, text);
            }
            rect.x += rect.width;
            rect.width /= 2;
            var isClick = GUI.Button(rect, tlPlaySet.isWrite ? "書込" : "読込", guiStyle.gsButton);
            rect.x += rect.width;
            if (!tlPlaySet.isOfficialDance)
            {
                tlPlaySet.isAllMaids = GUI.Toggle(rect, tlPlaySet.isAllMaids, "一括", guiStyle.gsToggle);
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            rect.width *= 2;
            text = string.IsNullOrEmpty(tlPlaySet.morphFile) ? "" : tlPlaySet.morphFile;
            tlPlaySet.morphFile = guiMgr.SetTextField(rect, text);
            rect.x += rect.width;
            rect.width /= 2;
            rect.x += rect.width;
            tlPlaySet.isWrite = GUI.Toggle(rect, tlPlaySet.isWrite, "書込ON", guiStyle.gsToggle);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 2;
            rect.width *= 2;
            text = string.IsNullOrEmpty(tlPlaySet.cameraFile) ? "" : tlPlaySet.cameraFile;
            tlPlaySet.cameraFile = guiMgr.SetTextField(rect, text);
            rect.x += rect.width;
            rect.width /= 2;
            tlPlaySet.isEnabledCamera = GUI.Toggle(rect, tlPlaySet.isEnabledCamera, "カメラ有効", guiStyle.gsToggle);
            rect.x += rect.width;
            tlPlaySet.isViewAngle = GUI.Toggle(rect, tlPlaySet.isViewAngle, "視野角有効", guiStyle.gsToggle);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 3;
            rect.width *= 2;
            text = string.IsNullOrEmpty(tlPlaySet.audioFile) ? "" : tlPlaySet.audioFile;
            if (!tlPlaySet.isOfficialDance)
            {
                tlPlaySet.audioFile = guiMgr.SetTextField(rect, text);
            }
            return isClick;
        }

        /// <summary>
        /// 再生エリア設定
        /// </summary>
        public bool SetPlayArea(ref TimeLinePlaySet tlPlaySet) 
        { 
            var isClick = false;
            int baseRow = 7;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            if (GUI.Button(rect, tlPlaySet.isPlay ? "중지" : "재생", guiStyle.gsButton))
            {
                tlPlaySet.isPlay = !tlPlaySet.isPlay;
                tlPlaySet.isPause = false;
                tlPlaySet.isMorphPlay = tlPlaySet.isPlay;
                isClick = true;
            }
            rect.x += rect.width;
            if (tlPlaySet.isPlay)
            {
                if (tlPlaySet.isPlay)
                {
                    if (GUI.Button(rect, tlPlaySet.isPause ? "再開" : "一時停止", guiStyle.gsButton))
                    {
                        tlPlaySet.isPause = !tlPlaySet.isPause;
                    }
                }
                rect.x += rect.width;
                if (tlPlaySet.isLoop)
                {
                    GUI.Label(rect, "ループON", guiStyle.gsLabel);
                }
            }
            else if(!tlPlaySet.isOfficialDance)
            {
                rect.x += rect.width;
                tlPlaySet.isLoop = GUI.Toggle(rect, tlPlaySet.isLoop, "ループ", guiStyle.gsToggle);
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            if (tlPlaySet.isPlay)
            {
                rect.width *= 4;
                var label = string.Format("現在タイム (フレーム)：{0} ({1})", tlPlaySet.allPlayTime.ToString(MyConst.DECIMAL_FORMAT), MyHelper.ConvertFrame(tlPlaySet.allPlayTime));
                GUI.Label(rect, label, guiStyle.gsLabel);
            }
            else
            {
                rect.width *= 2;
                GUI.Label(rect, "開始／終了フレーム", guiStyle.gsLabel);
                rect.x += rect.width;
                rect.width /= 2;
                guiMgr.SetNumberField(rect, 0, ref tlPlaySet.fromFrame);
                rect.x += rect.width;
                guiMgr.SetNumberField(rect, 0, ref tlPlaySet.toFrame);
            }
            return isClick;
        }

        /// <summary>
        /// 公式ダンス選択
        /// </summary>
        public bool SetPlayAreaSelectedOfficialDance(ref TimeLinePlaySet tlPlaySet, List<string> danceList)
        {
            int baseRow = 10;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow - 1;
            rect.width *= 4;
            GUI.Label(rect, "選択楽曲:" + tlPlaySet.audioFile, guiStyle.gsLabel);

            var index = guiMgr.SetSelectionGrid(baseRow, danceList,
                                         MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow - 1),
                                         ref scrollDanceList);

            if (index != danceList.Count() - 1)
            {
                var fReader = new FileReader();
                var path = fReader.GetFilePath(MyConst.FILE_DANCE_LIST, "");
                var title = danceList[index];
                tlPlaySet.danceData = fReader.GetFreeDanceData(path, title, false);
                tlPlaySet.danceCameraData = fReader.GetDanceCameraMotionData(path, title, false);
                tlPlaySet.audioFile = title;
                return true;
            }
            return false;
        }

        /// <summary>
        /// 再生エリア設定（VMDファイル変換）
        /// 재생 영역 설정 (VMD 파일 변환)
        /// </summary>
        public void SetPlayAreaConvertOption(ref TimeLinePlaySet tlPlaySet)
        {
            int baseRow = 10;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "オプション", guiStyle.gsLabel);
            
            for (int i = 0; i < MyConst.MOTION_OPTION_LABEL.Count(); i++)
            {
                rect.x += rect.width;
                var isSelected = GUI.Toggle(rect, i == tlPlaySet.optionIndex, MyConst.MOTION_OPTION_LABEL[i], guiStyle.gsToggle);
                if (isSelected)
                {
                    tlPlaySet.optionIndex = i;
                }
            }
        }

        /// <summary>
        /// 再生エリア設定（VMDファイル変換）
        /// </summary>
        public bool SetPlayAreaConvertVMDData(ref TimeLinePlaySet tlPlaySet)
        {
            int baseRow = 11;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            for (int i = 0; i < MyConst.MOTION_VMD_LABEL.Count(); i++)
            {
                var isSelected = GUI.Toggle(rect, i == tlPlaySet.vmdTypeIndex, MyConst.MOTION_VMD_LABEL[i], guiStyle.gsToggle);
                if (isSelected)
                {
                    tlPlaySet.vmdTypeIndex = i;
                }
                rect.x += rect.width;
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "ファイル名", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 2;
            tlPlaySet.vmdFile = guiMgr.SetTextField(rect, tlPlaySet.vmdFile);
            rect.x += rect.width;
            rect.width /= 2;
            return GUI.Button(rect, "VMD変換", guiStyle.gsButton);
        }

        /// <summary>
        /// 再生エリア設定（ファイルフレーム調整）
        /// </summary>
        public bool SetPlayAreaAjustFileFrame(ref TimeLinePlaySet tlPlaySet)
        {
            int baseRow = 14;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            for (int i = 0; i < MyConst.MOTION_FRAME_LABEL.Count(); i++)
            {
                var isSelected = GUI.Toggle(rect, i == tlPlaySet.frameAdjustmentIndex, MyConst.MOTION_FRAME_LABEL[i], guiStyle.gsToggle);
                if (isSelected)
                {
                    tlPlaySet.frameAdjustmentIndex = i;
                }
                rect.x += rect.width;
            }
            
            if (tlPlaySet.frameAdjustmentIndex == (int)FrameAjustmentType.FrameAjustment)
            {
                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 2;
                GUI.Label(rect, "増減数", guiStyle.gsLabel);
                rect.x += rect.width;
                guiMgr.SetNumberField(rect, 0, ref tlPlaySet.adjustedFrame);
            }

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "ファイル名", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 2;
            tlPlaySet.adjustedFile = guiMgr.SetTextField(rect, tlPlaySet.adjustedFile);
            rect.x += rect.width;
            rect.width /= 2;
            return GUI.Button(rect, "フレーム調整", guiStyle.gsButton);
        }

        /// <summary>
        /// 再生エリア設定（アニメーションファイル作成）
        /// </summary>
        public bool SetPlayAreaCreateAnimation(ref TimeLinePlaySet tlPlaySet)
        {
            int baseRow = 17;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 3;
            GUI.Label(rect, "アニメーション(保存先:mypose)", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width /= 3;
            tlPlaySet.isMaidBone = GUI.Toggle(rect, tlPlaySet.isMaidBone, "メイド適用値", guiStyle.gsToggle);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            GUI.Label(rect, "ファイル名", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 2;
            tlPlaySet.animeFile = guiMgr.SetTextField(rect, tlPlaySet.animeFile);
            rect.x += rect.width;
            rect.width /= 2;
            return GUI.Button(rect, "作成", guiStyle.gsButton);
        }

        /// <summary>
        /// 再生エリア設定（モーション初期化）
        /// </summary>
        public bool SetPlayAreaInitializeMotion()
        {
            int baseRow = 19;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 2;
            return GUI.Button(rect, "タイムライン初期化", guiStyle.gsButton);
        }

        /// <summary>
        /// タイムラインファイル指定ボーン出力
        /// </summary>
        public bool SetSelectedBone(ref TimeLinePlaySet tlPlaySet)
        {
            int baseRow = 11;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "ファイル名", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width *= 2;
            tlPlaySet.boneExportFile = guiMgr.SetTextField(rect, tlPlaySet.boneExportFile);
            rect.x += rect.width;
            rect.width /= 2;
            return GUI.Button(rect, "出力", guiStyle.gsButton);
        }

        /// <summary>
        /// フレーム操作エリア設定
        /// </summary>
        public void SetFrameAreaSelecter(int startFrame, ref int selectedFrame, ref TimeLineFrameProcType procType, ref TimeLineFrameSelectType selectType)
        {
            int baseRow = 3;
            var rect = MyConst.MENU_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "　移動・指定", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 0.375f;
            if (GUI.Button(rect, "|<", guiStyle.gsButton))
            {
                selectType = TimeLineFrameSelectType.Min;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, ".<", guiStyle.gsButton))
            {
                selectType = TimeLineFrameSelectType.Before;
            }
            rect.x += rect.width;
            if (GUI.RepeatButton(rect, "<<", guiStyle.gsButton))
            {
                selectedFrame -= 1;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, "<", guiStyle.gsButton))
            {
                selectedFrame -= 1;
            }
            if (selectedFrame < 0)
            {
                selectedFrame = 0;
            }

            rect.x += rect.width;
            guiMgr.SetNumberField(rect, startFrame, ref selectedFrame);
            rect.x += rect.width;
            rect.width *= 2;
            var label = string.Format("{0}", (selectedFrame * MyConst.FRAME_CONVERSION_RATIO).ToString(MyConst.DECIMAL_FORMAT));
            GUI.Label(rect, label, guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width /= 2;
            if (GUI.Button(rect, ">", guiStyle.gsButton))
            {
                selectedFrame += 1;
            }
            rect.x += rect.width;
            if (GUI.RepeatButton(rect, ">>", guiStyle.gsButton))
            {
                selectedFrame += 1;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, ">.", guiStyle.gsButton))
            {
                selectType = TimeLineFrameSelectType.Next;
            }
            rect.x += rect.width;
            if (GUI.Button(rect, ">|", guiStyle.gsButton))
            {
                selectType = TimeLineFrameSelectType.Max;
            }
            
            if(selectedFrame < startFrame)
            {
                selectedFrame = startFrame;
            }
            else if(MyConst.MAX_MOTION_FRAME < selectedFrame)
            {
                selectType = TimeLineFrameSelectType.Max;
                selectedFrame = MyConst.MAX_MOTION_FRAME;
            }

            if(selectType != TimeLineFrameSelectType.Non)
            {
                procType = TimeLineFrameProcType.Move;
            }
        }

        /// <summary>
        /// フレームエリア設定
        /// </summary>
        public void SetFrameAreaRange(ref int startFrame, ref int maxFrame)
        {
            int baseRow = 4;
            var rect = MyConst.MENU_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "　キー表示数", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "先頭位置指定", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, startFrame, ref startFrame);
            startFrame = Mathf.Abs(startFrame);
            rect.x += rect.width;
            GUI.Label(rect, "最大数指定", guiStyle.gsLabel);
            rect.x += rect.width;
            guiMgr.SetNumberField(rect, maxFrame, ref maxFrame);
            maxFrame = Mathf.Abs(maxFrame);
        }

        public void SetFrameAreaOperation(bool isExsits, int selectedFrame, ref int copiedFrame, ref TimeLineFrameProcType procType)
        {
            if (!isExsits)
            {
                return;
            }
            int baseRow = 5;
            var rect = MyConst.MENU_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "　複製・削除", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "空フレーム指定", guiStyle.gsLabel);
            rect.x += rect.width;
            rect.width /= 2;
            guiMgr.SetNumberField(rect, 0, ref copiedFrame);
            copiedFrame = Mathf.Abs(copiedFrame);
            rect.x += rect.width;
            rect.width *= 2;
            if (GUI.Button(rect, "コピー", guiStyle.gsButton))
            {
                procType = TimeLineFrameProcType.Copy;
            }
            copiedFrame = MyConst.MAX_MOTION_FRAME < copiedFrame ? MyConst.MAX_MOTION_FRAME : copiedFrame;
            rect.x += rect.width;
            rect.x += rect.width / 2f;
            if (0 < selectedFrame && GUI.Button(rect, "選択箇所削除", guiStyle.gsButton))
            {
                procType = TimeLineFrameProcType.Delete;
            }
        }

        /// <summary>
        /// フレームエリア設定
        /// </summary>
        public void SetTimeLineAreaFrame(List<int> keyFrame)
        {
            var gsButton = new GUIStyle(GUI.skin.button);
            gsButton.fontSize = MyConst.GUI_FONT_SIZE;
            gsButton.alignment = TextAnchor.MiddleLeft;

            int baseRow = 6;
            var rect = MyConst.DEFAULT_RECT;
            var viewRect = rect;
            viewRect.y *= baseRow;
            viewRect.width *= 4;
            viewRect.height *= 2;
            rect.width = MyConst.GUI_WIDTH_TIME_LINE * (keyFrame.Count() + 1);
            scrollFrame = GUI.BeginScrollView(viewRect, scrollFrame, rect, true, false);

            rect = MyConst.DEFAULT_RECT;
            rect.y += MyConst.GUI_MARGIN;
            rect.width = MyConst.GUI_WIDTH_TIME_LINE;
            foreach (var frame in keyFrame)
            {
                GUI.Label(rect, frame.ToString(), guiStyle.gsLabel);
                rect.x += rect.width;
            }
            GUI.EndScrollView();
            scrollTimeLine.x = scrollFrame.x;
        }

        /// <summary>
        /// ボーンエリア設定
        /// </summary>
        public void SetTimeLineAreaPartsBone()
        {
            SetTimeLineAreaItem(GetBoneGroup());
        }

        /// <summary>
        /// 表情エリア設定
        /// </summary>
        public void SetTimeLineAreaPartsMorph()
        {
            SetTimeLineAreaItem(MyConst.ALL_FACIAL_MORPH);
        }

        /// <summary>
        /// 共通アイテムエリア設定
        /// </summary>
        private void SetTimeLineAreaItem(Dictionary<string, string> dic)
        {
            int baseRow = 8;
            var rect = MyConst.MENU_RECT;
            var viewRect = rect;
            viewRect.y *= baseRow;
            viewRect.height = MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow);
            viewRect.width += MyConst.GUI_MARGIN;
            rect.width *= 3;
            rect.height = dic.Count() * rect.height;
            scrollItem = GUI.BeginScrollView(viewRect, scrollItem, rect, true, true);

            rect = MyConst.MENU_RECT;
            rect.width *= 3;
            foreach (var pair in dic)
            {
                GUI.Label(rect, string.Format("{0} : {1}", pair.Value, pair.Key), guiStyle.gsLabel);
                rect.y += rect.height;
            }
            GUI.EndScrollView();
            scrollTimeLine.y = scrollItem.y;
        }

        /// <summary>
        /// 共通メインタイムライン設定
        /// </summary>
        public bool SetTimeLineAreaMain(List<int> keyFrame, Dictionary<int, List<string>> motionKeyValue, Dictionary<string, string> itemDic,
                                        ref int selectedFrame, ref string selectedName)
        {
            int baseRow = 8;
            var rect = MyConst.DEFAULT_RECT;
            var viewRect = rect;
            viewRect.y *= baseRow;
            viewRect.width *= 4;
            viewRect.height = MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - baseRow);
            rect.width = MyConst.GUI_WIDTH_TIME_LINE * (keyFrame.Count() + 1);
            rect.height = itemDic.Count() * rect.height;
            scrollTimeLine = GUI.BeginScrollView(viewRect, scrollTimeLine, rect, true, false);

            rect = MyConst.DEFAULT_RECT;
            rect.width = MyConst.GUI_WIDTH_TIME_LINE - MyConst.GUI_MARGIN;
            var isClick = false;
            foreach (var frame in keyFrame)
            {
                foreach (var item in itemDic)
                {
                    if (motionKeyValue[frame].Exists(d => d == item.Key))
                    {
                        var isSame = selectedFrame == frame && selectedName == item.Key;
                        var selected = GUI.Toggle(rect, isSame, item.Value.Substring(0, 1), guiStyle.gsToggle);
                        if (selected && (selectedFrame != frame || selectedName != item.Key))
                        {
                            selectedFrame = frame;
                            selectedName = item.Key;
                            isClick = true;
                        }
                    }
                    rect.y += rect.height;
                }
                rect.x += MyConst.GUI_WIDTH_TIME_LINE;
                rect.y = MyConst.DEFAULT_RECT.y;
            }
            GUI.EndScrollView();
            scrollFrame.x = scrollTimeLine.x;
            scrollItem.y = scrollTimeLine.y;
            return isClick;
        }

        /// <summary>
        /// 1行エリア設定
        /// </summary>
        public void SetTimeLineAreaPartsOne(string label)
        {
            int baseRow = 8;
            var rect = MyConst.MENU_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, label, guiStyle.gsLabel);
        }

        /// <summary>
        /// 1行タイムライン設定
        /// </summary>
        public void SetTimeLineAreaMainOneLine(List<int> keyFrame, ref int selectedFrame)
        {
            int baseRow = 8;
            var rect = MyConst.DEFAULT_RECT;
            var viewRect = rect;
            viewRect.y *= baseRow;
            viewRect.width *= 4;
            viewRect.height = MyConst.GUI_HEIGHT * 2;
            rect.width = MyConst.GUI_WIDTH_TIME_LINE * (keyFrame.Count() + 1);
            scrollTimeLine = GUI.BeginScrollView(viewRect, scrollTimeLine, rect, true, false);

            rect = MyConst.DEFAULT_RECT;
            rect.width = MyConst.GUI_WIDTH_TIME_LINE - MyConst.GUI_MARGIN;
            foreach (var frame in keyFrame)
            {
                var selected = GUI.Toggle(rect, selectedFrame == frame, "◆", guiStyle.gsToggle);
                if (selected && selectedFrame != frame)
                {
                    selectedFrame = frame;
                }
                rect.x += MyConst.GUI_WIDTH_TIME_LINE;
            }
            GUI.EndScrollView();
            scrollFrame.x = scrollTimeLine.x;
            scrollItem.y = scrollTimeLine.y;
        }

        /// <summary>
        /// 表情操作エリア設定（トップ）
        /// </summary>
        public bool SetFaceOperationTop(bool isExists, ref TimeLinePlaySet tlPlaySet)
        {
            int baseRow = 10;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            for (int i = 0; i < MyConst.TIMELINE_FACE_LABEL.Count(); i++)
            {
                var isSelected = GUI.Toggle(rect, i == tlPlaySet.faceTypeIndex, MyConst.TIMELINE_FACE_LABEL[i], guiStyle.gsToggle);
                if (isSelected && i != tlPlaySet.faceTypeIndex)
                {
                    tlPlaySet.faceTypeIndex = i;
                }
                rect.x += rect.width;
            }
            rect.x += rect.width;
            if (!isExists)
            {
                return GUI.Button(rect, "フレーム追加", guiStyle.gsButton);
            }
            return false;
        }

        /// <summary>
        /// 表情操作エリア設定（オプション）
        /// </summary>
        public void SetFaceOperationOption(ref string blend, ref Maid.EyeMoveType eyeMoveType, Maid maid)
        {
            int baseRow = 11;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            GUI.Label(rect, "表情オプション", guiStyle.gsLabel);

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            var index = 0;
            var result = "";
            blend = string.IsNullOrEmpty(blend) ? "" : blend;
            foreach (var pair in MyConst.FACE_OPTION_MORPH)
            {
                if (index > 0 && index % MyConst.MAX_COLUMN == 0)
                {
                    rect.y += rect.height;
                    rect.x = MyConst.DEFAULT_RECT.x;
                }
                var isSelected = blend.Contains(pair.Value.Substring(2));
                isSelected = GUI.Toggle(rect, isSelected, pair.Value, guiStyle.gsToggle);
                if (isSelected)
                {
                    result += pair.Value.Substring(2);
                }
                rect.x += rect.width;
                index++;
            }
            blend = result;

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 4;
            rect.width *= 2;
            if (GUI.Toggle(rect, eyeMoveType != (Maid.EyeMoveType)MyConst.PRE_INDEX, "メイド目線設定有効", guiStyle.gsToggle))
            {
                if(eyeMoveType == (Maid.EyeMoveType)MyConst.PRE_INDEX)
                {
                    eyeMoveType = Maid.EyeMoveType.目だけ向ける;
                }
                rect = MyConst.DEFAULT_RECT;
                rect.y *= baseRow + 5;
                index = 0;
                foreach (Maid.EyeMoveType value in Enum.GetValues(typeof(Maid.EyeMoveType)))
                {
                    if (index > 0 && index % MyConst.MAX_COLUMN == 0)
                    {
                        rect.y += rect.height;
                        rect.x = MyConst.DEFAULT_RECT.x;
                    }
                    var lable = Enum.GetName(typeof(Maid.EyeMoveType), value);
                    var isSelected = GUI.Toggle(rect, value == eyeMoveType, lable, guiStyle.gsToggle);
                    if (isSelected && value != eyeMoveType)
                    {
                        eyeMoveType = value;
                        new MaidManager().SetEyeToCamera(maid, eyeMoveType);
                    }
                    rect.x += rect.width;
                    index++;
                }
            }
            else
            {
                eyeMoveType = (Maid.EyeMoveType)MyConst.PRE_INDEX;
            }
        }

        /// <summary>
        /// 表情操作エリア設定（公式表情）
        /// </summary>
        public void SetFaceOperationOfficial(ref string face, ref int selectedFacial)
        {
            int baseRow = 11;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.width *= 4;
            GUI.Label(rect, "選択表情：" + face, guiStyle.gsLabel); ;

            rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow + 1;
            for (int i = 0; i < MyConst.MOTION_FACIAL_LABEL.Count() - 1; i++)
            {
                var isSelected = GUI.Toggle(rect, i == selectedFacial, MyConst.MOTION_FACIAL_LABEL[i], guiStyle.gsToggle);
                if (isSelected && i != selectedFacial)
                {
                    selectedFacial = i;
                }
                rect.x += rect.width;
            }

            var labels = new List<string>();
            switch (selectedFacial)
            {
                case (int)TimeLineMorphType.General:
                    labels = MyConst.FACE_GENERAL_LABEL.ToList();
                    break;
                case (int)TimeLineMorphType.Dance:
                    labels = MyConst.FACE_DANCE_LABEL.ToList();
                    break;
                case (int)TimeLineMorphType.Ero:
                    labels = MyConst.FACE_ERO_LABEL.ToList();
                    break;
            }
            labels.Add("");

            var row = baseRow + 2;
            var index = guiMgr.SetSelectionGrid(row, labels,
                        MyConst.GUI_HEIGHT * (MyConst.GUI_WINDOW_ROW - row), ref scrollFace);
            if (index != labels.Count() - 1)
            {
                face = labels[index];
            }
        }

        /// <summary>
        /// カメラ操作エリア設定（トップ）
        /// </summary>
        public bool SetCameraOperationTop(bool isExists, ref TimeLinePlaySet tlPlaySet)
        {
            int baseRow = 10;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            tlPlaySet.isEnabledCamera = GUI.Toggle(rect, tlPlaySet.isEnabledCamera, "カメラ有効", guiStyle.gsToggle);
            rect.x += rect.width;
            tlPlaySet.isViewAngle = GUI.Toggle(rect, tlPlaySet.isViewAngle, "視野角有効", guiStyle.gsToggle);

            if (tlPlaySet.isEnabledCamera && !isExists)
            {
                rect.x += rect.width * 2;
                return GUI.Button(rect, "フレーム追加", guiStyle.gsButton);
            }
            return false;
        }

        public void SetCameraOperationTop(ref MotionTimeLineSet camera)
        {
            int baseRow = 10;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            rect.x += rect.width * 2;
            if (GUI.Button(rect, "現座標設定", guiStyle.gsButton))
            {
                var tm = MyHelper.GetCameraMainTransform();
                camera.position = tm.position;
                camera.rotation = tm.eulerAngles;
                camera.distance = MyConst.CAMERA_DEFAULT;
            }
        }

        /// <summary>
        /// カメラ操作エリア設定（座標）
        /// </summary>
        public void SetCameraOperationTransform(Vector3 posReset, Vector3 rotReset, ref MotionTimeLineSet camera)
        {
            int baseRow = 11;
            var rect = MyConst.DEFAULT_RECT;
            rect.y *= baseRow;
            guiMgr.SetPositionSlider(baseRow, ref camera.position, posReset);
            guiMgr.SetRotationSlider(baseRow + 3, ref camera.rotation, rotReset);
            camera.distance = guiMgr.SetOneLineSlider("距離", baseRow + 6, camera.distance, guiMgr.TransformSlider.positionMin.z, guiMgr.TransformSlider.positionMax.z, MyConst.CAMERA_DEFAULT, MyConst.GUI_ONE_SLIDER_SMALL);
            camera.viewAngle = (int)guiMgr.SetOneLineSlider("視野角", baseRow + 7, camera.viewAngle, MyConst.ZOOM_MIN, MyConst.ZOOM_MAX, MyConst.ZOOM_DEFAULT, MyConst.GUI_ONE_SLIDER_NORMAL);
        }

        /// <summary>
        /// 再生タイムリセット
        /// </summary>
        public void ResetPlayTime(ref TimeLinePlaySet tlPlaySet)
        {
            tlPlaySet.allPlayTime = 0f;
            if (0 < tlPlaySet.fromFrame)
            {
                tlPlaySet.allPlayTime = tlPlaySet.fromFrame * MyConst.FRAME_CONVERSION_RATIO;
            }
            if (tlPlaySet.toFrame < tlPlaySet.fromFrame)
            {
                tlPlaySet.toFrame = MyConst.MAX_MOTION_FRAME;
            }
        }

        /// <summary>
        /// 再生タイム設定
        /// </summary>
        public void SetPlayTime(ref TimeLinePlaySet tlPlaySet)
        {
            if (!tlPlaySet.isPause && !tlPlaySet.isLoop)
            {
                tlPlaySet.allPlayTime += Time.deltaTime;
                tlPlaySet.isPlay =
                    !(0 < tlPlaySet.toFrame && tlPlaySet.toFrame * MyConst.FRAME_CONVERSION_RATIO < tlPlaySet.allPlayTime ||
                        MyConst.MAX_MOTION_FRAME * MyConst.FRAME_CONVERSION_RATIO < tlPlaySet.allPlayTime);
            }
        }
    }

    /// <summary>
    /// ウィンドウ管理
    /// </summary>
    public class WindowManager
    {
        private readonly int[] width;
        private readonly int[] height;

        public WindowManager(int[] width, int[] height)
        {
            this.width = width;
            this.height = height;
        }
        
        public void ChangeWindow(int index)
        {
            GameMain.Instance.CMSystem.SetScreenSize(new Size<int>(width[index], height[index]));
            GameMain.Instance.CMSystem.ConfigScreenApply();
        }

        public Size<int> GetScreenSize()
        {
            return GameMain.Instance.CMSystem.GetScreenSizeNow();
        }

    }

    /// <summary>
    /// ファイル入力処理
    /// </summary>
    public class FileReader
    {
        /// <summary>
        /// ファイルフルパス取得
        /// </summary>
        public string GetFilePath(string fileName, string subFoldarName)
        {
            var filePath = "";
            if (!string.IsNullOrEmpty(fileName))
            {
                filePath = MyHelper.RootFolder;
                if (!string.IsNullOrEmpty(subFoldarName))
                {
                    filePath = Path.Combine(filePath, subFoldarName);
                }
                filePath = CheckFilePath(Path.Combine(filePath, fileName));
            }
            return filePath;
        }

        /// <summary>
        /// ファイルリスト取得
        /// </summary>
        public IEnumerable<string> GetFileList(string folderPath)
        {
            var di = new DirectoryInfo(folderPath);
            var files = di.GetFiles()
                          .Where(w => w.Name.Contains(MyConst.EXTENSION_ANM))
                          .OrderBy(f => f.FullName)
                          .Select(s => s.FullName);
            return files;
        }

        /// <summary>
        /// ファイルフルパス確認
        /// </summary>
        public string CheckFilePath(string filePath)
        {
            if (!File.Exists(@filePath))
            {
                Console.WriteLine(string.Format("ファイルがありません：{0}", filePath));
                filePath = "";
            }
            return filePath;
        }

        /// <summary>
        /// モーションファイル一覧取得
        /// </summary>
        public List<string> GetCameraLists(string folderPath)
        {
            List<string> motionList = new List<string>();
            motionList.AddRange(System.IO.Directory.GetFiles(@folderPath, "*" + MyConst.EXTENSION_CSV));
            if (MyHelper.CheckNull(motionList))
            {
                motionList.Add("");
            }
            else
            {
                motionList.Sort();
            }
            return motionList;
        }

        /// <summary>
        /// ダンス／ソングリストラベル取得
        /// </summary>
        public List<string> GetFreeDanceLabel(string filePath, bool isSong)
        {
            var firstElement = isSong ? "SongList" : "DanceList";
            var secondElement = isSong ? "song" : "dance";
            var elements = XDocument.Load(@filePath).Element(firstElement).Elements(secondElement);
            return GetLabel(elements, false);
        }

        /// <summary>
        /// ダンス／ソングリストグループラベル取得
        /// </summary>
        public List<string> GetFreeDanceGroupLabel(string filePath, bool isSong)
        {
            var firstElement = isSong ? "SongListGroup" : "DanceListGroup";
            var secondElement = isSong ? "songList" : "danceList";
            var elements = XDocument.Load(@filePath).Element(firstElement).Elements(secondElement);
            return GetLabel(elements, false);
        }

        /// <summary>
        /// ランダム表情設定ラベル取得
        /// </summary>
        public List<string> GetRandomFaceLabel(string filePath)
        {
            var elements = XDocument.Load(@filePath).Element("MaidRandomFace").Elements("faceGroup");
            return GetLabel(elements, false);
        }

        /// <summary>
        /// カスタム表情設定ラベル取得
        /// </summary>
        public List<string> GetCustomFaceLabel(string filePath)
        {
            var elements = XDocument.Load(@filePath).Element("MaidCustomFace").Elements("customFace");
            return GetLabel(elements, true);
        }

        /// <summary>
        /// 衣装ラベル取得
        /// </summary>
        public List<string> GetDressLabel(string filePath)
        {
            var elements = XDocument.Load(@filePath).Element("MaidDress").Elements("dress");
            return GetLabel(elements, true);
        }

        /// <summary>
        /// 衣装グループラベル取得
        /// </summary>
        public List<string> GetDressGroupLabel(string filePath)
        {
            var elements = XDocument.Load(@filePath).Element("MaidDressGroup").Elements("dressGroup");
            return GetLabel(elements, false);
        }

        /// <summary>
        /// 衣装メニューラベル取得
        /// </summary>
        public List<string> GetDressMenuLabel(string filePath)
        {
            var elements = XDocument.Load(@filePath).Element("MaidDressMenu").Elements("dressMenu");
            return GetLabel(elements, true);
        }

        /// <summary>
        /// 髪ラベル取得
        /// </summary>
        public List<string> GetHairMenuLabel(string filePath)
        {
            var elements = XDocument.Load(@filePath).Element("MaidHairMenu").Elements("hairMenu");
            return GetLabel(elements, true);
        }

        /// <summary>
        /// ぶっかけラベル取得
        /// </summary>
        public List<string> GetBukkakeMenuLabel(string filePath)
        {
            var elements = XDocument.Load(@filePath).Element("MaidBukkake").Elements("bukkakes");
            return GetLabel(elements, true);
        }

        /// <summary>
        /// 動くメイドラベル取得
        /// </summary>
        public List<string> GetMovingLabel(string filePath)
        {
            var elements = XDocument.Load(@filePath).Element("MaidMoving").Elements("moveSet");
            return GetLabel(elements, true);
        }

        /// <summary>
        /// スポットライト設定ラベル取得
        /// </summary>
        public List<string> GetSpotLightLabel(string filePath)
        {
            var elements = XDocument.Load(@filePath).Element("Light").Element("SpotLights").Elements("spotLightGroup");
            return GetLabel(elements, false);
        }

        /// <summary>
        /// ポイントライト設定ラベル取得
        /// </summary>
        public List<string> GetPointLightLabel(string filePath)
        {
            var elements = XDocument.Load(@filePath).Element("Light").Element("PointLights").Elements("pointLightGroup");
            return GetLabel(elements, false);
        }

        /// <summary>
        /// 舞台道具設定ラベル取得
        /// </summary>
        public List<string> GetStageObjectLabel(string filePath)
        {
            var elements = XDocument.Load(@filePath).Element("StageObject").Elements("objectGroup");
            return GetLabel(elements, true);
        }

        /// <summary>
        /// モデル設定ラベル取得
        /// </summary>
        public List<string> GetStageModelLabel(string filePath)
        {
            var elements = XDocument.Load(@filePath).Element("StageModel").Elements("modelGroup");
            return GetLabel(elements, true);
        }

        /// <summary>
        /// パーティクル設定ラベル取得
        /// </summary>
        public List<string> GetStageBubbleLameLabel(string filePath)
        {
            var elements = XDocument.Load(@filePath).Element("StageParticle").Elements("particle");
            return GetLabel(elements, true);
        }

        /// <summary>
        /// 背景パーツラベル取得
        /// </summary>
        public List<string> GetBgPartsLabel(string filePath)
        {
            var elements = XDocument.Load(@filePath).Element("BackgroundParts").Elements("partsGroup");
            return GetLabel(elements, true);
        }

        /// <summary>
        /// オートカメララベル取得
        /// </summary>
        public List<string> GetAutoCameraLabel(string filePath)
        {
            var elements = XDocument.Load(@filePath).Element("AutoCamera").Elements("autos");
            return GetLabel(elements, true);
        }

        /// <summary>
        /// ラベル取得
        /// </summary>
        private List<string> GetLabel(IEnumerable<XElement> elements, bool isAddBlank)
        {
            var data = new List<string>();
            foreach (var element in elements)
            {
                data.Add(GetAttribute(element, "label"));
            }
            if (MyHelper.CheckNull(data) || isAddBlank)
            {
                data.Add("");
            }
            return data;
        }

        /// <summary>
        /// ダンスリストデータ取得
        /// </summary>
        public List<FreeDanceSet> GetFreeDanceData(string filePath, string title, bool isSong)
        {
            try
            {
                var firstElement = isSong ? "SongList" : "DanceList";
                var secondElement = isSong ? "song" : "dance";

                var danceData = new List<FreeDanceSet>();
                var table = XDocument.Load(@filePath).Element(firstElement);
                filePath = Path.GetDirectoryName(filePath);
                foreach (var dance in table.Elements(secondElement))
                {
                    if (title == GetAttribute(dance, "label"))
                    {
                        var changeFolder = MyConst.FOLDER_GHANGE;
                        var songFolder = "";
                        if (isSong)
                        {
                           songFolder = GetElement(dance, "folder");
                           changeFolder = Path.Combine(MyConst.FOLDER_SONG, songFolder);
                        }

                        foreach (var maid in dance.Elements("maid"))
                        {
                            var isCustomAnm = false;
                            var data = new FreeDanceSet();
                            data.type = GetAttribute(dance, "type").ToUpper();
                            data.bgmName = GetElement(dance, "bgm");
                            data.maidTransform = GetElement(dance, "maidTransform");
                            data.startTime = GetElement(dance, "startTime", 0f);
                            data.endTime = GetElement(dance, "endTime", 0f);
                            data.activeSlotNo = GetAttribute(maid, "slotNo", 0);
                            data.animation = GetElement(maid, "animation");
                            if (string.IsNullOrEmpty(data.animation))
                            {
                                data.animation = GetElement(maid, "customAnimation");
                                isCustomAnm = !string.IsNullOrEmpty(data.animation);
                            }
                            data.isMabatakiOn = GetElement(maid, "isMabatakiOn", 0) == MyConst.FILE_TRUE ? true : false;
                            data.changeMaid = null;
                            data.changeBg = null;
                            data.changePng = null;
                            data.animationList = null;
                            data.face = null;
                            data.mouth = "";
                            data.isMorphOn = false;
                            data.movieLabel = GetElement(dance, "movie");
                            data.changeItem = GetElement(dance, "changeItem");
                            data.changeDress = GetElement(dance, "changeDress");
                            data.changeUndress = GetElement(dance, "changeUndress");
                            data.changePrefab = GetElement(dance, "changePrefab");
                            data.changeMaidPrefab = GetElement(dance, "changeMaidPrefab");
                            data.changePrimitive = GetElement(dance, "changePrimitive");
                            data.changeParticle = GetElement(dance, "changeParticle");
                            data.changeLight = GetElement(dance, "changeLight");

                            var fileName = GetElement(dance, "changeMaid");
                            if (!string.IsNullOrEmpty(fileName))
                            {
                                var path = GetFilePath(fileName, changeFolder);
                                if (!string.IsNullOrEmpty(path))
                                {
                                    data.changeMaid = ReadDanceCahngeMaidData(path);
                                }
                            }

                            if (MyHelper.CheckNull(danceData))
                            {
                                fileName = GetElement(dance, "changeBg");
                                if (!string.IsNullOrEmpty(fileName))
                                {
                                    if (fileName == MyConst.BG_DELETE)
                                    {
                                        var bg = new DanceBgSet();
                                        bg.bgName = fileName;
                                        data.changeBg = new List<DanceBgSet>();
                                        data.changeBg.Add(bg);
                                    }
                                    else
                                    {
                                        var path = GetFilePath(fileName, changeFolder);
                                        if (!string.IsNullOrEmpty(path))
                                        {
                                            data.changeBg = ReadDanceCahngeBgData(path);
                                        }
                                    }
                                }
                                var e = dance.Element("changeBgColor");
                                if(e != null)
                                {
                                    data.changeBgColor = new Vector4(
                                        GetAttribute(e, "r", 0f),
                                        GetAttribute(e, "g", 0f),
                                        GetAttribute(e, "b", 0f),
                                        MyConst.COLOR_MAX) / MyConst.COLOR_MAX;
                                }
                                else
                                {
                                    data.changeBgColor = MyHelper.GetCameraMain().backgroundColor;
                                }
                                fileName = GetElement(dance, "changePng");
                                if (!string.IsNullOrEmpty(fileName))
                                {
                                    var path = GetFilePath(fileName, changeFolder);
                                    if (!string.IsNullOrEmpty(path))
                                    {
                                        data.changePng = ReadDanceCahngePngData(path);
                                    }
                                }
                            }

                            fileName = GetElement(maid, "animationList");
                            if (!string.IsNullOrEmpty(fileName))
                            {
                                var path = GetFilePath(fileName, MyConst.FOLDER_ANIMATION);
                                if (!string.IsNullOrEmpty(path))
                                {
                                    data.animationList = ReadDanceAnimationData(path);
                                }
                            }
                            var element = maid.Element("randomFace");
                            if (element !=null)
                            {
                                var start = GetAttribute(element, "startTime", 0f);
                                var end = GetAttribute(element, "endTime", 0f);
                                var currentTime = 0f;
                                var face = MyConst.DANCE_FACE_EYE_CLOSE;
                                data.face = new List<DanceFaceSet>();
                                data.face.Add(SetRandomFace(0, face, false));
                                data.face.Add(SetRandomFace(end + MyConst.FACE_RANDOM_TIME_MIN, face, false));
                                while (currentTime < end)
                                {
                                    if(currentTime < start)
                                    {
                                        currentTime = start;
                                        face = MyConst.DANCE_FACE_EYE_OPEN;
                                    }
                                    else
                                    {
                                        currentTime += MyHelper.GetRandomFloat(MyConst.FACE_RANDOM_TIME_MIN, MyConst.FACE_RANDOM_TIME_MAX);
                                        var f = MyConst.FACE_DANCE_RANDOM.Where(d => d != face).ToList();
                                        var index = MyHelper.GetRandomIndex(f.Count());
                                        face = f[index];
                                    }
                                    var isHoho = MyHelper.GetRandomIndex(10) == 0;
                                    data.face.Add(SetRandomFace(currentTime, face, isHoho));
                                }
                                data.face = data.face.OrderBy(d => d.time).ToList();
                            }
                            else
                            {
                                fileName = GetElement(maid, "face");
                                if (!string.IsNullOrEmpty(fileName))
                                {
                                    var path = GetFilePath(fileName, isSong ? changeFolder : MyConst.FOLDER_FACE);
                                    if (!string.IsNullOrEmpty(path))
                                    {
                                        data.face = ReadDanceFaceData(path);
                                    }
                                }
                            }

                            fileName = GetElement(maid, "mouth");
                            if (!string.IsNullOrEmpty(fileName))
                            {
                                var path = GetFilePath(fileName, MyConst.FOLDER_MOUTH);
                                if (!string.IsNullOrEmpty(path))
                                {
                                    data.mouth = ReadDanceMouthData(path);
                                }
                            }

                            data.transform = new MyTransform();
                            data.transform.stPos
                                    = new Vector3(GetElement(maid, "positionX", 0f),
                                                  GetElement(maid, "positionY", 0f),
                                                  GetElement(maid, "positionZ", 0f));
                            data.transform.stRot
                                = new Vector3(GetElement(maid, "rotationX", 0f),
                                              GetElement(maid, "rotationY", 0f),
                                              GetElement(maid, "rotationZ", 0f));

                            if (isSong)
                            {
                                data.songSet = new FreeSongSet();
                                data.songSet.folder = songFolder;
                                data.songSet.metronome = GetElement(dance, "metronome", MyConst.METRONOME);
                                data.songSet.baseNote = GetElement(dance, "baseNote", MyConst.BASE_NOTE);
                                data.songSet.animationSpeed = GetElement(dance, "animationSpeed", MyConst.ANIMATION_SPEED);
                                data.songSet.isCommonPose = GetElement(dance, "isCommonPose", 0) == MyConst.FILE_TRUE ? true : false;
                                data.songSet.pose = GetElement(maid, "pose");
                                if (string.IsNullOrEmpty(data.songSet.pose))
                                {
                                    data.songSet.pose = GetElement(maid, "bone");
                                    data.songSet.isTlBone = !string.IsNullOrEmpty(data.songSet.pose);
                                }
                                else
                                {
                                    data.songSet.poseLoop = GetElement(maid, "poseLoop");
                                }
                                data.songSet.lyrics = GetElement(maid, "lyrics");
                                data.songSet.morph = GetElement(maid, "morph");
                                data.songSet.isCustomAnm = isCustomAnm;
                                var movie = dance.Element("movie");
                                if(movie != null)
                                {
                                    data.songSet.movieName = GetElement(movie, "movieName");
                                    data.songSet.volume = GetElement(movie, "volume", MyConst.VOLUME_MAX);
                                    data.songSet.isMute = GetElement(movie, "isMute", 0) == MyConst.FILE_TRUE ? true : false;
                                    var e = movie.Element("position");
                                    data.songSet.position = new Vector3(GetAttribute(e, "x", 0f),
                                                                         GetAttribute(e, "y", 0f),
                                                                         GetAttribute(e, "z", 0f));
                                    e = movie.Element("rotation");
                                    data.songSet.rotation = new Vector3(GetAttribute(e, "x", 0f),
                                                                         GetAttribute(e, "y", 0f),
                                                                         GetAttribute(e, "z", 0f));
                                    e = movie.Element("scale");
                                    data.songSet.scale = new Vector3(GetAttribute(e, "x", 0f),
                                                                     GetAttribute(e, "y", 0f),
                                                                     GetAttribute(e, "z", 0f));
                                }
                                else
                                {
                                    data.songSet.movieName = "";
                                }
                            }

                            danceData.Add(data);
                            danceData.Sort((a, b) => a.activeSlotNo - b.activeSlotNo);
                        }
                        break;
                    }
                }
                return danceData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// ダンスリストデータ取得（男）
        /// </summary>
        public List<FreeSongManSet> GetFreeDanceManData(string filePath, string title)
        {
            try
            {
                var data = new List<FreeSongManSet>();
                var table = XDocument.Load(@filePath).Element("SongList");
                filePath = Path.GetDirectoryName(filePath);
                foreach (var dance in table.Elements("song"))
                {
                    if (title == GetAttribute(dance, "label"))
                    {
                        var songFolder = Path.Combine(MyConst.FOLDER_SONG, GetElement(dance, "folder"));
                        foreach (var m in dance.Elements("man"))
                        {
                            var man = new FreeSongManSet();
                            man.slotNo = GetAttribute(m, "slotNo", 0);
                            man.pose = Path.Combine(songFolder, GetElement(m, "pose"));
                            man.position
                                = new Vector3(GetElement(m, "positionX", 0f),
                                                GetElement(m, "positionY", 0f),
                                                GetElement(m, "positionZ", 0f));
                            man.rotation
                                = new Vector3(GetElement(m, "rotationX", 0f),
                                              GetElement(m, "rotationY", 0f),
                                              GetElement(m, "rotationZ", 0f));
                            data.Add(man);
                        }
                        break;
                    }
                }
                return data;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }


        private DanceFaceSet SetRandomFace(float time, string face, bool isHoho)
        {
            var data = new DanceFaceSet();
            data.time = time;
            data.face = face;
            data.blend = MyConst.DEFAULT_BLEND;
            data.faceOpMorph = new Dictionary<string, float>();
            if (isHoho)
            {
                data.faceOpMorph[MyConst.FACE_OPTION_HOHO1] = MyConst.FACE_BLEND_VALUE;
            }
            data.eyeMoveType = (Maid.EyeMoveType)MyConst.PRE_INDEX;
            return data;
        }

        /// <summary>
        /// ダンスカメラモーションデータ取得
        /// </summary>
        public List<DanceCameraMotionSet> GetDanceCameraMotionData(string filePath, string title, bool isSong)
        {
            try
            {
                var firstElement = isSong ? "SongList" : "DanceList";
                var secondElement = isSong ? "song" : "dance";

                var screenData = new List<DanceCameraMotionSet>();
                var table = XDocument.Load(@filePath).Element(firstElement);
                foreach (var dance in table.Elements(secondElement))
                {
                    if (title == GetAttribute(dance, "label"))
                    {
                        var data = SetDanceCameraMotion(dance, isSong, true, "");
                        screenData.Add(data);

                        foreach (var screen in dance.Elements("screen"))
                        {
                            data = SetDanceCameraMotion(screen, isSong, false, GetElement(dance, "folder"));
                            data.position = new Vector3(GetElement(screen, "positionX", 0f),
                                                        GetElement(screen, "positionY", 0f),
                                                        GetElement(screen, "positionZ", 0f));
                            data.rotation = new Vector3(GetElement(screen, "rotationX", 0f),
                                                        GetElement(screen, "rotationY", 0f),
                                                        GetElement(screen, "rotationZ", 0f));
                            data.scale = new Vector3(GetElement(screen, "scaleX", 1f),
                                                     GetElement(screen, "scaleY", 1f),
                                                     GetElement(screen, "scaleZ", 1f));
                            data.addtionalPositionZ = GetElement(screen, "addtionalPositionZ", 0f);
                            data.isScreen = true;
                            screenData.Add(data);
                        }
                        break;
                    }
                }
                return screenData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        private DanceCameraMotionSet SetDanceCameraMotion(XElement element, bool isSong, bool isMain, string subFolder)
        {
            var data = new DanceCameraMotionSet();
            var motion = GetElement(element, "customMotion");
            if (!string.IsNullOrEmpty(motion))
            {
                data.motionName = motion;
                data.isCustomMotion = true;
            }
            else
            {
                data.motionName = GetElement(element, "motion");
            }
            if (!string.IsNullOrEmpty(data.motionName))
            {
                if (isSong)
                {
                    var folder = data.isCustomMotion ? MyConst.FOLDER_TIMELINE : MyConst.FOLDER_SONG;
                    if (isMain)
                    {                        
                        data.subFolder = Path.Combine(folder, GetElement(element, "folder"));
                    }
                    else
                    {
                        data.subFolder = Path.Combine(folder, subFolder);
                    }
                }
                else
                {
                    data.subFolder = MyConst.FOLDER_MOTION;
                }
                if (isMain)
                {
                    data.camera = MyHelper.GetCameraMain();
                }
                data.isMotionOn = true;
                data.cameraMgr = new CameraManager();
            }
            return data;
        }

        /// <summary>
        /// ダンスグループデータ取得
        /// </summary>
        public FreeDanceGroupSet GetDanceGroupData(string filePath, string title, bool isSong)
        {
            var firstElement = isSong ? "SongListGroup" : "DanceListGroup";
            var secondElement = isSong ? "songList" : "danceList";
            var thirdElement = isSong ? "song" : "dance";

            var group = new FreeDanceGroupSet();
            try
            {
                var table = XDocument.Load(@filePath).Element(firstElement);
                foreach (var row in table.Elements(secondElement))
                {
                    if (title == GetAttribute(row, "label"))
                    {
                        group.playType = GetAttribute(row, "playType", MyConst.DANCE_PLAY_NORMAL);
                        group.danceLabel = new List<string>();
                        foreach (var dance in row.Elements(thirdElement))
                        {
                            group.danceLabel.Add(GetAttribute(dance, "label"));
                        }
                        break;
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return group;
        }

        /// <summary>
        /// PNGファイル取得（スプライト）
        /// </summary>
        public Dictionary<string, SpriteRenderer> GetPngFile(List<DancePngSet> changePng, SpriteSet spriteSet)
        {
            var sRenderer = new Dictionary<string, SpriteRenderer>();
            foreach (var data in changePng)
            {
                var key = data.pngName;
                if (!sRenderer.ContainsKey(key))
                {
                    var path = GetFilePath(key, MyConst.FOLDER_PNG);
                    if (!string.IsNullOrEmpty(path))
                    {
                        var texture = ReadPngTexture(path);
                        var sr = new GameObject(key).AddComponent<SpriteRenderer>();
                        sr.sprite = Sprite.Create(texture, new Rect(spriteSet.rectX, spriteSet.rectY, texture.width, texture.height),
                                                           new Vector2(spriteSet.pivotX, spriteSet.pivotY));
                        sr.enabled = false;
                        sRenderer[key] = sr;
                    }
                }
            }
            return sRenderer;
        }

        /// <summary>
        /// テクスチャー読込(Primitive)
        /// </summary>
        public Dictionary<string, Texture2D> GetPngTexturFile(List<string> textureList, string folderPath)
        {
            var textureData = new Dictionary<string, Texture2D>();
            foreach (var key in textureList)
            {
                if (!textureData.ContainsKey(key))
                {
                    var path = CheckFilePath(Path.Combine(folderPath, key));
                    if (!string.IsNullOrEmpty(path))
                    {
                        textureData[key] = ReadPngTexture(path);
                    }
                }
            }
            return textureData;
        }

        /// <summary>
        /// PNGファイル読み込み
        /// </summary>
        public Texture2D ReadPngTexture(string path)
        {
            int pos = 16;
            int width = 0;
            int height = 0;

            var readBinary = ReadBinary(path);
            for (int i = 0; i < 4; i++)
            {
                width = width * 256 + readBinary[pos++];
            }
            for (int i = 0; i < 4; i++)
            {
                height = height * 256 + readBinary[pos++];
            }

            var texture = new Texture2D(width, height);
            texture.LoadImage(readBinary);
            texture.filterMode = FilterMode.Point;
            return texture;
        }

        /// <summary>
        /// スカイボックス用ファイル読み込み
        /// </summary>
        public Texture2D ReadSkyboxTexture(string path)
        {
            var readBinary = ReadBinary(path);
            var texture = new Texture2D(0, 0);
            texture.LoadImage(readBinary);
            return texture;
        }

        /// <summary>
        /// バイナリーデータ読み込み
        /// </summary>
        public byte[] ReadBinary(string path)
        {
            byte[] readBinary;
            using (FileStream fs = new FileStream(path, FileMode.Open, FileAccess.Read))
            {
                BinaryReader bin = new BinaryReader(fs);
                readBinary = bin.ReadBytes((int)bin.BaseStream.Length);
                bin.Close();
            }
            return readBinary;
        }

        /// <summary>
        /// 設定ファイル取得（Gui）
        /// </summary>
        public GuiSet GetSettingOfGui(string filePath, GuiSet gui)
        {
            try
            {
                var element = XDocument.Load(@filePath).Element("Setting").Element("Gui");
                gui.isMaidsDanceOn = GetElement(element, "isMaidsDanceOn", 0) == MyConst.FILE_TRUE ? true : false;

                var swing = element.Element("isMaidsSwingOn");
                gui.isMaidsSwingMuneOn = GetElement(swing, "mune", 0) == MyConst.FILE_TRUE ? true : false;
                gui.isMaidsSwingHairOn = GetElement(swing, "hair", 0) == MyConst.FILE_TRUE ? true : false;
                gui.isMaidsSwingDressOn = GetElement(swing, "dress", 0) == MyConst.FILE_TRUE ? true : false;

                gui.isMaidsEyesOn = GetElement(element, "isMaidsEyesOn", 0) == MyConst.FILE_TRUE ? true : false;
                gui.isGuiAutoOff = GetElement(element, "isGuiAutoOff", 0) == MyConst.FILE_TRUE ? true : false;
                gui.isUiAutoOff = GetElement(element, "isUiAutoOff", 0) == MyConst.FILE_TRUE ? true : false;
                gui.isGearOn = GetElement(element, "isGearOn", 0) == MyConst.FILE_TRUE ? true : false;
                gui.isFadeOn = GetElement(element, "isFadeOn", 0) == MyConst.FILE_TRUE ? true : false;
                gui.fadeInTime = GetElement(element, "fadeInTime", MyConst.DANCE_FADE_TIME);
                gui.fadeOutTime = GetElement(element, "fadeOutTime", MyConst.DANCE_FADE_TIME);
                var color = element.Element("backgroundColor");
                var isEnabled = GetAttribute(color, "enabled", MyConst.FILE_TRUE);
                gui.isBackgroundEnabled = isEnabled == MyConst.FILE_TRUE ? true : false;
                gui.backgroundColor = new Vector4(
                                            GetElement(color, "colorR", MyConst.COLOR_MIN),
                                            GetElement(color, "colorG", MyConst.COLOR_MIN),
                                            GetElement(color, "colorB", MyConst.COLOR_MIN),
                                            GetElement(color, "colorA", MyConst.GUI_WINDOW_ALPHA));
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return gui;
        }

        /// <summary>
        /// 設定ファイル取得（GameWindow）
        /// </summary>
        public WindowManager GetSettingOfGameWindow(string filePath)
        {
            WindowManager data;
            var max = MyConst.GUI_CHANGE_WINDOW_BUTTON;
            var width = new int[max];
            var height = new int[max];
            try
            {
                var element = XDocument.Load(@filePath).Element("Setting").Element("GameWindow");
                for (int i = 0; i < max; i++)
                {
                    width[i] = GetElement(element, "width" + (i + 1), MyConst.GAME_WINDOW_WIDTH[i]);
                    height[i] = GetElement(element, "height" + (i + 1), MyConst.GAME_WINDOW_HEIGHT[i]);
                }
                data = new WindowManager(width, height);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                data = new WindowManager(MyConst.GAME_WINDOW_WIDTH, MyConst.GAME_WINDOW_HEIGHT);
            }
            return data;
        }

        /// <summary>
        /// 設定ファイル取得（Key）
        /// </summary>
        public KeySet GetSettingOfKey(string filePath)
        {
            var key = new KeySet();
            try
            {
                var element = XDocument.Load(@filePath).Element("Setting").Element("Key");
                key.gui = GetElement(element, "gui");
                key.cameraForward = GetElement(element, "cameraForward");
                key.cameraBack = GetElement(element, "cameraBack");
                key.cameraLeft = GetElement(element, "cameraLeft");
                key.cameraRight = GetElement(element, "cameraRight");
                key.cameraUp = GetElement(element, "cameraUp");
                key.cameraDown = GetElement(element, "cameraDown");
                key.movingForward = GetElement(element, "movingForward");
                key.movingUp = GetElement(element, "movingUp");
                key.movingDown = GetElement(element, "movingDown");
                key.movingLeftRotation = GetElement(element, "movingLeftRotation");
                key.movingRightRotation = GetElement(element, "movingRightRotation");
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                key.gui = MyConst.DEFAULT_KEY_GUI;
                key.cameraForward = MyConst.DEFAULT_KEY_FORWARD;
                key.cameraBack = MyConst.DEFAULT_KEY_BACK;
                key.cameraLeft = MyConst.DEFAULT_KEY_LEFT;
                key.cameraRight = MyConst.DEFAULT_KEY_RIGHT;
                key.cameraUp = MyConst.DEFAULT_KEY_UP;
                key.cameraDown = MyConst.DEFAULT_KEY_DOWN;
                key.movingForward = MyConst.DEFAULT_KEY_MOVE_FORWARD;
                key.movingUp = MyConst.DEFAULT_KEY_MOVE_UP;
                key.movingDown = MyConst.DEFAULT_KEY_MOVE_DOWN;
                key.movingLeftRotation = MyConst.DEFAULT_KEY_MOVE_LEFT;
                key.movingRightRotation = MyConst.DEFAULT_KEY_MOVE_RIGHT;
            }
            return key;
        }

        /// <summary>
        /// 設定ファイル取得（Foreground）
        /// </summary>
        public void GetSettingOfForeground(string filePath, ref FreeForegroundSet[] foregroundSet, ref Dictionary<int, FreeMaidMaskSet> maskDic)
        {
            try
            {
                foregroundSet = new FreeForegroundSet[MyConst.FOREGROUND_MAX];
                for (int i = 0; i < foregroundSet.Count(); i++)
                {
                    foregroundSet[i].alpha = MyConst.COLOR_MAX;
                }
                maskDic = new Dictionary<int, FreeMaidMaskSet>();
                foreach (int key in Enum.GetValues(typeof(MaidMaskParam)))
                {
                    var data = new FreeMaidMaskSet();
                    data.color = new Color32(MyConst.COLOR_MAX, MyConst.COLOR_MAX, MyConst.COLOR_MAX, MyConst.COLOR_MAX);
                    maskDic[key] = data;
                }

                var element = XDocument.Load(@filePath).Element("Setting").Element("Foreground").Elements("mask");
                foreach (var mask in element)
                {
                    var type = GetAttribute(mask, "type");
                    switch (type)
                    {
                        case "foreground":
                            foregroundSet[0].pngName = GetElement(mask, "pngName");
                            foregroundSet[0].isFixedSize = GetElement(mask, "isFixedSize", 0) == MyConst.FILE_TRUE ? true : false;
                            foregroundSet[0].width = GetElement(mask, "width", 0);
                            foregroundSet[0].height = GetElement(mask, "height", 0);
                            foregroundSet[0].alpha = GetElement(mask, "colorA", 1f);
                            break;
                        case "nip":
                        case "vag":
                            var data = new FreeMaidMaskSet();
                            data.pngName = GetElement(mask, "pngName");
                            data.width = GetElement(mask, "width", 0);
                            data.height = GetElement(mask, "height", 0);
                            data.color = new Color32(
                                           GetColorElement(mask, "colorR"),
                                           GetColorElement(mask, "colorG"),
                                           GetColorElement(mask, "colorB"),
                                           GetColorElement(mask, "colorA"));
                            foreach (var key in Enum.GetValues(typeof(MaidMaskParam)))
                            {
                                if (type == Enum.GetName(typeof(MaidMaskParam), key).ToLower())
                                {
                                    maskDic[(int)key] = data;
                                    break;
                                }
                            }
                            break;
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// 設定ファイル取得（RenderTexture）
        /// </summary>
        public RenderTextureSet GetSettingOfRenderTexture(string filePath)
        {
            var data = new RenderTextureSet();
            try
            {
                var element = XDocument.Load(@filePath).Element("Setting").Element("RenderTexture");
                data.width = GetElement(element, "width", MyConst.BASE_WINDOW_WIDTH);
                data.height = GetElement(element, "height", MyConst.BASE_WINDOW_HEIGHT);
                data.isMask = GetElement(element, "isMask", 0) == MyConst.FILE_TRUE ? true : false;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                data.width = MyConst.BASE_WINDOW_WIDTH;
                data.height = MyConst.BASE_WINDOW_HEIGHT;
            }
            return data;
        }

        /// <summary>
        /// 設定ファイル取得（スポットライト）
        /// </summary>
        public FreeLightSet GetSettingOfSpotLight(string filePath)
        {
            var data = new FreeLightSet();
            try
            {
                var element = XDocument.Load(@filePath).Element("Setting").Element("Light").Element("spotLight");
                data.color = new Color32(
                    GetColorElement(element, "colorR"),
                    GetColorElement(element, "colorG"),
                    GetColorElement(element, "colorB"),
                    MyConst.COLOR_MAX);
                data.position = new Vector3(
                    GetElement(element, "positionX", MyConst.CAMERA_DEFAULT),
                    GetElement(element, "positionY", MyConst.CAMERA_DEFAULT),
                    GetElement(element, "positionZ", MyConst.CAMERA_DEFAULT));
                data.rotation = new Vector3(
                    GetElement(element, "rotationX", MyConst.CAMERA_DEFAULT),
                    GetElement(element, "rotationY", MyConst.CAMERA_DEFAULT),
                    GetElement(element, "rotationXZ", MyConst.CAMERA_DEFAULT));
                data.intensity = GetElement(element, "intensity", MyConst.LIGHT_INTENSITY);
                data.range = GetElement(element, "range", MyConst.LIGHT_RANGE);
                data.spotAngle = GetElement(element, "spotAngle", MyConst.LIGHT_SPOTANGLE);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                data.color = MyHelper.SetColorWhite();
                data.position = Vector3.zero;
                data.rotation = Vector3.zero;
            }
            return data;
        }

        /// <summary>
        /// 設定ファイル取得（ポイントライト）
        /// </summary>
        public FreeLightSet GetSettingOfPointLight(string filePath)
        {
            var data = new FreeLightSet();
            try
            {
                var element = XDocument.Load(@filePath).Element("Setting").Element("Light").Element("pointLight");
                data.color = new Color32(
                    GetColorElement(element, "colorR"),
                    GetColorElement(element, "colorG"),
                    GetColorElement(element, "colorB"),
                    MyConst.COLOR_MAX);
                data.position = new Vector3(
                    GetElement(element, "positionX", MyConst.CAMERA_DEFAULT),
                    GetElement(element, "positionY", MyConst.CAMERA_DEFAULT),
                    GetElement(element, "positionZ", MyConst.CAMERA_DEFAULT));
                data.intensity = GetElement(element, "intensity", MyConst.LIGHT_INTENSITY);
                data.range = GetElement(element, "range", MyConst.LIGHT_RANGE);
                data.isFollowing = true;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                data.color = MyHelper.SetColorWhite();
                data.position = Vector3.zero;
            }
            return data;
        }

        /// <summary>
        /// 設定ファイル取得（スプライト）
        /// </summary>
        public SpriteSet GetSettingOfSprite(string filePath)
        {
            var data = new SpriteSet();
            try
            {
                var element = XDocument.Load(@filePath).Element("Setting").Element("Sprite");
                data.rectX = GetElement(element, "rectX", 0f);
                data.rectY = GetElement(element, "rectY", 0f);
                data.pivotX = GetElement(element, "pivotX", 0f);
                data.pivotY = GetElement(element, "pivotY", 0f);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return data;
        }

        /// <summary>
        /// 設定ファイル取得（人垣）
        /// </summary>
        public FreeCrowdSet GetSettingOfCrowd(string filePath, FreeCrowdSet data)
        {
            try
            {
                if (MyHelper.CheckNull(data.crowd))
                {
                    data.crowd = new List<GameObject>();
                }
                var top = XDocument.Load(@filePath).Element("Setting").Element("Crowd");
                data.layer = GetElement(top, "layer", 0);
                data.mobNumber = GetElement(top, "mobNumber", 0);
                data.centerDistance = GetElement(top, "centerDistance", 0f);
                data.mobDistanceX = GetElement(top, "mobDistanceX", 0f);
                data.mobDistanceZ = GetElement(top, "mobDistanceZ", 0f);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return data;
        }

        /// <summary>
        /// 設定ファイル取得（サイリウム）
        /// </summary>
        public FreeCyalumeSet[] GetSettingOfCyalume(string filePath)
        {
            var cyalume = new FreeCyalumeSet[MyConst.STAGE_OBJECT_CYALUME_MAX];
            try
            {
                var dataIndex = 0;
                var top = XDocument.Load(@filePath).Element("Setting").Element("Cyalumes").Elements("cyalume");
                foreach(var row in top)
                {
                    var data = new FreeCyalumeSet();
                    var element = row.Element("floor1st");
                    data.floor1st = new Vector2(
                        GetAttribute(element, "column", 0),
                        GetAttribute(element, "row", 0));
                    data.isPair1st = GetAttribute(element, "pair", 0) == MyConst.FILE_TRUE ? true : false;
                    element = row.Element("floor2nd");
                    data.floor2nd = new Vector2(
                        GetAttribute(element, "column", 0),
                        GetAttribute(element, "row", 0));
                    data.isPair2nd = GetAttribute(element, "pair", 0) == MyConst.FILE_TRUE ? true : false;
                    data.pairSpace = GetElement(row, "pairSpace", 0f);
                    element = row.Element("position1st");
                    data.position1st = new Vector3(
                        GetAttribute(element, "x", 0f),
                        GetAttribute(element, "y", 0f),
                        GetAttribute(element, "z", 0f));
                    element = row.Element("position2nd");
                    data.position2nd = new Vector3(
                        GetAttribute(element, "x", 0f),
                        GetAttribute(element, "y", 0f),
                        GetAttribute(element, "z", 0f));
                    element = row.Element("positionAdjustment");
                    data.positionAdjustment = new Vector3(
                        GetAttribute(element, "x", 0f),
                        GetAttribute(element, "y", 0f),
                        GetAttribute(element, "z", 0f));
                    element = row.Element("rotation");
                    data.rotation = new Vector3(
                        GetAttribute(element, "x", 0f),
                        GetAttribute(element, "y", 0f),
                        GetAttribute(element, "z", 0f));
                    element = row.Element("scale");
                    data.scale = new Vector3(
                        GetAttribute(element, "x", 0f),
                        GetAttribute(element, "y", 0f),
                        GetAttribute(element, "z", 0f));
                    element = row.Element("moveDistance");
                    data.moveDistance = new Vector3(
                        GetAttribute(element, "x", 0f),
                        GetAttribute(element, "y", 0f),
                        GetAttribute(element, "z", 0f));
                    data.moveTime = GetElement(row, "moveTime", 0f);
                    data.rotationAddY = GetElement(row, "rotationAddY", 0f);
                    data.fadeTime = GetElement(row, "fadeTime", 0f);
                    data.changeTime = GetElement(row, "changeTime", 0f);
                    element = row.Element("colorLeft");
                    data.color = new Color32[2];
                    data.color[0] = new Color32(
                        GetColorAttribute(element, "r"),
                        GetColorAttribute(element, "g"),
                        GetColorAttribute(element, "b"),
                        GetColorAttribute(element, "a"));
                    element = row.Element("colorRight");
                    data.color[1] = new Color32(
                        GetColorAttribute(element, "r"),
                        GetColorAttribute(element, "g"),
                        GetColorAttribute(element, "b"),
                        GetColorAttribute(element, "a"));
                    data.isRandomColors = GetElement(row, "isRandomColor", 0) == MyConst.FILE_TRUE ? true : false;
                    data.isRandomChanged = GetElement(row, "isRandomChanged", 0) == MyConst.FILE_TRUE ? true : false;
                    data.textureName = GetElement(row, "textureName");

                    cyalume[dataIndex] = data;
                    dataIndex++;
                    if (dataIndex == MyConst.STAGE_OBJECT_CYALUME_MAX) break;
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return cyalume;
        }

        /// <summary>
        /// 設定ファイル取得（注視・分割カメラ）
        /// </summary>
        public LookAtSet GetSettingOfLookAt(string filePath)
        {
            var data = new LookAtSet();
            try
            {
                var element = XDocument.Load(@filePath).Element("Setting").Element("LookAt");
                data.randomTime = GetElement(element, "randomTime", MyConst.LOOK_AT_RANDOM_TIME);
                data.distance = GetElement(element, "distance", MyConst.LOOK_AT_DISTANCE);
                data.distanceScreen = GetElement(element, "distanceScreen", MyConst.LOOK_AT_DISTANCE_SCREEN);
                data.rotateAroundTime = GetElement(element, "rotateAroundTime", MyConst.LOOK_AT_ROTATEAROUND_TIME);
                data.autoData = new MaidLookAtAutoSet[MyConst.LOOK_AT_AUTO_LABEL.Count()];
                var index = 0;
                foreach (var e in element.Elements("auto"))
                {
                    var d = new MaidLookAtAutoSet();
                    d.position = new Vector3(
                        GetAttribute(e.Element("autoPosition"), "x", 0f),
                        GetAttribute(e.Element("autoPosition"), "y", 0f),
                        GetAttribute(e.Element("autoPosition"), "z", MyConst.LOOK_AT_AUTO_MIN_Z));
                    d.autoTime = new Vector2(
                        GetAttribute(e.Element("autoTime"), "min", MyConst.LOOK_AT_AUTO_TIME),
                        GetAttribute(e.Element("autoTime"), "max", MyConst.LOOK_AT_AUTO_TIME));
                    d.isEnabled = GetAttribute(e, "isEnabled", 0) == MyConst.FILE_TRUE ? true : false;
                    data.autoData[index] = d;
                    index++;
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                data.randomTime = MyConst.LOOK_AT_RANDOM_TIME;
                data.distance = MyConst.LOOK_AT_DISTANCE;
                data.distanceScreen = MyConst.LOOK_AT_DISTANCE_SCREEN;
                data.rotateAroundTime = MyConst.LOOK_AT_ROTATEAROUND_TIME;
                var count = MyConst.LOOK_AT_AUTO_LABEL.Count();
                data.autoData = new MaidLookAtAutoSet[count];
                for (int i = 0; i < count; i++)
                {
                    data.autoData[i].position = new Vector3(0f, 0f, MyConst.LOOK_AT_AUTO_MIN_Z);
                }
            }
            return data;
        }

        /// <summary>
        /// 設定ファイル取得（ランダム脱衣）
        /// </summary>
        public DanceUndressSet GetSettingOfRandomUndress(string filePath)
        {
            var data = new DanceUndressSet();
            try
            {
                var element = XDocument.Load(@filePath).Element("Setting").Element("RandomUndress");
                data.startTime = GetElement(element, "startTime", MyConst.UNDRESS_START_TIME);
                data.interval = GetElement(element, "interval", MyConst.UNDRESS_INTERVAL);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                data.startTime = MyConst.UNDRESS_START_TIME;
                data.interval = MyConst.UNDRESS_INTERVAL;
            }
            return data;
        }

        /// <summary>
        /// 設定ファイル取得（ランダム表情）
        /// </summary>
        public MaidRandomFaceSet GetSettingOfRandomFace(string filePath)
        {
            var data = new MaidRandomFaceSet();
            try
            {
                var element = XDocument.Load(@filePath).Element("Setting").Element("RandomFace");
                data.fadeTime = GetElement(element, "fadeTime", MyConst.FACE_START_TIME);
                data.minTime = GetElement(element, "minTime", MyConst.FACE_MIN_TIME);
                data.maxTime = GetElement(element, "maxTime", MyConst.FACE_MAX_TIME);
                data.morphData = null;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                data.fadeTime = MyConst.FACE_FADE_TIME;
                data.minTime = MyConst.FACE_MIN_TIME;
                data.maxTime = MyConst.FACE_FRAME;
            }
            return data;
        }

        /// <summary>
        /// 設定ファイル取得（キー＆マウス移動値）
        /// </summary>
        public MoveSpeedSet GetSettingOfMoveSpeed(string filePath)
        {
            var moveSpeed = new MoveSpeedSet();
            try
            {
                var element = XDocument.Load(@filePath).Element("Setting").Element("MoveSpeed");
                moveSpeed.keyMove = GetElement(element, "key_move", MyConst.NORMAL_KEY_MOVE);
                moveSpeed.mouseMove = GetElement(element, "mouse_move", MyConst.NORMAL_MOUSE_MOVE / 100);
                moveSpeed.mouseRotate = GetElement(element, "mouse_rotate", MyConst.NORMAL_MOUSE_MOVE);
                moveSpeed.maidForward = GetElement(element, "maidForward", MyConst.MIAD_MOVE_FORWARD);
                moveSpeed.maidRotation = GetElement(element, "maidRotation", MyConst.MIAD_MOVE_RAUND);
                moveSpeed.maidUpDown = GetElement(element, "maiddUpDown", MyConst.MIAD_MOVE_FORWARD);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                moveSpeed.keyMove = MyConst.NORMAL_KEY_MOVE;
                moveSpeed.mouseMove = MyConst.NORMAL_MOUSE_MOVE / 100;
                moveSpeed.mouseRotate = MyConst.NORMAL_MOUSE_MOVE;
            }
            return moveSpeed;
        }

        /// <summary>
        /// 設定ファイル取得（ダンス自動終了）
        /// </summary>
        public bool GetSettingOfDanceAutoEnd(string filePath)
        {
            var isAutoEnd = false;
            try
            {
                var table = XDocument.Load(@filePath).Element("Setting").Element("Dance");
                isAutoEnd = GetElement(table, "isAutoEnd", 0) == MyConst.FILE_TRUE ? true : false;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return isAutoEnd;
        }

        /// <summary>
        /// 設定ファイル取得（ダンスずれ調整判定タイム）
        /// </summary>
        public DanceAnimationSyncSet GetSettingOfDanceSync(string filePath)
        {
            var syncSet = new DanceAnimationSyncSet();
            try
            {
                var table = XDocument.Load(@filePath).Element("Setting").Element("Dance");
                syncSet.firstSyncTime = GetElement(table, "firstSyncTime", MyConst.DANCE_GAP_TIME);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return syncSet;
        }

        /// <summary>
        /// 設定ファイル取得（CM3D2ダンス、及び歌BGMVolue）
        /// </summary>
        public int GetSettingOfDanceBGMVolue(string filePath)
        {
            var volume = new SoundManager().GetVolumeDance();
            try
            {
                var table = XDocument.Load(@filePath).Element("Setting").Element("Dance");
                volume = GetElement(table, "volume", volume);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return volume;
        }

        /// <summary>
        /// 設定ファイル取得（座標スライダー）
        /// </summary>
        public TransformSliderSet GetSettingOfTransformSlider(string filePath)
        {
            try
            {
                var slider = new TransformSliderSet();
                var data = XDocument.Load(@filePath).Element("Setting").Element("TransformSlider");
                slider.positionMin
                    = new Vector3(GetElement(data, "positionX_Min", 0f),
                                  GetElement(data, "positionY_Min", 0f),
                                  GetElement(data, "positionZ_Min", 0f));
                slider.positionMax
                    = new Vector3(GetElement(data, "positionX_Max", 0f),
                                  GetElement(data, "positionY_Max", 0f),
                                  GetElement(data, "positionZ_Max", 0f));
                slider.rotationMin
                    = new Vector3(GetElement(data, "rotationX_Min", 0f),
                                  GetElement(data, "rotationY_Min", 0f),
                                  GetElement(data, "rotationZ_Min", 0f));
                slider.rotationMax
                    = new Vector3(GetElement(data, "rotationX_Max", 0f),
                                  GetElement(data, "rotationY_Max", 0f),
                                  GetElement(data, "rotationZ_Max", 0f));
                slider.scaleMin
                    = new Vector3(GetElement(data, "scaleX_Min", 0f),
                                  GetElement(data, "scaleY_Min", 0f),
                                  GetElement(data, "scaleZ_Min", 0f));
                slider.scaleMax
                    = new Vector3(GetElement(data, "scaleX_Max", 0f),
                                  GetElement(data, "scaleY_Max", 0f),
                                  GetElement(data, "scaleZ_Max", 0f));
                slider.boneRotationMin
                    = new Vector3(GetElement(data, "boneRotationX_Min", 0f),
                                  GetElement(data, "boneRotationY_Min", 0f),
                                  GetElement(data, "boneRotationZ_Min", 0f));
                slider.boneRotationMax
                    = new Vector3(GetElement(data, "boneRotationX_Max", 0f),
                                  GetElement(data, "boneRotationY_Max", 0f),
                                  GetElement(data, "boneRotationZ_Max", 0f));
                return slider;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return new TransformSliderSet();
            }
        }

        /// <summary>
        /// 設定ファイル取得（カメラモーション変化判定値）
        /// </summary>
        public CameraMotionDeltaSet GetSettingOfCameraMotionDelta(string filePath)
        {
            try
            {
                var data = new CameraMotionDeltaSet();
                var delta = XDocument.Load(@filePath).Element("Setting").Element("CameraMotionDelta");
                data.time = GetElement(delta, "time", 0f);
                data.position = GetElement(delta, "position", 0f);
                data.rotation = GetElement(delta, "rotation", 0f);
                data.viewAngle = GetElement(delta, "viewAngle", 0f);
                return data;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return new CameraMotionDeltaSet();
            }
        }

        /// <summary>
        /// 設定ファイル取得（メイドモーション変化判定値）
        /// </summary>
        public MaidMotionSet GetSettingOfMaidMotion(string filePath)
        {
            try
            {
                var data = new MaidMotionSet();
                var table = XDocument.Load(@filePath).Element("Setting").Element("MaidMotion");
                var delta = table.Element("captureDelta");
                data.time = GetElement(delta, "time", 0f);
                data.position = GetElement(delta, "position", 0f);
                data.rotation = GetElement(delta, "rotation", 0f);
                data.morphValue = GetElement(delta, "morphValue", 0f);
                return data;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return new MaidMotionSet();
            }
        }

        /// <summary>
        /// 設定ファイル取得（カメラ位置調整値）
        /// </summary>
        public DanceCameraAdjustSet GetSettingOfDanceCameraAdjust(string filePath)
        {
            var data = new DanceCameraAdjustSet();
            try
            {
                
                var delta = XDocument.Load(@filePath).Element("Setting").Element("DanceCameraAdjust");
                data.baseMinHeight = GetElement(delta, "baseMinHeight", MyConst.DCA_BASE_MIN_HEIGHT);
                data.baseMaxHeight = GetElement(delta, "baseMaxHeight", MyConst.DCA_BASE_MAX_HEIGHT);
                data.singleAngleMax = GetElement(delta, "singleAngleMax", MyConst.DCA_SINGLE_ANGLE_MAX);
                data.multiAngleMax = GetElement(delta, "multiAngleMax", MyConst.DCA_MULTI_ANGLE_MAX);
                data.cameraHeightMin = GetElement(delta, "cameraHeightMin", MyConst.DCA_CAMERA_HEIGHT_MIN);
                data.cameraMoveMax = GetElement(delta, "cameraMoveMax", MyConst.DCA_CAMERA_MOVE_MAX);
                data.deltaMax = GetElement(delta, "deltaMax", MyConst.DCA_DELTA_MAX);
                data.correctRate = GetElement(delta, "correctRate", MyConst.DCA_CORRECT_RATE);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                data.baseMinHeight = MyConst.DCA_BASE_MIN_HEIGHT;
                data.baseMaxHeight = MyConst.DCA_BASE_MAX_HEIGHT;
                data.singleAngleMax = MyConst.DCA_SINGLE_ANGLE_MAX;
                data.multiAngleMax = MyConst.DCA_MULTI_ANGLE_MAX;
                data.cameraHeightMin = MyConst.DCA_CAMERA_HEIGHT_MIN;
                data.cameraMoveMax = MyConst.DCA_CAMERA_MOVE_MAX;
                data.deltaMax = MyConst.DCA_DELTA_MAX;
                data.correctRate = MyConst.DCA_CORRECT_RATE;
            }
            return data;
        }

        /// <summary>
        /// 設定ファイル取得（スクリーン脱衣：除外）
        /// </summary>
        public string[] GetSettingOfScreenUndressExcept(string filePath)
        {
            var data = new string[MyConst.SCREEN_UNDRESS_PATTERN];
            try
            {
                var element = XDocument.Load(@filePath).Element("SettingScreenUndress").Element("except");
                data[0] = GetElement(element, "perfectMatching");
                data[1] = GetElement(element, "startsWith");
                data[2] = GetElement(element, "endsWith");
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                data = new string[MyConst.SCREEN_UNDRESS_PATTERN];
            }
            return data;
        }

        /// <summary>
        /// 設定ファイル取得（スクリーン脱衣：判定）
        /// </summary>
        public Dictionary<TBody.SlotID, string[]> GetSettingOfScreenUndressJudgment(string filePath)
        {
            var dic = new Dictionary<TBody.SlotID, string[]>();
            try
            {
                var element = XDocument.Load(@filePath).Element("SettingScreenUndress").Elements("judgment");
                foreach (var row in element)
                {
                    var data = new string[MyConst.SCREEN_UNDRESS_PATTERN];
                    var keys = new SatgeObjectManager().GetScreenUnderessKeys();
                    foreach (var key in keys)
                    {
                        var name = Enum.GetName(typeof(TBody.SlotID), key).ToLower();
                        if(name == GetAttribute(row, "type").ToLower())
                        {
                            data[0] = GetElement(row, "perfectMatching");
                            data[1] = GetElement(row, "startsWith");
                            data[2] = GetElement(row, "endsWith");
                            dic[key] = data;
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                dic = new Dictionary<TBody.SlotID, string[]>();
            }
            return dic;
        }

        /// <summary>
        /// 設定ファイル取得（おまけ：浣腸）
        /// </summary>
        public MaidEnemaSet GetSettingOfDanceExtraEnema(string filePath)
        {
            var data = new MaidEnemaSet();
            try
            {
                var element = XDocument.Load(@filePath).Element("Setting").Element("Extra").Element("enema");
                data.duration = GetElement(element, "duration", 0f);
                data.startLifetime = GetElement(element, "startLifetime", 0f);
                data.startSize = GetElement(element, "startSize", 0f);
                data.startRotation = GetElement(element, "startRotation", 0f);
                data.gravityModifier = GetElement(element, "gravityModifier", 0f);
                data.isShader = GetElement(element, "isShader", 0) == MyConst.FILE_TRUE;
                data.color = new Color32(
                                GetColorElement(element, "colorR"),
                                GetColorElement(element, "colorG"),
                                GetColorElement(element, "colorB"),
                                GetColorElement(element, "colorA"));
                data.textureName = GetElement(element, "textureName");
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return data;
        }

        /// <summary>
        /// 設定ファイル取得（ボディ）
        /// </summary>
        public MaidSongKupaSet GetSettingOfBodyKupa(string filePath)
        {
            var data = new MaidSongKupaSet();
            try
            {
                var element = XDocument.Load(@filePath).Element("Setting").Element("BodyMorph");
                data.kupaSize = GetElement(element, "kupaSize", 0f);
                data.analkupaSize = GetElement(element, "analkupaSize", 0f);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return data;
        }

        /// <summary>
        /// メイド胸揺れ設定ファイル取得（個別）
        /// </summary>
        public List<MaidMuneSet> GetSettingOfMaidEachMune(string filePath)
        {
            try
            {
                var list = new List<MaidMuneSet>();
                var element = XDocument.Load(@filePath).Element("SettingMaidSwing").Element("eachMune").Elements("mune");
                foreach (var mune in element)
                {
                    var data = new MaidMuneSet();
                    data.minSize = GetElement(mune, "minSize", 0);
                    data.maxSize = GetElement(mune, "maxSize", 0);
                    data.gravity = GetElement(mune, "gravity", MyConst.MUNE_GRAVITY_DEFAULT);
                    data.damping = GetElement(mune, "damping", MyConst.MUNE_DAMPING_DEFAULT);
                    data.yawaraka = GetElement(mune, "yawaraka", MyConst.MUNE_YAWARAKA_DEFAULT);
                    data.maxStiffness = GetElement(mune, "maxStiffness", MyConst.MUNE_MAX_STIFFNESS_DEFAULT);
                    data.minStiffness = GetElement(mune, "minStiffness", MyConst.MUNE_MIN_STIFFNESS_DEFAULT);
                    data.maxStiffnessBra = GetElement(mune, "maxStiffnessBra", MyConst.MUNE_MAX_STIFFNESS_BRA_DEFAULT);
                    data.minStiffnessBra = GetElement(mune, "minStiffnessBra", MyConst.MUNE_MIN_STIFFNESS_BRA_DEFAULT);
                    list.Add(data);
                }
                return list;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return new List<MaidMuneSet>(MyConst.SWING_SETTING_COUNT);
            }
        }

        /// <summary>
        /// メイド胸揺れ設定ファイル取得（共通）
        /// </summary>
        public List<MaidMuneSet> GetSettingOfMaidCommonMune(string filePath)
        {
            try
            {
                var list = new List<MaidMuneSet>();
                var element = XDocument.Load(@filePath).Element("SettingMaidSwing").Element("commonMune").Elements("mune");
                foreach (var mune in element)
                {
                    var data = new MaidMuneSet();
                    data.minSize = GetElement(mune, "minSize", 0);
                    data.maxSize = GetElement(mune, "maxSize", 0);
                    data.gravity = GetElement(mune, "gravity", MyConst.MUNE_GRAVITY_DEFAULT);
                    data.damping = GetElement(mune, "damping", MyConst.MUNE_DAMPING_DEFAULT);
                    data.yawaraka = GetElement(mune, "yawaraka", MyConst.MUNE_YAWARAKA_DEFAULT);
                    data.maxStiffness = GetElement(mune, "maxStiffness", MyConst.MUNE_MAX_STIFFNESS_DEFAULT);
                    data.minStiffness = GetElement(mune, "minStiffness", MyConst.MUNE_MIN_STIFFNESS_DEFAULT);
                    data.maxStiffnessBra = GetElement(mune, "maxStiffnessBra", MyConst.MUNE_MAX_STIFFNESS_BRA_DEFAULT);
                    data.minStiffnessBra = GetElement(mune, "minStiffnessBra", MyConst.MUNE_MIN_STIFFNESS_BRA_DEFAULT);
                    list.Add(data);
                }
                return list;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return new List<MaidMuneSet>(MyConst.SWING_SETTING_COUNT);
            }
        }

        /// <summary>
        /// メイド髪揺れ設定ファイル取得（共通）
        /// </summary>
        public List<Dictionary<TBody.SlotID, DynamicBone>> GetSettingOfMaidCommonHair(string filePath)
        {
            try
            {
                var list = new List<Dictionary<TBody.SlotID, DynamicBone>>();
                var element = XDocument.Load(@filePath).Element("SettingMaidSwing").Element("commonHair").Elements("hairs");
                foreach (var hairs in element)
                {
                    var dic = new Dictionary<TBody.SlotID, DynamicBone>();
                    foreach (var hair in hairs.Elements("hair"))
                    {
                        var data = new DynamicBone();
                        var id = MyHelper.ConvertTBodySlotNameToID(GetAttribute(hair, "type"));
                        data.m_Damping = GetElement(hair, "damping", MyConst.HAIR_DAMPING_DEFAULT);
                        data.m_Elasticity = GetElement(hair, "elasticity", MyConst.HAIR_ELASTICITY_DEFAULT);
                        data.m_Stiffness = GetElement(hair, "stiffness", MyConst.HAIR_STIFFNESS_DEFAULT);
                        data.m_Inert = GetElement(hair, "inert", MyConst.SWING_COMMON_MIN);
                        data.m_Radius = GetElement(hair, "radius", MyConst.HAIR_RADIUS_DEFAULT);
                        dic[id] = data;
                    }
                    list.Add(dic);
                }
                return list;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// メイドスカート揺れ設定ファイル取得（共通）
        /// </summary>
        public List<Dictionary<TBody.SlotID, DynamicSkirtBone>> GetSettingOfMaidCommonSkirt(string filePath)
        {
            try
            {
                var list = new List<Dictionary<TBody.SlotID, DynamicSkirtBone>>();
                var element = XDocument.Load(@filePath).Element("SettingMaidSwing").Element("commonSkirt").Elements("skirts");
                foreach (var skirts in element)
                {
                    var dic = new Dictionary<TBody.SlotID, DynamicSkirtBone>();
                    foreach (var skirt in skirts.Elements("skirt"))
                    {
                        var data = new DynamicSkirtBone();
                        var id = MyHelper.ConvertTBodySlotNameToID(GetAttribute(skirt, "type"));
                        data.m_fPanierRadius = GetElement(skirt, "radius", MyConst.SKIRT_RADIUS_DEFAULT);
                        data.m_fVelocityForceRate = GetElement(skirt, "velocity", MyConst.SKIRT_VELOCITY_DEFAULT);
                        data.m_fPanierForce = GetElement(skirt, "force", MyConst.SKIRT_FORCE_DEFAULT);
                        data.m_fRegDefaultRadius = GetElement(skirt, "regRadius", MyConst.SKIRT_REG_RADIUS_DEFAULT);
                        data.m_fPanierStiffnessRate = GetElement(skirt, "stiffness", MyConst.SKIRT_STIFFNESS_DEFAULT);
                        data.m_fPanierStressForce = GetElement(skirt, "stress", MyConst.SKIRT_STRESS_DEFAULT);
                        data.m_fPanierForceDistanceThreshold = GetElement(skirt, "threshold", MyConst.SKIRT_THRESHOLD_DEFAULT);
                        dic[id] = data;
                    }
                    list.Add(dic);
                }
                return list;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// ダンス効果設定ファイル取得（バブル）
        /// </summary>
        public FreeBubbleLameSet GetSettingOfDanceEffectBubble(string filePath)
        {
            var data = new FreeBubbleLameSet();
            try
            {
                var element = XDocument.Load(@filePath).Element("SettingDanceEffect").Element("bubble");
                data.minSize = GetElement(element, "minSize", 0f);
                data.maxSize = GetElement(element, "maxSize", 0f);
                data.minEnergy = GetElement(element, "minEnergy", 0f);
                data.maxEnergy = GetElement(element, "maxEnergy", 0f);
                data.minEmission = GetElement(element, "minEmission", 0f);
                data.maxEmission = GetElement(element, "maxEmission", 0f);
                data.worldVelocity = new Vector3(
                    GetElement(element, "worldVelocityX", 0f),
                    GetElement(element, "worldVelocityY", 0f),
                    GetElement(element, "worldVelocityZ", 0f));
                data.rndVelocity = new Vector3(
                    GetElement(element, "rndVelocityX", 0f),
                    GetElement(element, "rndVelocityY", 0f),
                    GetElement(element, "rndVelocityZ", 0f));
                data.angularVelocity = GetElement(element, "angularVelocity", 0f);
                data.rndAngularVelocity = GetElement(element, "rndAngularVelocity", 0f);
                data.rndRotation = GetElement(element, "rndRotation", 0) == MyConst.FILE_TRUE;
                data.textureName = "";
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return data;
        }

        /// <summary>
        /// ステージ&ダンス効果設定ファイル取得（パーティクル）
        /// </summary>
        public DanceParticle GetSettingOfStageEffectParticle(string filePath, string label, bool isDance)
        {
            var data = new DanceParticle();
            try
            {
                var root = isDance ? "SettingDanceEffect" : "StageParticle";
                var elements = XDocument.Load(@filePath).Element(root).Elements("particle");
                foreach (var particle in elements)
                {
                    if (label == GetAttribute(particle, "label"))
                    {
                        data = GetParticleData(particle);
                        break;
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return data;
        }

        /// <summary>
        /// ダンス効果設定ファイル取得（パーティクル）
        /// </summary>
        private DanceParticle GetParticleData(XElement particle)
        {
            var data = new DanceParticle();
            data.label = GetAttribute(particle, "label");
            data.textureName = GetElement(particle, "textureName");
            data.shaderName = GetElement(particle, "shaderName");
            data.position
                = new Vector3(GetElement(particle, "positionX", 0f),
                              GetElement(particle, "positionY", 0f),
                              GetElement(particle, "positionZ", 0f));
            data.rotation
                = new Vector3(GetElement(particle, "rotationX", 0f),
                              GetElement(particle, "rotationY", 0f),
                              GetElement(particle, "rotationZ", 0f));
            data.scale
                = new Vector3(GetElement(particle, "scaleX", MyConst.SCALE_DEFAULT),
                              GetElement(particle, "scaleY", MyConst.SCALE_DEFAULT),
                              GetElement(particle, "scaleZ", MyConst.SCALE_DEFAULT));
            data.allScale = MyConst.SCALE_DEFAULT;
            data.isColor = GetElement(particle, "isColor", 0) == MyConst.FILE_TRUE;
            data.color = new Color32(
                        GetColorElement(particle, "colorR"),
                        GetColorElement(particle, "colorG"),
                        GetColorElement(particle, "colorB"),
                        GetColorElement(particle, "colorA"));

            var element = particle.Element("main");
            if (element != null)
            {
                var p = data.main;
                p.enabled = true;
                p.duration = GetElement(element, "duration", 5f);
                p.maxParticles = GetElement(element, "maxParticles", 1000);
                p.isLoop = GetElement(element, "isLoop", 1) == MyConst.FILE_TRUE;
                p.startDelay
                    = new Vector2(GetElement(element, "startDelayMin", 0f),
                                  GetElement(element, "startDelayMax", 0f));
                p.startLifetime
                    = new Vector2(GetElement(element, "startLifetimeMin", 1f),
                                  GetElement(element, "startLifetimeMax", 1f));
                p.startSpeed
                    = new Vector2(GetElement(element, "startSpeedMin", 0.1f),
                                  GetElement(element, "startSpeedMax", 0.1f));
                p.startSize
                    = new Vector2(GetElement(element, "startSizeMin", 0.1f),
                                  GetElement(element, "startSizeMax", 0.1f));
                p.startRotation
                    = new Vector2(GetElement(element, "startRotationMin", 0f),
                                  GetElement(element, "startRotationMax", 0f));
                p.gravityModifier
                    = new Vector2(GetElement(element, "gravityModifierMin", 0f),
                                  GetElement(element, "gravityModifierMax", 0f));
                data.main = p;
            }
            
            element = particle.Element("emission");
            if (element != null)
            {
                var p = data.emission;
                p.enabled = true;
                p.rateOverTime
                    = new Vector2(GetElement(element, "rateOverTimeMin", 0f),
                                  GetElement(element, "rateOverTimeMax", 0f));
                p.rateOverDistance
                    = new Vector2(GetElement(element, "rateOverDistanceMin", 0f),
                                  GetElement(element, "rateOverDistanceMax", 0f));
                p.burst
                    = new Vector3(GetElement(element, "burstMin", 0f),
                                  GetElement(element, "burstMax", 0f),
                                  GetElement(element, "burstTime", 0f));
                data.emission = p;
            }
            
            element = particle.Element("shape");
            if (element != null)
            {
                var p = data.shape;
                p.enabled = true;
                p.shapeType = (ParticleSystemShapeType)GetElement(element, "shapeType", 0);
                p.angle = GetElement(element, "angle", 0f);
                p.sphericalDirectionAmount = GetElement(element, "sphericalDirectionAmount", 0f);
                p.randomDirectionAmount = GetElement(element, "randomDirectionAmount", 0f);
                p.boxSize
                    = new Vector3(GetElement(element, "boxSizeX", 0f),
                                  GetElement(element, "boxSizeY", 0f),
                                  GetElement(element, "boxSizeZ", 0f));
                p.radiusMode = (ParticleSystemShapeMultiModeValue)GetElement(element, "radiusMode", 0);
                p.radius = GetElement(element, "radius", 0f);
                p.radiusSpread = GetElement(element, "radiusSpread", 0f);
                p.radiusSpeed
                    = new Vector2(GetElement(element, "radiusSpeedMin", 0f),
                                  GetElement(element, "radiusSpeedMax", 0f));
                p.arcMode = (ParticleSystemShapeMultiModeValue)GetElement(element, "arcMode", 0);
                p.arc = GetElement(element, "arc", 0f);
                p.arcSpread = GetElement(element, "arcSpread", 0f);
                p.arcSpeed
                    = new Vector2(GetElement(element, "arcSpeedMin", 0f),
                                  GetElement(element, "arcSpeedMax", 0f));
                data.shape = p;
            }

            GetParticleDefaultColorSetting(ref data);

            var elements = particle.Elements("colorOverLifetime");
            if (elements != null)
            {
                var p = data.colorOverLifetime;
                foreach (var elm in elements)
                {
                    p.enabled = true;
                    var mode = (ParticleSystemGradientMode)GetElement(elm, "mode", 0);
                    p.mode = mode;
                    p.isRandom = GetElement(elm, "isRandom", 0) == MyConst.FILE_TRUE;

                    foreach(var key in MyConst.PARTICLE_GRADIENT_TYPE.Keys)
                    {
                        var tag = Enum.GetName(typeof(ParticleSystemGradientMode), key);
                        var gColor = p.gradientColor[key];

                        foreach (var color in elm.Element(tag).Elements("color"))
                        {
                            var index = GetAttribute(color, "index", 0);
                            var g = new GradientColorKey();
                            g.color = new Color32(
                                GetColorElement(color, "colorR"),
                                GetColorElement(color, "colorG"),
                                GetColorElement(color, "colorB"),
                                MyConst.COLOR_MAX);
                            g.time = GetElement(color, "time", 0f);
                            gColor[index] = g;
                        }
                        p.gradientColor[key] = gColor;

                        var gAlpha = p.gradientAlpha[key];
                        foreach (var color in elm.Element(tag).Elements("alpha"))
                        {
                            var index = GetAttribute(color, "index", 0);
                            var a = new GradientAlphaKey();
                            a.alpha = GetElement(color, "colorA", 1f);
                            a.time = GetElement(color, "time", 0f);
                            gAlpha[index] = a;
                        }
                        p.gradientAlpha[key] = gAlpha;

                        if (key == mode)
                        {
                            break;
                        }
                    }
                }
                data.colorOverLifetime = p;
            }

            elements = particle.Elements("colorBySpeed");
            if (elements != null)
            {
                var p = data.colorBySpeed;
                foreach (var elm in elements)
                {
                    p.enabled = true;
                    var mode = (ParticleSystemGradientMode)GetElement(elm, "mode", 0);
                    p.mode = mode;
                    p.isRandom = GetElement(elm, "isRandom", 0) == MyConst.FILE_TRUE;

                    foreach (var key in MyConst.PARTICLE_GRADIENT_TYPE.Keys)
                    {
                        var tag = Enum.GetName(typeof(ParticleSystemGradientMode), key);
                        var gColor = p.gradientColor[key];

                        foreach (var color in elm.Element(tag).Elements("color"))
                        {
                            var index = GetAttribute(color, "index", 0);
                            var g = new GradientColorKey();
                            g.color = new Color32(
                                GetColorElement(color, "colorR"),
                                GetColorElement(color, "colorG"),
                                GetColorElement(color, "colorB"),
                                MyConst.COLOR_MAX);
                            g.time = GetElement(color, "time", 0f);
                            gColor[index] = g;
                        }
                        p.gradientColor[key] = gColor;

                        var gAlpha = p.gradientAlpha[key];
                        foreach (var color in elm.Element(tag).Elements("alpha"))
                        {
                            var index = GetAttribute(color, "index", 0);
                            var a = new GradientAlphaKey();
                            a.alpha = GetElement(color, "colorA", 1f);
                            a.time = GetElement(color, "time", 0f);
                            gAlpha[index] = a;
                        }
                        p.gradientAlpha[key] = gAlpha;

                        if (key == mode)
                        {
                            break;
                        }
                    }
                    p.range
                        = new Vector2(GetElement(elm, "rangeMin", 0f),
                                      GetElement(elm, "rangeMax", 0f));
                }
                data.colorBySpeed = p;
            }
            
            element = particle.Element("inheritVelocity");
            if (element != null)
            {
                var p = data.inheritVelocity;
                p.enabled = true;
                p.curve
                    = new Vector2(GetElement(element, "curveMin", 0f),
                                  GetElement(element, "curveMax", 0f));
                data.inheritVelocity = p;
            }
            
            element = particle.Element("velocityOverLifetime");
            if (element != null)
            {
                var p = data.velocityOverLifetime;
                p.enabled = true;
                p.speed.x
                    = new Vector2(GetElement(element, "speedMinX", 0f),
                                  GetElement(element, "speedMaxX", 0f));
                p.speed.y
                    = new Vector2(GetElement(element, "speedMinY", 0f),
                                  GetElement(element, "speedMaxY", 0f));
                p.speed.z
                    = new Vector2(GetElement(element, "speedMinZ", 0f),
                                  GetElement(element, "speedMaxZ", 0f));
                data.velocityOverLifetime = p;
            }
            
            element = particle.Element("limitVelocityOverLifetime");
            if (element != null)
            {
                var p = data.limitVelocityOverLifetime;
                p.enabled = true;
                p.dampen = GetElement(element, "dampen", 0f);
                p.limit.x
                    = new Vector2(GetElement(element, "limitMinX", 0f),
                                  GetElement(element, "limitMaxX", 0f));
                p.limit.y
                    = new Vector2(GetElement(element, "limitMinY", 0f),
                                  GetElement(element, "limitMaxY", 0f));
                p.limit.z
                    = new Vector2(GetElement(element, "limitMinZ", 0f),
                                  GetElement(element, "limitMaxZ", 0f));
                data.limitVelocityOverLifetime = p;
            }
            
            element = particle.Element("forceOverLifetime");
            if (element != null)
            {
                var p = data.forceOverLifetime;
                p.enabled = true;
                p.randomized = GetElement(element, "randomized", 0) == MyConst.FILE_TRUE ? true : false;
                p.force.x
                    = new Vector2(GetElement(element, "forceMinX", 0f),
                                  GetElement(element, "forceMaxX", 0f));
                p.force.y
                    = new Vector2(GetElement(element, "forceMinY", 0f),
                                  GetElement(element, "forceMaxY", 0f));
                p.force.z
                    = new Vector2(GetElement(element, "forceMinZ", 0f),
                                  GetElement(element, "forceMaxZ", 0f));
                data.forceOverLifetime = p;
            }
            
            element = particle.Element("externalForces");
            if (element != null)
            {
                var p = data.externalForces;
                p.enabled = true;
                p.multiplier = GetElement(element, "multiplier", 0f);
                data.externalForces = p;
            }
            
            element = particle.Element("sizeOverLifetime");
            if (element != null)
            {
                var p = data.sizeOverLifetime;
                p.enabled = true;
                p.size.x
                    = new Vector2(GetElement(element, "sizeMinX", 0f),
                                  GetElement(element, "sizeMaxX", 0f));
                p.size.y
                    = new Vector2(GetElement(element, "sizeMinY", 0f),
                                  GetElement(element, "sizeMaxY", 0f));
                p.size.z
                    = new Vector2(GetElement(element, "sizeMinZ", 0f),
                                  GetElement(element, "sizeMaxZ", 0f));
                data.sizeOverLifetime = p;
            }
            
            element = particle.Element("sizeBySpeed");
            if (element != null)
            {
                var p = data.sizeBySpeed;
                p.enabled = true;
                data.sizeBySpeed.enabled = true;
                p.size.x
                    = new Vector2(GetElement(element, "sizeMinX", 0f),
                                  GetElement(element, "sizeMaxX", 0f));
                p.size.y
                    = new Vector2(GetElement(element, "sizeMinY", 0f),
                                  GetElement(element, "sizeMaxY", 0f));
                p.size.z
                    = new Vector2(GetElement(element, "sizeMinZ", 0f),
                                  GetElement(element, "sizeMaxZ", 0f));
                p.range
                    = new Vector2(GetElement(element, "rangeMin", 0f),
                                  GetElement(element, "rangeMax", 0f));
                data.sizeBySpeed = p;
            }
            
            element = particle.Element("rotationOverLifetime");
            if (element != null)
            {
                var p = data.rotationOverLifetime;
                p.enabled = true;
                p.rotation.x
                    = new Vector2(GetElement(element, "rotationMinX", 0f),
                                  GetElement(element, "rotationMaxX", 0f));
                p.rotation.y
                    = new Vector2(GetElement(element, "rotationMinY", 0f),
                                  GetElement(element, "rotationMaxY", 0f));
                p.rotation.z
                    = new Vector2(GetElement(element, "rotationMinZ", 0f),
                                  GetElement(element, "rotationMaxZ", 0f));
                data.rotationOverLifetime = p;
            }
            
            element = particle.Element("rotationBySpeed");
            if (element != null)
            {
                var p = data.rotationBySpeed;
                p.enabled = true;
                p.rotation.x
                    = new Vector2(GetElement(element, "rotationMinX", 0f),
                                  GetElement(element, "rotationMaxX", 0f));
                p.rotation.y
                    = new Vector2(GetElement(element, "rotationMinY", 0f),
                                  GetElement(element, "rotationMaxY", 0f));
                p.rotation.z
                    = new Vector2(GetElement(element, "rotationMinZ", 0f),
                                  GetElement(element, "rotationMaxZ", 0f));
                p.range
                    = new Vector2(GetElement(element, "rangeMin", 0f),
                                  GetElement(element, "rangeMax", 0f));
                data.rotationBySpeed = p;
            }
           
            element = particle.Element("collision");
            if (element != null)
            {
                var p = data.collision;
                p.enabled = true;
                p.dampen
                    = new Vector2(GetElement(element, "dampenMin", 0f),
                                  GetElement(element, "dampenMax", 0f));
                p.bounce
                    = new Vector2(GetElement(element, "bounceMin", 0f),
                                  GetElement(element, "bounceMax", 0f));
                p.lifetimeLoss
                   = new Vector2(GetElement(element, "lifetimeLossMin", 0f),
                                 GetElement(element, "lifetimeLossMax", 0f));
                p.minKillSpeed = GetElement(element, "minKillSpeed", 0f);
                data.collision = p;
            }
            
            element = particle.Element("noise");
            if (element != null)
            {
                var p = data.noise;
                p.enabled = true;
                p.strength.x
                    = new Vector2(GetElement(element, "strengthMinX", 0f),
                                  GetElement(element, "strengthMaxX", 0f));
                p.strength.y
                    = new Vector2(GetElement(element, "strengthMinY", 0f),
                                  GetElement(element, "strengthMaxY", 0f));
                p.strength.z
                    = new Vector2(GetElement(element, "strengthMinZ", 0f),
                                  GetElement(element, "strengthMaxZ", 0f));
                p.frequency = GetElement(element, "frequency", 0f);
                p.damping = GetElement(element, "damping", 0) == MyConst.FILE_TRUE ? true : false;
                data.noise = p;
            }

            element = particle.Element("render");
            if (element != null)
            {
                var p = data.render;
                p.enabled = true;
                p.mode = (ParticleSystemRenderMode)GetElement(element, "mode", 0);
                data.render = p;
            }

            element = particle.Element("textureSheetAnimation");
            if (element != null)
            {
                data.textureSheetAnimation.enabled = true;
            }
            
            return data;
        }

        /// <summary>
        /// パーティクル色初期設定取得
        /// </summary>
        public void GetParticleDefaultColorSetting(ref DanceParticle data)
        {
            var gradientColor = new GradientColorKey[MyConst.GRADIENT_KEY];
            var gradientAlpha = new GradientAlphaKey[MyConst.GRADIENT_KEY];
            for (int i = 0; i < MyConst.GRADIENT_KEY; i++)
            {
                gradientColor[i].color = MyHelper.SetColorWhite();
                gradientAlpha[i].alpha = 1f;
            }
            data.colorOverLifetime.gradientColor = new Dictionary<ParticleSystemGradientMode, GradientColorKey[]>();
            data.colorBySpeed.gradientColor = new Dictionary<ParticleSystemGradientMode, GradientColorKey[]>();
            data.colorOverLifetime.gradientAlpha = new Dictionary<ParticleSystemGradientMode, GradientAlphaKey[]>();
            data.colorBySpeed.gradientAlpha = new Dictionary<ParticleSystemGradientMode, GradientAlphaKey[]>();
            foreach (var key in MyConst.PARTICLE_GRADIENT_TYPE.Keys)
            {
                data.colorOverLifetime.gradientColor[key] = (GradientColorKey[])gradientColor.Clone();
                data.colorBySpeed.gradientColor[key] = (GradientColorKey[])gradientColor.Clone();
                data.colorOverLifetime.gradientAlpha[key] = (GradientAlphaKey[])gradientAlpha.Clone();
                data.colorBySpeed.gradientAlpha[key] = (GradientAlphaKey[])gradientAlpha.Clone();
            }
        }

        /// <summary>
        /// ダンス効果設定ファイル取得（ライン）
        /// </summary>
        public FreeLineSet GetSettingOfDanceEffectLine(string filePath)
        {
            var data = new FreeLineSet();
            try
            {
                var element = XDocument.Load(@filePath).Element("SettingDanceEffect").Element("line");
                data.length = GetElement(element, "length", 0f);
                data.frameWidth = GetElement(element, "frameWidth", 0f);
                data.numCornerVertices = GetElement(element, "numCornerVertices", 0);
                data.flashingRndomTime = GetElement(element, "flashingRndomTime", 0);
                data.flashingInterval = GetElement(element, "flashingInterval", 0f);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return data;
        }

        /// <summary>
        /// カメラモーションファイルデータ読み込み
        /// </summary>
        public List<CameraTransformSet> ReadCameraMotionData(string filePath, float limitY, bool isLimitY)
        {
            try
            {
                var motionData = new List<CameraTransformSet>();
                var lines = File.ReadAllLines(@filePath);
                if (lines.GetLength(0) > 1)
                {
                    for (int i = 0; i < lines.GetLength(0) - 1; i++)
                    {
                        var value = lines[i + 1].Split(MyConst.DELIMITER_CSV);
                        var data = new CameraTransformSet();
                        data.easingType = int.Parse(value[0]);
                        data.stTime = float.Parse(value[1]);
                        data.transform.stPos
                            = new Vector3(float.Parse(value[2]),
                                          AdjustY(value[3], limitY, isLimitY),
                                          float.Parse(value[4]));
                        data.transform.stRot
                            = new Vector3(float.Parse(value[5]),
                                          float.Parse(value[6]),
                                          float.Parse(value[7]));
                        data.edTime = float.Parse(value[8]);
                        data.transform.edPos
                            = new Vector3(float.Parse(value[9]),
                                          AdjustY(value[10], limitY, isLimitY),
                                          float.Parse(value[11]));
                        data.transform.edRot
                            = new Vector3(float.Parse(value[12]),
                                          float.Parse(value[13]),
                                          float.Parse(value[14]));
                        data.deltaTime = data.edTime - data.stTime;
                        
                        if(value.Count() == MyConst.HEADER_MOTION.Split(MyConst.DELIMITER_CSV).Count())
                        {
                            data.transform.stSca = new Vector3(float.Parse(value[15]), float.Parse(value[17]), 0f);
                            data.transform.edSca = new Vector3(float.Parse(value[16]), float.Parse(value[18]), 0f);
                        }
                        else
                        {
                            data.transform.stSca = new Vector3(0f, MyConst.ZOOM_DEFAULT, 0f);
                            data.transform.edSca = new Vector3(0f, MyConst.ZOOM_DEFAULT, 0f);
                        }
                        motionData.Add(data);
                    }
                }
                return motionData.OrderBy(d => d.stTime).ToList();
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        private float AdjustY(string y, float limitY, bool isLimitY)
        {
            var val = float.Parse(y);
            return isLimitY && val < limitY ? limitY : val;
        }

        /// <summary>
        /// ダンスムービーファイルデータ読み込み
        /// </summary>
        public List<DanceMovieSet> ReadDanceMovieData(string filePath)
        {
            var movieData = new List<DanceMovieSet>();
            var table = XDocument.Load(@filePath).Element("DanceMovie");
            foreach (var element in table.Elements("movies"))
            {
                var label = GetAttribute(element, "label");
                foreach (var row in element.Elements("movie"))
                {
                    var data = new DanceMovieSet();
                    data.label = label;
                    data.type = GetAttribute(row, "type", 0);
                    data.fileName = row.Value;
                    movieData.Add(data);
                }
            }
            return movieData;
        }

        /// <summary>
        /// スイッチャーファイルデータ読み込み
        /// </summary>
        public List<SwitcherTransformSet> ReadSwitcherData(string filePath)
        {
            try
            {
                var switcherList = new List<SwitcherTransformSet>();
                var switcherData = new SwitcherTransformSet();
                var table = XDocument.Load(@filePath).Element("Switcher");
                foreach (var row in table.Elements("transform"))
                {
                    switcherData.label = GetAttribute(row, "label");
                    switcherData.transform = new MyTransform();
                    switcherData.transform.stPos
                        = new Vector3(GetElement(row, "positionX", 0f),
                                      GetElement(row, "positionY", 0f),
                                      GetElement(row, "positionZ", 0f));
                    switcherData.transform.stRot
                        = new Vector3(GetElement(row, "rotationX", 0f),
                                      GetElement(row, "rotationY", 0f),
                                      GetElement(row, "rotationZ", 0f));
                    switcherList.Add(switcherData);
                }
                var d = new SwitcherTransformSet();
                d.label = "";
                switcherList.Add(d);
                return switcherList;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// メイドポジションファイルデータ読み込み
        /// </summary>
        public List<MaidTransformSet> ReadMaidTransformData(string filePath)
        {
            try
            {
                var positionList = new List<MaidTransformSet>();
                var table = XDocument.Load(@filePath).Element("MaidTransform");
                foreach (var row in table.Elements("Transform"))
                {
                    var positionData = new MaidTransformSet();
                    positionData.transform = new List<MyTransform>();
                    positionData.label = GetAttribute(row, "label");
                    positionData.auto = GetAttribute(row, "auto", 0);
                    foreach (var maid in row.Elements("maid"))
                    {
                        var data = new MyTransform();
                        data.stPos = new Vector3(GetElement(maid, "positionX", 0f),
                                                 GetElement(maid, "positionY", 0f),
                                                 GetElement(maid, "positionZ", 0f));
                        data.stRot = new Vector3(GetElement(maid, "rotationX", 0f),
                                                 GetElement(maid, "rotationY", 0f),
                                                 GetElement(maid, "rotationZ", 0f));
                        positionData.transform.Add(data);
                    }
                    positionList.Add(positionData);
                }
                var m = new MaidTransformSet();
                m.label = "";
                positionList.Add(m);
                return positionList;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// メイド口パクファイルデータ読み込み（歌モード）
        /// </summary>
        public Dictionary<string, SongMouthSet> ReadSongMouthMorphData(string filePath)
        {
            try
            {
                SongMouthSet data;
                var dic = new Dictionary<string, SongMouthSet>();
                var lines = File.ReadAllLines(@filePath);
                if (lines.GetLength(0) > 1)
                {
                    for (int i = 0; i < lines.GetLength(0) - 1; i++)
                    {
                        data = new SongMouthSet();
                        var value = lines[i + 1].Split(MyConst.DELIMITER_CSV);

                        data.character = value[0];
                        data.stMouth = new Vector3(float.Parse(value[1]), float.Parse(value[2]), float.Parse(value[3]));
                        data.edMouth = new Vector3(float.Parse(value[4]), float.Parse(value[5]), float.Parse(value[6]));
                        data.mouthMorph = new Dictionary<string, float>();
                        var index = 7;
                        foreach (var key in MyConst.MOUTH_MORPH.Keys.Where(k => k != MyConst.FACE_MOUTH_A && k != MyConst.FACE_MOUTH_I && k != MyConst.FACE_MOUTH_C))
                        {
                            data.mouthMorph[key] = float.Parse(value[index]);
                            index++;
                        }
                        dic[value[0]] = data;
                    }
                }
                data = new SongMouthSet();
                data.character = "";
                dic[""] = data;
                return dic;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// メイド口パクファイルデータ読み込み（メイドモーション）
        /// </summary>
        public Dictionary<string, Dictionary<string, float>> ReadMotionMouthMorphData(string filePath)
        {
            try
            {
                var dic = new Dictionary<string, Dictionary<string, float>>();
                var lines = File.ReadAllLines(@filePath);
                if (lines.GetLength(0) > 1)
                {
                    for (int i = 0; i < lines.GetLength(0) - 1; i++)
                    {
                        var data = new Dictionary<string, float>();
                        var value = lines[i + 1].Split(MyConst.DELIMITER_CSV);

                        data[MyConst.FACE_MOUTH_A] = float.Parse(value[4]);
                        data[MyConst.FACE_MOUTH_I] = float.Parse(value[5]);
                        data[MyConst.FACE_MOUTH_C] = float.Parse(value[6]);
                        var index = 7;
                        foreach (var key in MyConst.MOUTH_MORPH.Keys.Where(k => k != MyConst.FACE_MOUTH_A && k != MyConst.FACE_MOUTH_I && k != MyConst.FACE_MOUTH_C))
                        {
                            data[key] = float.Parse(value[index]);
                            index++;
                        }
                        dic[value[0]] = data;
                    }
                }
                return dic;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// ランダムフェイスファイルデータ読み込み
        /// </summary>
        public List<string> ReadMaidRandomFaceData(string filePath, string label)
        {
            try
            {
                var faceData = new List<string>();
                var table = XDocument.Load(@filePath).Element("MaidRandomFace").Elements("faceGroup");
                foreach (var row in table)
                {
                    if (label == GetAttribute(row, "label"))
                    {
                        foreach (var data in row.Elements("face"))
                        {
                            var name = GetAttribute(data, "name");
                            if (!string.IsNullOrEmpty(name))
                            {
                                faceData.Add(name);
                            }
                        }
                        break;
                    }
                }
                return faceData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// カスタムフェイスファイルデータ読み込み
        /// </summary>
        public Dictionary<string, float> ReadMaidCustomFaceData(string filePath, string label)
        {
            try
            {
                var facialDic = new Dictionary<string, float>();
                var table = XDocument.Load(@filePath).Element("MaidCustomFace").Elements("customFace");
                foreach (var row in table)
                {
                    if (label == GetAttribute(row, "label"))
                    {
                        foreach (var key in MyConst.ALL_FACIAL_MORPH.Keys)
                        {
                            facialDic[key] = GetElement(row, key, 0f);
                        }
                        break;
                    }
                }
                return facialDic;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// カスタムフェイスファイルデータ読み込み（モーフ）
        /// </summary>
        public List<MotionTimeLineSet> ReadMaidCustomMorphData(string filePath, string label, int frame)
        {
            try
            {
                var morph = new List<MotionTimeLineSet>();
                var table = XDocument.Load(@filePath).Element("MaidCustomFace").Elements("customFace");
                foreach (var row in table)
                {
                    if (label == GetAttribute(row, "label"))
                    {
                        morph.AddRange(SetMorphData(row, MyConst.FACE_OPTION_MORPH.Keys.ToArray(), frame));
                        morph.AddRange(SetMorphData(row, MyConst.FACE_MORPH.Keys.ToArray(), frame));
                        morph.AddRange(SetMorphData(row, MyConst.MOUTH_MORPH.Keys.ToArray(), frame));
                        break;
                    }
                }
                return morph;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        private List<MotionTimeLineSet> SetMorphData(XElement element, string[] names, int frame)
        {
            var morph = new List<MotionTimeLineSet>();
            foreach (var name in names)
            {
                var data = new MotionTimeLineSet();
                data.frame = frame;
                data.name = name;
                data.morphValue = GetElement(element, name, 0f);
                morph.Add(data);
            }
            return morph;
        }

        /// <summary>
        /// 拘束ファイルデータ読み込み
        /// </summary>
        public Dictionary<string, MaidBindSet> ReadMaidBindData(string filePath)
        {
            try
            {
                var dic = new Dictionary<string, MaidBindSet>();
                var table = XDocument.Load(@filePath).Element("MaidBind").Elements("bind");
                foreach (var row in table)
                {
                    var data = new MaidBindSet();
                    data.menuDic = new Dictionary<string, string>();
                    data.bindDic = new Dictionary<string, Vector3>();
                    data.label = GetAttribute(row, "label");
                    foreach (var menu in row.Element("menus").Elements("menu"))
                    {
                        var tag = GetAttribute(menu, "tag");
                        var name = GetAttribute(menu, "name");
                        data.menuDic[tag] = name;
                    }
                    foreach (var bind in row.Element("rotation").Elements("bone"))
                    {
                        var name = GetAttribute(bind, "name");
                        var x = GetAttribute(bind, "x", 0f);
                        var y = GetAttribute(bind, "y", 0f);
                        var z = GetAttribute(bind, "z", 0f);
                        data.bindDic[name] = new Vector3(x, y, z);
                    }
                    dic[data.label] = data;
                }
                return dic;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// 髪ファイルデータ読み込み
        /// </summary>
        public Dictionary<string, string> ReadMaidHairMenuData(string filePath, string label)
        {
            try
            {
                var hairDic = new Dictionary<string, string>();
                var table = XDocument.Load(@filePath).Element("MaidHairMenu").Elements("hairMenu");
                foreach (var row in table)
                {
                    if (label == GetAttribute(row, "label"))
                    {
                        foreach (var key in MyConst.HAIR_TAG.Keys)
                        {
                            hairDic[key] = GetElement(row, key);
                        }
                        break;
                    }
                }
                return hairDic;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// 衣装ファイルデータ読み込み
        /// </summary>
        public Dictionary<string, string> ReadMaidDressData(string filePath, string label)
        {
            try
            {
                var dressDic = new Dictionary<string, string>();
                var table = XDocument.Load(@filePath).Element("MaidDress").Elements("dress");
                foreach (var row in table)
                {
                    if (label == GetAttribute(row, "label"))
                    {
                        foreach (var key in MyConst.DRESS_TAG.Keys)
                        {
                            dressDic[key] = GetElement(row, key);
                        }
                        break;
                    }
                }
                return dressDic;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        public Dictionary<string, Dictionary<string, string>> ReadDanceMaidDressData(string filePath, List<string> labelData)
        {
            try
            {
                var dressDic = new Dictionary<string, Dictionary<string, string>>();
                var table = XDocument.Load(@filePath).Element("MaidDress").Elements("dress");
                foreach (var row in table)
                {
                    var dic = new Dictionary<string, string>();
                    var label = GetAttribute(row, "label");
                    if (labelData.Exists(l => l == label))
                    {
                        foreach (var key in MyConst.DRESS_TAG.Keys)
                        {
                            dic[key] = GetElement(row, key);
                        }
                        dressDic[label] = dic;
                    }
                }
                return dressDic;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// 衣装グループファイルデータ読み込み（メイド名指定）
        /// </summary>
        public Dictionary<string, string> ReadDressGroupMaidData(string filePath, string label)
        {
            try
            {
                var dressDic = new Dictionary<string, string>();
                var table = XDocument.Load(@filePath).Element("MaidDressGroup").Elements("dressGroup");
                foreach (var row in table)
                {
                    if (label == GetAttribute(row, "label"))
                    {
                        foreach (var dress in row.Elements("dress"))
                        {
                            var name = GetAttribute(dress, "name");
                            if (!string.IsNullOrEmpty(name))
                            {
                                dressDic[name] = GetAttribute(dress, "label");
                            }
                        }
                    }
                }
                return dressDic;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// 衣装グループファイルデータ読み込み
        /// </summary>
        public List<string> ReadDressGroupData(string filePath, string label)
        {
            try
            {
                var data = new List<string>();
                var table = XDocument.Load(@filePath).Element("MaidDressGroup").Elements("dressGroup");
                foreach (var row in table)
                {
                    if (label == GetAttribute(row, "label"))
                    {
                        foreach (var dress in row.Elements("dress"))
                        {
                            data.Add(GetAttribute(dress, "label"));
                        }
                    }
                }
                return data;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// 衣装メニューファイルデータ読み込み
        /// </summary>
        public MaidDressMenuSet ReadDressMenuData(string filePath, string label)
        {
            var menuSet = new MaidDressMenuSet();
            try
            {
                var table = XDocument.Load(@filePath).Element("MaidDressMenu").Elements("dressMenu");
                foreach (var row in table)
                {
                    if (label == GetAttribute(row, "label"))
                    {
                        menuSet.label = label;
                        menuSet.type = GetAttribute(row, "type");
                        var data = new List<string>();
                        foreach (var menu in row.Elements("menu"))
                        {
                            data.Add(menu.Value);
                        }
                        menuSet.fileNameList = data;
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return menuSet;
        }

        /// <summary>
        /// 髪ファイルデータ読み込み
        /// </summary>
        public Dictionary<string, Dictionary<string, DynamicBone>> ReadMaidHairDataAll(string filePath)
        {
            try
            {
                var hairDic = new Dictionary<string, Dictionary<string, DynamicBone>>();
                var hairTypes = XDocument.Load(@filePath).Element("MaidHair").Elements("hairType");
                foreach (var hairType in hairTypes)
                {
                    var dic = new Dictionary<string, DynamicBone>();
                    var type = GetAttribute(hairType, "type");
                    var hairs = hairType.Elements("hair");
                    foreach (var hair in hairs)
                    {
                        var menu = GetAttribute(hair, "menu");
                        var data = new DynamicBone();
                        data.m_Damping = GetElement(hair, "damping", MyConst.HAIR_DAMPING_DEFAULT);
                        data.m_Elasticity = GetElement(hair, "elasticity", MyConst.HAIR_ELASTICITY_DEFAULT);
                        data.m_Stiffness = GetElement(hair, "stiffness", MyConst.HAIR_STIFFNESS_DEFAULT);
                        data.m_Inert = GetElement(hair, "inert", MyConst.SWING_COMMON_MIN);
                        data.m_Radius = GetElement(hair, "radius", MyConst.HAIR_RADIUS_DEFAULT);
                        dic[menu] = data;
                    }
                    hairDic[type] = dic;
                }
                return hairDic;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// スカートファイルデータ読み込み
        /// </summary>
        public Dictionary<string, Dictionary<string, DynamicSkirtBone>> ReadMaidSkirtDataAll(string filePath)
        {
            try
            {
                var skirtDic = new Dictionary<string, Dictionary<string, DynamicSkirtBone>>();
                var skirtTypes = XDocument.Load(@filePath).Element("MaidSkirt").Elements("skirtType");
                foreach (var skirtType in skirtTypes)
                {
                    var dic = new Dictionary<string, DynamicSkirtBone>();
                    var type = GetAttribute(skirtType, "type");
                    var skirts = skirtType.Elements("skirt");
                    foreach (var skirt in skirts)
                    {
                        var menu = GetAttribute(skirt, "menu");
                        var data = new DynamicSkirtBone();
                        data.m_fPanierRadius = GetElement(skirt, "radius", MyConst.SKIRT_RADIUS_DEFAULT);
                        data.m_fVelocityForceRate = GetElement(skirt, "velocity", MyConst.SKIRT_VELOCITY_DEFAULT);
                        data.m_fPanierForce = GetElement(skirt, "force", MyConst.SKIRT_FORCE_DEFAULT);
                        data.m_fRegDefaultRadius = GetElement(skirt, "regRadius", MyConst.SKIRT_REG_RADIUS_DEFAULT);
                        data.m_fPanierStiffnessRate = GetElement(skirt, "stiffness", MyConst.SKIRT_STIFFNESS_DEFAULT);
                        data.m_fPanierStressForce = GetElement(skirt, "stress", MyConst.SKIRT_STRESS_DEFAULT);
                        data.m_fPanierForceDistanceThreshold = GetElement(skirt, "threshold", MyConst.SKIRT_THRESHOLD_DEFAULT);
                        dic[menu] = data;
                    }
                    skirtDic[type] = dic;
                }
                return skirtDic;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// ぶっかけファイルデータ読み込み
        /// </summary>
        public List<MaidBukkakeSet> ReadMaidBukkakeMenuData(string filePath, string label)
        {
            try
            {
                var bukkake = new List<MaidBukkakeSet>();
                var table = XDocument.Load(@filePath).Element("MaidBukkake").Elements("bukkakes");
                foreach (var row in table)
                {
                    if (label == GetAttribute(row, "label"))
                    {
                        foreach (var element in row.Elements("bukkake"))
                        {
                            var data = new MaidBukkakeSet(false);
                            var value = GetElement(element, "slot");
                            if (!string.IsNullOrEmpty(value))
                            {
                                var slot = value.Split(MyConst.DELIMITER_BUKKAKE);
                                var slotName = MyConst.BUKKAKE_TAG.Keys.ToList();
                                for (int i = 0; i < slotName.Count(); i++)
                                {
                                    if (slot.Contains(slotName[i]))
                                    {
                                        data.slotNo[i] = true;
                                    }
                                }
                            }
                            for (int h = 0; h < data.fileNo.GetLength(0); h++)
                            {
                                value = GetElement(element, h == 0 ? "file" : "fileR");
                                if (!string.IsNullOrEmpty(value))
                                {
                                    var file = value.Split(MyConst.DELIMITER_BUKKAKE);
                                    foreach (var i in file)
                                    {
                                        data.fileNo[h, int.Parse(i) - 1] = true;
                                    }
                                }
                            }

                            data.repeat = GetElement(element, "repeat", 0);
                            data.repeat = Mathf.Clamp(data.repeat, MyConst.BUKKAKE_REPEAT_MIN, MyConst.BUKKAKE_FILE_MAX);
                            var e = element.Element("positionX");
                            data.min.x = GetAttribute(e, "min", 0f);
                            data.max.x = GetAttribute(e, "max", 0f);
                            e = element.Element("positionY");
                            data.min.y = GetAttribute(e, "min", 0f);
                            data.max.y = GetAttribute(e, "max", 0f);
                            e = element.Element("rotation");
                            data.min.z = GetAttribute(e, "min", 0f);
                            data.max.z = GetAttribute(e, "max", 0f);
                            e = element.Element("scale");
                            data.min.w = GetAttribute(e, "min", 0f);
                            data.max.w = GetAttribute(e, "max", 0f);
                            
                            bukkake.Add(data);
                        }
                        break;
                    }
                }
                return bukkake;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// 動くメイドデータ読み込み
        /// </summary>
        public List<MaidMovingSet> ReadMaidMovingData(string filePath, string label)
        {
            try
            {
                var moveSet = new List<MaidMovingSet>();
                var table = XDocument.Load(@filePath).Element("MaidMoving").Elements("moveSet");
                foreach (var row in table)
                {
                    if (label == GetAttribute(row, "label"))
                    {
                        for (int i = 0; i < Enum.GetNames(typeof(MaidMovingType)).Length; i++)
                        {
                            var data = new MaidMovingSet();
                            data.animationData = new List<MaidMovingAnimationSet>();
                            data.folder = GetElement(row, "folder");
                            data.forwardSpeed = GetElement(row, "forwardSpeed", MyConst.MIAD_MOVE_FORWARD);

                            var move = row.Element(i == (int)MaidMovingType.Wait ? "wait" : "move");
                            data.status = i;
                            data.animationType = GetElement(move, "animationType", i);

                            foreach (var d in move.Elements("animation"))
                            {
                                var anm = new MaidMovingAnimationSet();
                                anm.animation = d.Value;
                                anm.fadeTime = GetAttribute(d, "fade", 0f);
                                anm.waitTime = GetAttribute(d, "wait", 0f);
                                data.animationData.Add(anm);
                            }
                            moveSet.Add(data);
                        }
                        break;
                    }
                }
                return moveSet;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// サブライトデータ取得
        /// </summary>
        public FreeLightSet ReadSubLightData(string filePath)
        {
            var data = new FreeLightSet();
            try
            {
                var table = XDocument.Load(@filePath).Element("Light").Element("SubLight");
                data.color = new Color32(
                        GetColorElement(table, "colorR"),
                        GetColorElement(table, "colorG"),
                        GetColorElement(table, "colorB"),
                        MyConst.COLOR_MAX);
                data.rotation = new Vector3(
                    GetElement(table, "rotationX", MyConst.CAMERA_DEFAULT),
                    GetElement(table, "rotationY", MyConst.CAMERA_DEFAULT),
                    GetElement(table, "rotationXZ", MyConst.CAMERA_DEFAULT));
                data.shadowStrength = GetElement(table, "shadowStrength", MyConst.LIGHT_SHADOW_STRENGTH);
                data.intensity = GetElement(table, "intensity", MyConst.LIGHT_INTENSITY);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return data;
        }

        /// <summary>
        /// スポットライトデータ取得
        /// </summary>
        public List<FreeLightSet> ReadSpotLightData(string filePath, string lable)
        {
            try
            {
                var lightData = new List<FreeLightSet>();
                var table = XDocument.Load(@filePath).Element("Light").Element("SpotLights");

                foreach (var row in table.Elements("spotLightGroup"))
                {
                    if (lable == GetAttribute(row, "label"))
                    {
                        foreach (var light in row.Elements("spotLight"))
                        {
                            var data = new FreeLightSet();
                            data.color = new Color32(
                                GetColorElement(light, "colorR"),
                                GetColorElement(light, "colorG"),
                                GetColorElement(light, "colorB"),
                                MyConst.COLOR_MAX);
                            data.position = new Vector3(
                                GetElement(light, "positionX", MyConst.CAMERA_DEFAULT),
                                GetElement(light, "positionY", MyConst.CAMERA_DEFAULT),
                                GetElement(light, "positionZ", MyConst.CAMERA_DEFAULT));
                            data.rotation = new Vector3(
                                GetElement(light, "rotationX", MyConst.CAMERA_DEFAULT),
                                GetElement(light, "rotationY", MyConst.CAMERA_DEFAULT),
                                GetElement(light, "rotationZ", MyConst.CAMERA_DEFAULT));
                            data.intensity = GetElement(light, "intensity", MyConst.LIGHT_INTENSITY);
                            data.range = GetElement(light, "range", MyConst.LIGHT_RANGE);
                            data.spotAngle = GetElement(light, "spotAngle", MyConst.LIGHT_SPOTANGLE);
                            data.isFollowing = false;
                            lightData.Add(data);
                        }
                    }
                }
                return lightData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// ポイントライトデータ取得
        /// </summary>
        public List<FreeLightSet> ReadPointLightData(string filePath, string lable)
        {
            try
            {
                var lightData = new List<FreeLightSet>();
                var table = XDocument.Load(@filePath).Element("Light").Element("PointLights");

                foreach (var row in table.Elements("pointLightGroup"))
                {
                    if (lable == GetAttribute(row, "label"))
                    {
                        foreach (var light in row.Elements("pointLight"))
                        {
                            var data = new FreeLightSet();
                            data.color = new Color32(
                                GetColorElement(light, "colorR"),
                                GetColorElement(light, "colorG"),
                                GetColorElement(light, "colorB"),
                                MyConst.COLOR_MAX);
                            data.position = new Vector3(
                                GetElement(light, "positionX", MyConst.CAMERA_DEFAULT),
                                GetElement(light, "positionY", MyConst.CAMERA_DEFAULT),
                                GetElement(light, "positionZ", MyConst.CAMERA_DEFAULT));
                            data.intensity = GetElement(light, "intensity", MyConst.LIGHT_INTENSITY);
                            data.range = GetElement(light, "range", MyConst.LIGHT_RANGE);
                            data.isFollowing = false;
                            lightData.Add(data);
                        }
                    }
                }
                return lightData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// 舞台道具データ取得
        /// </summary>
        public List<FreeStageObjectSet> ReadStageObjectData(string filePath, string lable)
        {
            try
            {
                var stageData = new List<FreeStageObjectSet>();
                var table = XDocument.Load(@filePath).Element("StageObject");

                foreach (var row in table.Elements("objectGroup"))
                {
                    if (lable == GetAttribute(row, "label"))
                    {
                        foreach (var stage in row.Elements("object"))
                        {
                            var data = new FreeStageObjectSet();
                            data.color = new Color32(
                                GetColorElement(stage, "colorR"),
                                GetColorElement(stage, "colorG"),
                                GetColorElement(stage, "colorB"),
                                GetColorElement(stage, "colorA"));
                            data.position = new Vector3(
                                GetElement(stage, "positionX", MyConst.CAMERA_DEFAULT),
                                GetElement(stage, "positionY", MyConst.CAMERA_DEFAULT),
                                GetElement(stage, "positionZ", MyConst.CAMERA_DEFAULT));
                            data.rotation = new Vector3(
                                GetElement(stage, "rotationX", MyConst.CAMERA_DEFAULT),
                                GetElement(stage, "rotationY", MyConst.CAMERA_DEFAULT),
                                GetElement(stage, "rotationZ", MyConst.CAMERA_DEFAULT));
                            data.scale = new Vector3(
                                GetElement(stage, "scaleX", MyConst.SCALE_DEFAULT),
                                GetElement(stage, "scaleY", MyConst.SCALE_DEFAULT),
                                GetElement(stage, "scaleZ", MyConst.SCALE_DEFAULT));
                            data.allScale = MyConst.SCALE_DEFAULT;
                            data.textureName = GetElement(stage, "textureName");
                            data.isTrans = GetElement(stage, "isTrans", 0) == MyConst.FILE_TRUE;
                            data.isLight = GetElement(stage, "isLight", 0) == MyConst.FILE_TRUE;
                            data.isUnlight = GetElement(stage, "isUnlight", 0) == MyConst.FILE_TRUE;
                            data.isRepeat = GetElement(stage, "isRepeat", 0) == MyConst.FILE_TRUE;
                            data.textureScaleX = GetElement(stage, "textureScaleX", MyConst.SCALE_DEFAULT);
                            data.textureScaleY = GetElement(stage, "textureScaleY", MyConst.SCALE_DEFAULT);
                            data.key = GetAttribute(stage, "type");

                            data.videoMgr = new VideoManager(true);
                            data.videoMgr.VideoName = GetElement(stage, "videoName");

                            data.lineSet = new FreeLineSet();
                            data.lineSet.length = MyConst.SCALE_DEFAULT;
                            data.lineSet.type = GetElement(stage, "lineType");
                            data.lineSet.frameWidth = GetElement(stage, "frameWidth", 0f);
                            data.lineSet.numCornerVertices = GetElement(stage, "numCornerVertices", 0);

                            data.curevedSet = new FreeCurevedSet();
                            data.curevedSet.width = GetElement(stage, "curveWidth", 0f);
                            data.curevedSet.height = GetElement(stage, "curveHight", 0f);
                            data.curevedSet.depth = GetElement(stage, "curveDepth", 0f);
                            data.curevedSet.points = GetElement(stage, "curvePoints", 0);
                            data.curevedSet.angle = GetElement(stage, "curveAngle", 0f);
                            stageData.Add(data);
                        }
                    }
                }
                return stageData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// 背景ファイルデータ読み込み
        /// </summary>
        public Dictionary<string, FreeBgSet> ReadBackgroundData(string filePath)
        {
            try
            {
                FreeBgSet data;
                var dic = new Dictionary<string, FreeBgSet>();
                var table = XDocument.Load(@filePath).Element("Background").Elements("bg");
                foreach (var row in table)
                {
                    var label = GetAttribute(row, "label");
                    data = new FreeBgSet();
                    data.bgName = GetElement(row, "bgName");
                    data.position = new Vector3(
                                        GetElement(row, "positionX", MyConst.CAMERA_DEFAULT),
                                        GetElement(row, "positionY", MyConst.CAMERA_DEFAULT),
                                        GetElement(row, "positionZ", MyConst.CAMERA_DEFAULT));
                    data.rotation = new Vector3(
                                        GetElement(row, "rotationX", MyConst.CAMERA_DEFAULT),
                                        GetElement(row, "rotationY", MyConst.CAMERA_DEFAULT),
                                        GetElement(row, "rotationZ", MyConst.CAMERA_DEFAULT));
                    data.scale = GetElement(row, "scale", MyConst.SCALE_DEFAULT);
                    data.isRandom = GetElement(row, "random", 0) == MyConst.FILE_TRUE;
                    dic[label] = data;
                }
                data = new FreeBgSet();
                data.bgName = "";
                dic[""] = data;
                return dic;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// 背景パーツファイルデータ読み込み
        /// </summary>
        public List<FreeBgPartsSet> ReadBackgroundPartsData(string filePath, string lable)
        {
            try
            {
                var partsData = new List<FreeBgPartsSet>();
                var table = XDocument.Load(@filePath).Element("BackgroundParts").Elements("partsGroup");
                foreach (var row in table)
                {
                    if (lable == GetAttribute(row, "label"))
                    {
                        foreach (var bg in row.Elements("background"))
                        {
                            var data = new FreeBgPartsSet();
                            data.bgName = GetAttribute(bg, "name");
                            data.partsName = new List<string>();
                            data.bgData = new GameObject();
                            foreach (var parts in bg.Elements("parts"))
                            {
                                data.partsName.Add(parts.Value);
                            }
                            data.position = new Vector3(
                                                GetElement(bg, "positionX", MyConst.CAMERA_DEFAULT),
                                                GetElement(bg, "positionY", MyConst.CAMERA_DEFAULT),
                                                GetElement(bg, "positionZ", MyConst.CAMERA_DEFAULT));
                            data.rotation = new Vector3(
                                                GetElement(bg, "rotationX", MyConst.CAMERA_DEFAULT),
                                                GetElement(bg, "rotationY", MyConst.CAMERA_DEFAULT),
                                                GetElement(bg, "rotationZ", MyConst.CAMERA_DEFAULT));
                            data.scale = new Vector3(
                                                GetElement(bg, "scaleX", MyConst.SCALE_DEFAULT),
                                                GetElement(bg, "scaleY", MyConst.SCALE_DEFAULT),
                                                GetElement(bg, "scaleZ", MyConst.SCALE_DEFAULT));
                            partsData.Add(data);
                        }
                    }
                }
                return partsData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// モデルファイルデータ読み込み
        /// </summary>
        public List<FreeModelSet> ReadModelData(string filePath, string lable)
        {
            try
            {
                var modelData = new List<FreeModelSet>();
                var table = XDocument.Load(@filePath).Element("StageModel");
                foreach (var row in table.Elements("modelGroup"))
                {
                    if (lable == GetAttribute(row, "label"))
                    {
                        foreach (var model in row.Elements("model"))
                        {
                            var data = new FreeModelSet();
                            data.viewName = lable;
                            data.modelName = GetAttribute(model, "name");
                            data.position = new Vector3(
                                GetElement(model, "positionX", MyConst.CAMERA_DEFAULT),
                                GetElement(model, "positionY", MyConst.CAMERA_DEFAULT),
                                GetElement(model, "positionZ", MyConst.CAMERA_DEFAULT));
                            data.rotation = new Vector3(
                                GetElement(model, "rotationX", MyConst.CAMERA_DEFAULT),
                                GetElement(model, "rotationY", MyConst.CAMERA_DEFAULT),
                                GetElement(model, "rotationZ", MyConst.CAMERA_DEFAULT));
                            data.scale = new Vector3(
                                GetElement(model, "scaleX", MyConst.SCALE_DEFAULT),
                                GetElement(model, "scaleY", MyConst.SCALE_DEFAULT),
                                GetElement(model, "scaleZ", MyConst.SCALE_DEFAULT));
                            data.allScale = MyConst.SCALE_DEFAULT;
                            modelData.Add(data);
                        }
                    }
                }
                return modelData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// パーティクルファイルデータ読み込み
        /// </summary>
        public FreeBubbleLameSet ReadBubbleLameData(string filePath, string lable)
        {
            var data = new FreeBubbleLameSet();
            try
            {
                var table = XDocument.Load(@filePath).Element("StageParticle");
                foreach (var particle in table.Elements("particle"))
                {
                    if (lable == GetAttribute(particle, "label"))
                    {
                        data.label = lable;
                        data.type = GetAttribute(particle, "type");
                        data.minSize = GetElement(particle, "minSize", 0f);
                        data.maxSize = GetElement(particle, "maxSize", 0f);
                        data.minEnergy = GetElement(particle, "minEnergy", 0f);
                        data.maxEnergy = GetElement(particle, "maxEnergy", 0f);
                        data.minEmission = GetElement(particle, "minEmission", 0f);
                        data.maxEmission = GetElement(particle, "maxEmission", 0f);
                        data.worldVelocity = new Vector3(
                            GetElement(particle, "worldVelocityX", 0f),
                            GetElement(particle, "worldVelocityY", 0f),
                            GetElement(particle, "worldVelocityZ", 0f));
                        data.rndVelocity = new Vector3(
                            GetElement(particle, "rndVelocityX", 0f),
                            GetElement(particle, "rndVelocityY", 0f),
                            GetElement(particle, "rndVelocityZ", 0f));
                        data.angularVelocity = GetElement(particle, "angularVelocity", 0f);
                        data.rndAngularVelocity = GetElement(particle, "rndAngularVelocity", 0f);
                        data.rndRotation = GetElement(particle, "rndRotation", 0) == MyConst.FILE_TRUE;
                        data.position = new Vector3(
                            GetElement(particle, "positionX", 0f),
                            GetElement(particle, "positionY", 0f),
                            GetElement(particle, "positionZ", 0f));
                        data.rotation = new Vector3(
                            GetElement(particle, "rotationX", 0f),
                            GetElement(particle, "rotationY", 0f),
                            GetElement(particle, "rotationZ", 0f));
                        data.color = new Color32(
                            GetColorElement(particle, "colorR"),
                            GetColorElement(particle, "colorG"),
                            GetColorElement(particle, "colorB"),
                            GetColorElement(particle, "colorA"));
                        data.textureName = GetElement(particle, "textureName");
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return data;
        }

        /// <summary>
        /// フェイスファイルデータ読み込み
        /// </summary>
        public List<DanceFaceSet> ReadDanceFaceData(string filePath)
        {
            try
            {
                var faceData = new List<DanceFaceSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new DanceFaceSet();
                    data.time = float.Parse(value[0]);
                    data.face = value[1];
                    data.blend = value[2];
                    var eyeMoveType = MyConst.PRE_INDEX;
                    var frame = MyConst.PRE_INDEX;
                    if (3 < value.Count())
                    {
                        eyeMoveType = int.Parse(value[3]);
                        frame = int.Parse(value[4]);
                    }
                    data.eyeMoveType = (Maid.EyeMoveType)eyeMoveType;
                    data.frame = frame;
                    data.faceOpMorph = new Dictionary<string, float>();
                    if (!string.IsNullOrEmpty(data.blend))
                    {
                        foreach (var pair in MyConst.FACE_OPTION_MORPH)
                        {
                            data.faceOpMorph[pair.Key] = data.blend.Contains(pair.Value.Substring(2)) ? MyConst.FACE_BLEND_VALUE : 0f;
                        }
                    }
                    faceData.Add(data);
                }
                return faceData.OrderBy(d => d.time).ToList();
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// アニメーションファイルデータ読み込み
        /// </summary>
        private List<DanceAnimationSet> ReadDanceAnimationData(string filePath)
        {
            try
            {
                var anmData = new List<DanceAnimationSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new DanceAnimationSet();
                    data.time = float.Parse(value[0]);
                    data.animation = value[1];
                    anmData.Add(data);
                }
                return anmData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// マウスファイルデータ読み込み
        /// </summary>
        private string ReadDanceMouthData(string filePath)
        {
            try
            {
                var lines = File.ReadAllLines(@filePath);
                return (lines.GetLength(0) > 1) ? lines[1] : "";
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return "";
            }
        }

        /// <summary>
        /// メイド変更ファイルデータ読み込み
        /// </summary>
        public List<DanceVisibleMaidSet> ReadDanceCahngeMaidData(string filePath)
        {
            try
            {
                var changeData = new List<DanceVisibleMaidSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new DanceVisibleMaidSet();
                    data.time = float.Parse(value[0]);
                    for (int j = 1; j < value.GetLength(0); j++)
                    {
                        var lst = new List<int> { MyConst.NO_DATA };
                        if (!string.IsNullOrEmpty(value[j]))
                        {
                            lst = value[j].Split(MyConst.DELIMITER_STRING).Select(a => int.Parse(a)).ToList();
                        }
                        if (j == 1)
                        {
                            data.visible = lst;
                        }
                        else
                        {
                            data.inVisible = lst;
                        }
                    }
                    changeData.Add(data);
                }
                return changeData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// ダンス衣装変更データ取得
        /// </summary>
        public List<DanceDressSet> ReadDanceCahngeDressData(string filePath)
        {
            try
            {
                var dressData = new List<DanceDressSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new DanceDressSet();
                    data.label = value[0];
                    data.slotNo = int.Parse(value[1]);
                    data.time = float.Parse(value[2]);
                    dressData.Add(data);
                }
                return dressData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// ダンス脱衣データ取得
        /// </summary>
        public List<DanceUndressSet> ReadDanceCahngeUndressData(string filePath)
        {
            try
            {
                var undressData = new List<DanceUndressSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new DanceUndressSet();
                    data.label = value[0];
                    data.slotNo = int.Parse(value[1]);
                    data.time = float.Parse(value[2]);
                    data.isMasked = true;
                    undressData.Add(data);
                }
                return undressData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// 背景変更ファイルデータ読み込み
        /// </summary>
        public List<DanceBgSet> ReadDanceCahngeBgData(string filePath)
        {
            try
            {
                var changeData = new List<DanceBgSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new DanceBgSet();
                    data.transform = new MyTransform();
                    data.bgName = value[0];
                    data.groupNo = int.Parse(value[1]);
                    data.changeTime = float.Parse(value[2]);
                    data.transform.stPos = new Vector3(float.Parse(value[3]), float.Parse(value[4]), float.Parse(value[5]));
                    data.transform.stRot = new Vector3(float.Parse(value[6]), float.Parse(value[7]), float.Parse(value[8]));
                    data.scale = float.Parse(value[9]);
                    changeData.Add(data);
                }
                return changeData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// PNG変更ファイルデータ読み込み
        /// </summary>
        public List<DancePngSet> ReadDanceCahngePngData(string filePath)
        {
            try
            {
                var changeData = new List<DancePngSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new DancePngSet();
                    data.transform = new MyTransform();
                    data.pngName = value[0];
                    data.stTime = float.Parse(value[1]);
                    data.edTime = float.Parse(value[2]);
                    data.transform.stPos = new Vector3(float.Parse(value[3]), float.Parse(value[4]), float.Parse(value[5]));
                    data.transform.stRot = new Vector3(float.Parse(value[6]), float.Parse(value[7]), float.Parse(value[8]));
                    changeData.Add(data);
                }
                return changeData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// アイテムファイルデータ読み込み
        /// </summary>
        public List<DanceItemSet> ReadDanceCahngeItemData(string filePath)
        {
            try
            {
                var changeData = new List<DanceItemSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new DanceItemSet();
                    data.tag = value[0];
                    data.menu = value[1];
                    data.activeSlotNo = int.Parse(value[2]);
                    data.stTime = float.Parse(value[3]);
                    data.edTime = float.Parse(value[4]);
                    data.option = value[5];
                    data.isSet = false;
                    changeData.Add(data);
                }
                return changeData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// Prefabファイルデータ読み込み
        /// </summary>
        public List<DancePrefabSet> ReadDanceCahngePrefabData(string filePath)
        {
            try
            {
                var changeData = new List<DancePrefabSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new DancePrefabSet();
                    data.name = value[0];
                    data.group = int.Parse(value[1]);
                    data.stTime = float.Parse(value[2]);
                    data.transform.stPos
                        = new Vector3(float.Parse(value[3]),
                                      float.Parse(value[4]),
                                      float.Parse(value[5]));
                    data.transform.stRot
                        = new Vector3(float.Parse(value[6]),
                                      float.Parse(value[7]),
                                      float.Parse(value[8]));
                    data.transform.stSca
                        = new Vector3(float.Parse(value[9]),
                                      float.Parse(value[10]),
                                      float.Parse(value[11]));
                    data.edTime = float.Parse(value[12]);
                    data.transform.edPos
                        = new Vector3(float.Parse(value[13]),
                                      float.Parse(value[14]),
                                      float.Parse(value[15]));
                    data.transform.edRot
                        = new Vector3(float.Parse(value[16]),
                                      float.Parse(value[17]),
                                      float.Parse(value[18]));
                    data.transform.edSca
                        = new Vector3(float.Parse(value[19]),
                                      float.Parse(value[20]),
                                      float.Parse(value[21]));
                    data.option = value[22];
                    data.maidSlotNo = int.Parse(value[23]);
                    data.isBubble = data.option.ToLower().Contains(MyConst.OBJECT_OPTION_BUBBLE);
                    data.deltaTime = data.edTime - data.stTime;
                    data.lerpTime = 0;
                    changeData.Add(data);
                }
                return changeData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// メイドPrefabファイルデータ読み込み
        /// </summary>
        public List<DanceMaidPrefabSet> ReadDanceCahngeMaidPrefabData(string filePath)
        {
            try
            {
                var changeData = new List<DanceMaidPrefabSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new DanceMaidPrefabSet();
                    data.name = value[0];
                    data.group = int.Parse(value[1]);
                    data.maidSlotNo = int.Parse(value[2]);
                    data.maidBone = value[3];
                    data.stTime = float.Parse(value[4]);
                    data.edTime = float.Parse(value[5]);
                    data.transform.stPos
                        = new Vector3(float.Parse(value[6]),
                                      float.Parse(value[7]),
                                      float.Parse(value[8]));
                    data.transform.stRot
                        = new Vector3(float.Parse(value[9]),
                                      float.Parse(value[10]),
                                      float.Parse(value[11]));
                    data.option = value[12];
                    data.isAdded = false;
                    changeData.Add(data);
                }
                return changeData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// Primitiveファイルデータ読み込み
        /// </summary>
        public List<DancePrimitiveSet> ReadDanceCahngePrimitiveData(string filePath)
        {
            try
            {
                var changeData = new List<DancePrimitiveSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new DancePrimitiveSet();
                    data.type = value[0];
                    data.group = int.Parse(value[1]);
                    data.stTime = float.Parse(value[2]);
                    data.transform.stPos
                        = new Vector3(float.Parse(value[3]),
                                      float.Parse(value[4]),
                                      float.Parse(value[5]));
                    data.transform.stRot
                        = new Vector3(float.Parse(value[6]),
                                      float.Parse(value[7]),
                                      float.Parse(value[8]));
                    data.transform.stSca
                        = new Vector3(float.Parse(value[9]),
                                      float.Parse(value[10]),
                                      float.Parse(value[11]));
                    data.edTime = float.Parse(value[12]);
                    data.transform.edPos
                        = new Vector3(float.Parse(value[13]),
                                      float.Parse(value[14]),
                                      float.Parse(value[15]));
                    data.transform.edRot
                        = new Vector3(float.Parse(value[16]),
                                      float.Parse(value[17]),
                                      float.Parse(value[18]));
                    data.transform.edSca
                        = new Vector3(float.Parse(value[19]),
                                      float.Parse(value[20]),
                                      float.Parse(value[21]));
                    data.option = value[22];
                    data.stColor.x = GetColorByte(value[23]);
                    data.stColor.y = GetColorByte(value[24]);
                    data.stColor.z = GetColorByte(value[25]);
                    data.stColor.w = GetColorByte(value[26]);
                    data.edColor.x = GetColorByte(value[27]);
                    data.edColor.y = GetColorByte(value[28]);
                    data.edColor.z = GetColorByte(value[29]);
                    data.edColor.w = GetColorByte(value[30]);
                    data.texture = value[31];
                    data.textureSize
                       = new Vector2(float.Parse(value[32]),
                                     float.Parse(value[33]));
                    data.shader = value[34];
                    data.maidSlotNo = int.Parse(value[35]);
                    data.isFlashing = data.option.Contains(MyConst.OBJECT_OPTION_FLASHING);
                    data.deltaTime = data.edTime - data.stTime;
                    data.lerpTime = 0;
                    changeData.Add(data);
                }
                return changeData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// Particleファイルデータ読み込み
        /// </summary>
        public List<DancePartticleSet> ReadDanceCahngeParticleData(string filePath)
        {
            try
            {
                var changeData = new List<DancePartticleSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new DancePartticleSet();
                    data.label = value[0];
                    data.group = int.Parse(value[1]);
                    data.stTime = float.Parse(value[2]);
                    data.transform.stPos
                        = new Vector3(float.Parse(value[3]),
                                      float.Parse(value[4]),
                                      float.Parse(value[5]));
                    data.transform.stRot
                        = new Vector3(float.Parse(value[6]),
                                      float.Parse(value[7]),
                                      float.Parse(value[8]));
                    data.transform.stSca
                       = new Vector3(float.Parse(value[9]),
                                     float.Parse(value[10]),
                                     float.Parse(value[11]));
                    data.edTime = float.Parse(value[12]);
                    data.transform.edPos
                        = new Vector3(float.Parse(value[13]),
                                      float.Parse(value[14]),
                                      float.Parse(value[15]));
                    data.transform.edRot
                        = new Vector3(float.Parse(value[16]),
                                      float.Parse(value[17]),
                                      float.Parse(value[18]));
                    data.transform.edSca
                       = new Vector3(float.Parse(value[19]),
                                     float.Parse(value[20]),
                                     float.Parse(value[21]));
                    data.option = value[22];
                    data.maidSlotNo = int.Parse(value[23]);
                    data.deltaTime = data.edTime - data.stTime;
                    data.lerpTime = 0;
                    changeData.Add(data);
                }
                return changeData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// Lightファイルデータ読み込み
        /// </summary>
        public List<DanceLightSet> ReadDanceCahngeLightData(string filePath)
        {
            try
            {
                var changeData = new List<DanceLightSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new DanceLightSet();
                    data.type = value[0];
                    data.group = int.Parse(value[1]);
                    data.stTime = float.Parse(value[2]);
                    data.transform.stPos
                        = new Vector3(float.Parse(value[3]),
                                      float.Parse(value[4]),
                                      float.Parse(value[5]));
                    data.transform.stRot
                        = new Vector3(float.Parse(value[6]),
                                      float.Parse(value[7]),
                                      float.Parse(value[8]));
                    data.stColor.x = GetColorByte(value[9]);
                    data.stColor.y = GetColorByte(value[10]);
                    data.stColor.z = GetColorByte(value[11]);
                    data.edTime = float.Parse(value[12]);
                    data.transform.edPos
                        = new Vector3(float.Parse(value[13]),
                                      float.Parse(value[14]),
                                      float.Parse(value[15]));
                    data.transform.edRot
                        = new Vector3(float.Parse(value[16]),
                                      float.Parse(value[17]),
                                      float.Parse(value[18]));
                    data.edColor.x = GetColorByte(value[19]);
                    data.edColor.y = GetColorByte(value[20]);
                    data.edColor.z = GetColorByte(value[21]);
                    data.option = value[22];
                    data.range = float.Parse(value[23]);
                    data.intensity = float.Parse(value[24]);
                    data.spotAngle = float.Parse(value[25]);
                    data.maidSlotNo = int.Parse(value[26]);
                    data.deltaTime = data.edTime - data.stTime;
                    data.lerpTime = 0;
                    changeData.Add(data);
                }
                return changeData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// 歌マウスファイルデータ読み込み
        /// </summary>
        public List<SongMouthSet> ReadSongMouthData(string filePath)
        {
            try
            {
                var mouthData = new List<SongMouthSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var data = new SongMouthSet();
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    data.stTime = float.Parse(value[0]);
                    data.character = value[1];
                    mouthData.Add(data);
                }
                return mouthData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// 歌ポーズファイルデータ読み込み
        /// </summary>
        public List<SongPoseSet> ReadSongPoseData(string filePath)
        {
            try
            {
                var poseData = new List<SongPoseSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new SongPoseSet();
                    data.time = float.Parse(value[0]);
                    data.poseType = int.Parse(value[1]);
                    data.animation = value[2];
                    if(data.poseType == (int)SongPoseType.DanceAnimationTime ||
                       data.poseType == (int)SongPoseType.OldDanceAnimationTime)
                    {
                        data.startTime = float.Parse(value[3]);
                    }
                    else
                    {
                        data.fadeTime = float.Parse(value[3]);
                    }
                    data.speed = float.Parse(value[4]);
                    data.position = new Vector3(float.Parse(value[5]), float.Parse(value[6]), float.Parse(value[7]));
                    data.rotation = new Vector3(float.Parse(value[8]), float.Parse(value[9]), float.Parse(value[10]));
                    data.eyeMoveType = (Maid.EyeMoveType)int.Parse(value[11]);
                    data.option = value[12];
                    data.loopIndex = MyConst.PRE_INDEX;
                    data.loopData = new List<SongLoopPoseSet>();
                    poseData.Add(data);
                }
                return poseData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// 歌ループポーズファイルデータ読み込み
        /// </summary>
        public List<SongLoopPoseSet> ReadSongLoopPoseData(string filePath)
        {
            try
            {
                var poseData = new List<SongLoopPoseSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new SongLoopPoseSet();
                    data.loopName = value[0];
                    data.loopNo = int.Parse(value[1]);
                    data.animation = value[2];
                    data.fadeTime = float.Parse(value[3]);
                    data.position = new Vector3(float.Parse(value[4]), float.Parse(value[5]), float.Parse(value[6]));
                    data.rotation = new Vector3(float.Parse(value[7]), float.Parse(value[8]), float.Parse(value[9]));
                    poseData.Add(data);
                }
                return poseData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// タイムラインモーションファイルデータ読み込み
        /// </summary>
        public List<MotionTimeLineSet> ReadTimelineMotionFileData(string filePath)
        {
            try
            {
                var motionData = new List<MotionTimeLineSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new MotionTimeLineSet();
                    data.frame = int.Parse(value[0]);
                    data.name = value[1];
                    data.rotation = new Vector3(float.Parse(value[2]), float.Parse(value[3]), float.Parse(value[4]));
                    if (data.name == MyConst.BONE_ALL)
                    {
                        data.position = new Vector3(float.Parse(value[5]), float.Parse(value[6]), float.Parse(value[7]));
                    }
                    data.easing = int.Parse(value[8]);
                    motionData.Add(data);
                }
                return motionData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// タイムライン表情ファイルデータ読み込み
        /// </summary>
        public List<MotionTimeLineSet> ReadTimelineMorphFileData(string filePath)
        {
            try
            {
                var morphData = new List<MotionTimeLineSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new MotionTimeLineSet();
                    data.frame = int.Parse(value[0]);
                    data.name = value[1];
                    data.morphValue = float.Parse(value[2]);
                    morphData.Add(data);
                }
                return morphData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// タイムラインカメラモーションファイルデータ読み込み
        /// </summary>
        public List<MotionTimeLineSet> ReadTimelineCameraFileData(string filePath)
        {
            try
            {
                var cameraData = new List<MotionTimeLineSet>();
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var data = new MotionTimeLineSet();
                    data.frame = int.Parse(value[0]);
                    data.position = new Vector3(float.Parse(value[1]), float.Parse(value[2]), float.Parse(value[3]));
                    data.rotation = new Vector3(float.Parse(value[4]), float.Parse(value[5]), float.Parse(value[6]));
                    data.distance = float.Parse(value[7]);
                    data.viewAngle = float.Parse(value[8]);
                    data.easing = int.Parse(value[9]);
                    cameraData.Add(data);
                }
                return cameraData;
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                return null;
            }
        }

        /// <summary>
        /// 注視・分割カメラデータ読み込み
        /// </summary>
        public MaidLookAtSet ReadLookAtData(string filePath, int settingIndex)
        {
            var data = new MaidLookAtSet();
            try
            {
                var xml = XDocument.Load(@filePath).Element("LookAt").Elements("setting");
                foreach (var row in xml)
                {
                    if (MyConst.LOOK_AT_SETTING_LABEL[settingIndex] == GetAttribute(row, "label"))
                    {
                        data.settingIndex = settingIndex;
                        data.lookAtIndex = GetElement(row, "lookAtIndex", 0);
                        data.isMaidEye = GetElement(row, "isMaidEye", 0) == MyConst.FILE_TRUE;
                        data.isMotionOn = GetElement(row, "isMotionOn", 0) == MyConst.FILE_TRUE;
                        data.randomTime = GetElement(row, "randomTime", 0f);
                        data.divisionSet = new MaidLookAtEachSet[MyConst.LOOK_AT_DIVISION];
                        foreach (var div in row.Elements("dividedCamera"))
                        {
                            data.dividedIndex = GetElement(div, "dividedIndex", 0);
                            foreach (var cam in div.Elements("camera"))
                            {
                                var index = GetAttribute(cam, "index", 0);
                                data.divisionSet[index].isLookAt = GetElement(cam, "isLookAt", 0) == MyConst.FILE_TRUE;
                                data.divisionSet[index].isOffsetX = GetElement(cam, "isOffsetX", 0) == MyConst.FILE_TRUE;
                                data.divisionSet[index].isFixedPosY = GetElement(cam, "isFixedPosY", 0) == MyConst.FILE_TRUE;
                                data.divisionSet[index].isFixedRotX = GetElement(cam, "isFixedRotX", 0) == MyConst.FILE_TRUE;
                                data.divisionSet[index].isFixedRotY = GetElement(cam, "isFixedRotY", 0) == MyConst.FILE_TRUE;
                                data.divisionSet[index].offsetX = GetElement(cam, "offsetX", 0);
                                data.divisionSet[index].fixedPosY = GetElement(cam, "fixedPosY", MyConst.LOOK_AT_FIXED_POS_Y);
                                data.divisionSet[index].fixedRotX = GetElement(cam, "fixedRotX", MyConst.LOOK_AT_FIXED_ROT_X);
                                data.divisionSet[index].fixedRotY = GetElement(cam, "fixedRotY", MyConst.LOOK_AT_FIXED_ROT_Y);
                                data.divisionSet[index].isRandomMaid = GetElement(cam, "isRandomMaid", 0) == MyConst.FILE_TRUE;
                                data.divisionSet[index].isRandomPoint = GetElement(cam, "isRandomPoint", 0) == MyConst.FILE_TRUE;
                                data.divisionSet[index].pointIndex = GetElement(cam, "pointIndex", 0);
                                data.divisionSet[index].typeIndex = GetElement(cam, "typeIndex", 0);
                                data.divisionSet[index].aroundTypeIndex = GetElement(cam, "aroundTypeIndex", 0);
                                data.divisionSet[index].distanceSlider = GetElement(cam, "distanceSlider", MyConst.LOOK_AT_DISTANCE);
                                data.divisionSet[index].autoCamera = new CameraTransformSet();
                                data.divisionSet[index].autoAngleIndex = MyConst.PRE_INDEX;
                            }
                        }
                        data.subSet = new MaidLookAtEachSet[MyConst.LOOK_AT_SUB];
                        foreach (var sub in row.Elements("subCamera"))
                        {
                            foreach (var cam in sub.Elements("camera"))
                            {
                                var index = GetAttribute(cam, "index", 0);
                                data.subSet[index].isLookAt = GetElement(cam, "isLookAt", 0) == MyConst.FILE_TRUE;
                                data.subSet[index].subSizeIndex = GetElement(cam, "subSizeIndex", 0);
                                data.subSet[index].isOffsetX = GetElement(cam, "isOffsetX", 0) == MyConst.FILE_TRUE;
                                data.subSet[index].isFixedPosY = GetElement(cam, "isFixedPosY", 0) == MyConst.FILE_TRUE;
                                data.subSet[index].isFixedRotX = GetElement(cam, "isFixedRotX", 0) == MyConst.FILE_TRUE;
                                data.subSet[index].isFixedRotY = GetElement(cam, "isFixedRotY", 0) == MyConst.FILE_TRUE;
                                data.subSet[index].offsetX = GetElement(cam, "offsetX", 0);
                                data.subSet[index].fixedPosY = GetElement(cam, "fixedPosY", MyConst.LOOK_AT_FIXED_POS_Y);
                                data.subSet[index].fixedRotX = GetElement(cam, "fixedRotX", MyConst.LOOK_AT_FIXED_ROT_X);
                                data.subSet[index].fixedRotY = GetElement(cam, "fixedRotY", MyConst.LOOK_AT_FIXED_ROT_Y);
                                data.subSet[index].isRandomMaid = GetElement(cam, "isRandomMaid", 0) == MyConst.FILE_TRUE;
                                data.subSet[index].isRandomPoint = GetElement(cam, "isRandomPoint", 0) == MyConst.FILE_TRUE;
                                data.subSet[index].pointIndex = GetElement(cam, "pointIndex", 0);
                                data.subSet[index].typeIndex = GetElement(cam, "typeIndex", 0);
                                data.subSet[index].aroundTypeIndex = GetElement(cam, "aroundTypeIndex", 0);
                                data.subSet[index].distanceSlider = GetElement(cam, "distanceSlider", MyConst.LOOK_AT_DISTANCE);
                                data.subSet[index].autoCamera = new CameraTransformSet();
                                data.subSet[index].autoAngleIndex = MyConst.PRE_INDEX;
                            }
                        }
                        break;
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
                data = new MaidLookAtSet();
            }
            return data;
        }

        /// <summary>
        /// オートカメラ読み込み
        /// </summary>
        public AutoCameraSet ReadAutoCameraData(string filePath, string label, bool isFirst)
        {
            var data = new AutoCameraSet();
            data.autoCamera = new CameraTransformSet();
            data.each = new AutoCameraEachSet[Enum.GetValues(typeof(LookAtAutoAngleType)).Length];
            try
            {
                var table = XDocument.Load(@filePath).Element("AutoCamera").Elements("autos");
                foreach (var row in table)
                {
                    if(isFirst || label == GetAttribute(row, "label"))
                    {
                        data.isRandomMaid = GetElement(row, "isRandomMaid", 0) == MyConst.FILE_TRUE;
                        var index = 0;
                        foreach (var element in row.Elements("auto"))
                        {
                            var d = new AutoCameraEachSet();
                            d.isAngleEnabled = GetElement(element, "isAngleEnabled", 0) == MyConst.FILE_TRUE ? true : false;
                            d.isBackEnabled = GetElement(element, "isBackEnabled", 0) == MyConst.FILE_TRUE ? true : false;
                            d.isInfrequent = GetElement(element, "isInfrequent", 0) == MyConst.FILE_TRUE ? true : false;
                            d.positionMin = new Vector3(
                                GetAttribute(element.Element("positionMin"), "x", 0f),
                                GetAttribute(element.Element("positionMin"), "y", 0f),
                                GetAttribute(element.Element("positionMin"), "z", MyConst.LOOK_AT_AUTO_MIN_Z));
                            d.positionMax = new Vector3(
                                GetAttribute(element.Element("positionMax"), "x", 0f),
                                GetAttribute(element.Element("positionMax"), "y", 0f),
                                GetAttribute(element.Element("positionMax"), "z", MyConst.LOOK_AT_AUTO_MIN_Z));
                            d.autoTime = new Vector2(
                                GetAttribute(element.Element("autoTime"), "min", MyConst.LOOK_AT_AUTO_TIME),
                                GetAttribute(element.Element("autoTime"), "max", MyConst.LOOK_AT_AUTO_TIME));
                            data.each[index] = d;
                            index++;
                        }
                        break;
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
            return data;
        }

        /// <summary>
        /// XML要素取得（string）
        /// </summary>
        private string GetElement(XElement e, string tag)
        {
            var val = "";
            if (e.Element(tag) != null)
            {
                val = e.Element(tag).Value;
            }
            return val;
        }

        /// <summary>
        /// XML要素取得（int）
        /// </summary>
        private int GetElement(XElement e, string tag, int nullVal)
        {
            return (int)GetElement(e, tag, (float)nullVal);
        }

        /// <summary>
        /// XML要素取得（float）
        /// </summary>
        private float GetElement(XElement e, string tag, float nullVal)
        {
            var val = nullVal;
            if (e.Element(tag) != null)
            {
                float f;
                val = float.TryParse(e.Element(tag).Value, out f) ? f : nullVal;
            }
            return val;
        }

        /// <summary>
        /// XML要素取得（color）
        /// </summary>
        private byte GetColorElement(XElement e, string tag)
        {
            return (byte)GetElement(e, tag, MyConst.COLOR_MAX);
        }

        /// <summary>
        /// XML属性取得（string）
        /// </summary>
        private string GetAttribute(XElement e, string tag)
        {
            var val = "";
            if (e.Attribute(tag) != null)
            {
                val = e.Attribute(tag).Value;
            }
            return val;
        }

        /// <summary>
        /// XML属性取得（int）
        /// </summary>
        private int GetAttribute(XElement e, string tag, int nullVal)
        {
            return (int)GetAttribute(e, tag, (float)nullVal);
        }

        /// <summary>
        /// XML属性取得（float）
        /// </summary>
        private float GetAttribute(XElement e, string tag, float nullVal)
        {
            var val = nullVal;
            if (e.Attribute(tag) != null)
            {
                float f;
                val = float.TryParse(e.Attribute(tag).Value, out f) ? f : nullVal;
            }
            return val;
        }

        /// <summary>
        /// XML要素取得（color）
        /// </summary>
        private byte GetColorAttribute(XElement e, string tag)
        {
            return (byte)GetAttribute(e, tag, MyConst.COLOR_MAX);
        }

        /// <summary>
        /// カラー用バイト範囲値
        /// </summary>
        private float GetColorByte(string value)
        {
            return Mathf.Clamp(float.Parse(value), MyConst.COLOR_MIN, MyConst.COLOR_MAX);
        }
    }

    /// <summary>
    /// ファイル出力処理
    /// </summary>
    public class FileWriter
    {

        /// <summary>
        /// Prefab一覧処理
        /// </summary>
        public void WritePrefabList()
        {
            try
            {
                Dictionary<string, string> prefab = new Dictionary<string, string>();
                var obj = Resources.LoadAll(MyConst.FOLDER_PREFAB, typeof(GameObject));
                foreach (GameObject t in obj)
                {
                    prefab[t.name] = t.name;
                }
                obj = Resources.LoadAll(MyConst.FOLDER_PREFAB + MyConst.FOLDER_PARTICLE, typeof(GameObject));
                foreach (GameObject t in obj)
                {
                    prefab[t.name] = MyConst.FOLDER_PARTICLE + "/" + t.name;
                }
                obj = Resources.LoadAll(MyConst.FOLDER_PREFAB + MyConst.FOLDER_PHOTOVER, typeof(GameObject));
                foreach (GameObject t in obj)
                {
                    prefab[t.name] = MyConst.FOLDER_PHOTOVER + "/" + t.name;
                }
                obj = Resources.LoadAll(MyConst.FOLDER_SHADER, typeof(Shader));
                foreach (Shader t in obj)
                {
                    prefab[t.name] = MyConst.FOLDER_SHADER + "/" + t.name;
                }

                var path = Path.Combine(MyHelper.RootFolder, MyConst.OBJECT_PREFAB + MyConst.EXTENSION_TXT);
                using (StreamWriter writer = new StreamWriter(path, false))
                {
                    foreach (var key in prefab.Keys)
                    {
                        writer.WriteLine(prefab[key]);
                    }
                }
                Resources.UnloadUnusedAssets();
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// リストファイル名出力
        /// </summary>
        public void WriteFileList(string filePath, string filterm, string extension)
        {
            try
            {
                using (StreamWriter writer = new StreamWriter(filePath, false))
                {
                    var allFiles = GameUty.FileSystem.GetList(filterm, AFileSystemBase.ListType.AllFile);
                    foreach (var file in allFiles)
                    {
                        if (extension == "" || Path.GetExtension(file) == extension)
                        {
                            writer.WriteLine(file);
                        }
                    }
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// 背景リスト追記
        /// </summary>
        public void WriteBackgroudList(string label, string bgName)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(MyConst.FILE_BACKGROUND, "");
                if (!string.IsNullOrEmpty(filePath))
                {
                    var backGround = GameMain.Instance.BgMgr.current_bg_object;
                    var position = backGround.transform.position;
                    var rotation = backGround.transform.eulerAngles;
                    var scale = backGround.transform.localScale.z;

                    var xml = XElement.Load(@filePath);
                    var data = xml.Elements("bg").FirstOrDefault(e => e.Attribute("label").Value == label);
                    var isNew = false;
                    if (data == null)
                    {
                        data = new XElement("bg");
                        data.Add(new XAttribute("label", label));
                        isNew = true;
                    }
                    SetXElement(ref data, "bgName", bgName);
                    if (position.x != 0)
                    {
                        SetXElement(ref data, "positionX", position.x);
                    }
                    if (position.y != 0)
                    {
                        SetXElement(ref data, "positionY", position.y);
                    }
                    if (position.z != 0)
                    {
                        SetXElement(ref data, "positionZ", position.z);
                    }
                    if (rotation.x != 0)
                    {
                        SetXElement(ref data, "rotationX", rotation.x);
                    }
                    if (rotation.y != 0)
                    {
                        SetXElement(ref data, "rotationY", rotation.y);
                    }
                    if (rotation.z != 0)
                    {
                        SetXElement(ref data, "rotationZ", rotation.z);
                    }
                    if (scale != MyConst.SCALE_DEFAULT && scale > 0)
                    {
                        SetXElement(ref data, "scale", scale);
                    }
                    if (isNew)
                    {
                        xml.Add(data);
                    }
                    xml.Save(@filePath);
                    GameObject.Destroy(backGround);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// バブル・ラメリスト追記
        /// </summary>
        public void WriteBubleLameList(FreeBubbleLameSet particleData, string label)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(MyConst.FILE_STAGE_BUBBLE_LAME, "");
                if (!string.IsNullOrEmpty(filePath))
                {
                    var xml = XElement.Load(@filePath);
                    var data = xml.Elements("particle").FirstOrDefault(e => e.Attribute("label").Value == label);
                    var isNew = false;
                    if (data == null)
                    {
                        data = new XElement("particle");
                        data.Add(new XAttribute("label", label));
                        data.Add(new XAttribute("type", particleData.type));
                        isNew = true;
                    }
                    SetXElement(ref data, "minSize", particleData.minSize);
                    SetXElement(ref data, "maxSize", particleData.maxSize);
                    SetXElement(ref data, "minEnergy", particleData.minEnergy);
                    SetXElement(ref data, "maxEnergy", particleData.maxEnergy);
                    SetXElement(ref data, "minEmission", particleData.minEmission);
                    SetXElement(ref data, "maxEmission", particleData.maxEmission);
                    SetXElement(ref data, "worldVelocityX", particleData.worldVelocity.x);
                    SetXElement(ref data, "worldVelocityY", particleData.worldVelocity.y);
                    SetXElement(ref data, "worldVelocityZ", particleData.worldVelocity.z);
                    SetXElement(ref data, "rndVelocityX", particleData.rndVelocity.x);
                    SetXElement(ref data, "rndVelocityY", particleData.rndVelocity.y);
                    SetXElement(ref data, "rndVelocityZ", particleData.rndVelocity.z);
                    SetXElement(ref data, "angularVelocity", particleData.angularVelocity);
                    SetXElement(ref data, "rndAngularVelocity", particleData.rndAngularVelocity);
                    SetXElement(ref data, "rndRotation", particleData.rndRotation ? MyConst.FILE_TRUE : 0);
                    SetXElement(ref data, "positionX", particleData.position.x);
                    SetXElement(ref data, "positionY", particleData.position.y);
                    SetXElement(ref data, "positionZ", particleData.position.z);
                    SetXElement(ref data, "rotationX", particleData.rotation.x);
                    SetXElement(ref data, "rotationY", particleData.rotation.y);
                    SetXElement(ref data, "rotationZ", particleData.rotation.z);
                    SetXElement(ref data, "colorR", (int)particleData.color.r);
                    SetXElement(ref data, "colorG", (int)particleData.color.g);
                    SetXElement(ref data, "colorB", (int)particleData.color.b);
                    SetXElement(ref data, "colorA", (int)particleData.color.a);
                    SetXElement(ref data, "textureName", particleData.textureName);
                    if (isNew)
                    {
                        xml.Add(data);
                    }
                    xml.Save(@filePath);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// パーティクルリスト追記
        /// </summary>
        public void WriteParticleList(DanceParticle particleData, string label)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(MyConst.FILE_STAGE_PARTICLE, "");
                if (!string.IsNullOrEmpty(filePath))
                {
                    var xml = XElement.Load(@filePath);
                    var data = xml.Elements("particle").FirstOrDefault(e => e.Attribute("label").Value == label);
                    var isNew = false;
                    
                    if (data == null)
                    {
                        data = new XElement("particle");
                        data.Add(new XAttribute("label", label));
                        isNew = true;
                    }
                    else
                    {
                        data.RemoveNodes();
                    }

                    SetXElement(ref data, "textureName", particleData.textureName);
                    SetXElement(ref data, "shaderName", particleData.shaderName);
                    if(particleData.position != Vector3.zero)
                    {
                        SetXElement(ref data, "positionX", particleData.position.x);
                        SetXElement(ref data, "positionY", particleData.position.y);
                        SetXElement(ref data, "positionZ", particleData.position.z);
                    }
                    if (particleData.rotation != Vector3.zero)
                    {
                        SetXElement(ref data, "rotationX", particleData.rotation.x);
                        SetXElement(ref data, "rotationY", particleData.rotation.y);
                        SetXElement(ref data, "rotationZ", particleData.rotation.z);
                    }
                    if (particleData.scale != new Vector3(MyConst.SCALE_DEFAULT, MyConst.SCALE_DEFAULT, MyConst.SCALE_DEFAULT))
                    {
                        SetXElement(ref data, "scaleX", particleData.scale.x);
                        SetXElement(ref data, "scaleY", particleData.scale.y);
                        SetXElement(ref data, "scaleZ", particleData.scale.z);
                    }
                    if (particleData.isColor)
                    {
                        SetXElement(ref data, "isColor", particleData.isColor ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref data, "colorR", particleData.color.r);
                        SetXElement(ref data, "colorG", particleData.color.g);
                        SetXElement(ref data, "colorB", particleData.color.b);
                        SetXElement(ref data, "colorA", particleData.color.a);
                    }

                    var tag = "main";
                    var child = data.Element(tag);
                    if (particleData.main.enabled)
                    {
                        child = new XElement(tag);
                        var p = particleData.main;
                        SetXElement(ref child, "duration", p.duration);
                        SetXElement(ref child, "maxParticles", p.maxParticles);
                        SetXElement(ref child, "startDelayMin", p.startDelay.x);
                        SetXElement(ref child, "startDelayMax", p.startDelay.y);
                        SetXElement(ref child, "startLifetimeMin", p.startLifetime.x);
                        SetXElement(ref child, "startLifetimeMax", p.startLifetime.y);
                        SetXElement(ref child, "startSpeedMin", p.startSpeed.x);
                        SetXElement(ref child, "startSpeedMax", p.startSpeed.y);
                        SetXElement(ref child, "startSizeMin", p.startSize.x);
                        SetXElement(ref child, "startSizeMax", p.startSize.y);
                        SetXElement(ref child, "startRotationMin", p.startRotation.x);
                        SetXElement(ref child, "startRotationMax", p.startRotation.y);
                        SetXElement(ref child, "gravityModifierMin", p.gravityModifier.x);
                        SetXElement(ref child, "gravityModifierMax", p.gravityModifier.y);
                        data.Add(child);
                    }

                    tag = "emission";
                    child = data.Element(tag);
                    if (particleData.emission.enabled)
                    {
                        var p = particleData.emission;
                        child = new XElement(tag);
                        SetXElement(ref child, "rateOverTimeMin", p.rateOverTime.x);
                        SetXElement(ref child, "rateOverTimeMax", p.rateOverTime.y);
                        SetXElement(ref child, "rateOverDistanceMin", p.rateOverDistance.x);
                        SetXElement(ref child, "rateOverDistanceMax", p.rateOverDistance.y);
                        SetXElement(ref child, "burstMin", p.burst.x);
                        SetXElement(ref child, "burstMax", p.burst.y);
                        SetXElement(ref child, "burstTime", p.burst.z);
                        data.Add(child);
                    }

                    tag = "shape";
                    child = data.Element(tag);
                    if (particleData.shape.enabled)
                    {
                        child = new XElement(tag);
                        var p = particleData.shape;                        
                        SetXElement(ref child, "shapeType", (int)p.shapeType);
                        SetXElement(ref child, "angle", p.angle);
                        SetXElement(ref child, "sphericalDirectionAmount", p.sphericalDirectionAmount);
                        SetXElement(ref child, "randomDirectionAmount", p.randomDirectionAmount);
                        SetXElement(ref child, "boxSizeX", p.boxSize.x);
                        SetXElement(ref child, "boxSizeY", p.boxSize.y);
                        SetXElement(ref child, "boxSizeZ", p.boxSize.z);
                        SetXElement(ref child, "radiusMode", (int)p.radiusMode);
                        SetXElement(ref child, "radius", p.radius);
                        SetXElement(ref child, "radiusSpread", p.radiusSpread);
                        SetXElement(ref child, "radiusSpeedMin", p.radiusSpeed.x);
                        SetXElement(ref child, "radiusSpeedMax", p.radiusSpeed.y);
                        SetXElement(ref child, "arcMode", (int)p.arcMode);
                        SetXElement(ref child, "arc", p.arc);
                        SetXElement(ref child, "arcSpread", p.arcSpread);
                        SetXElement(ref child, "arcSpeedMin", p.arcSpeed.x);
                        SetXElement(ref child, "arcSpeedMax", p.arcSpeed.y);
                        data.Add(child);
                    }

                    tag = "colorOverLifetime";
                    child = data.Element(tag);
                    if (particleData.colorOverLifetime.enabled)
                    {
                        child = new XElement(tag);
                        var p = particleData.colorOverLifetime;
                        SetXElement(ref child, "mode", (int)p.mode);
                        SetXElement(ref child, "isRandom", p.isRandom ? MyConst.FILE_TRUE : 0);

                        foreach (var key in MyConst.PARTICLE_GRADIENT_TYPE.Keys)
                        {
                            var gradient = new XElement(Enum.GetName(typeof(ParticleSystemGradientMode), key));
                            foreach (int i in Enumerable.Range(0, MyConst.GRADIENT_KEY))
                            {
                                var color = new XElement("color");
                                color.Add(new XAttribute("index", i));
                                var gColor = (GradientColorKey[])p.gradientColor[key].Clone();
                                var c = gColor[i].color * MyConst.COLOR_MAX;
                                SetXElement(ref color, "colorR", (int)c.r);
                                SetXElement(ref color, "colorG", (int)c.g);
                                SetXElement(ref color, "colorB", (int)c.b);
                                SetXElement(ref color, "time", gColor[i].time);
                                gradient.Add(color);
                            }
                            var alpha = new XElement(Enum.GetName(typeof(ParticleSystemGradientMode), key));
                            foreach (int i in Enumerable.Range(0, MyConst.GRADIENT_KEY))
                            {
                                var color = new XElement("alpha");
                                color.Add(new XAttribute("index", i));
                                var gAlpha = (GradientAlphaKey[])p.gradientAlpha[key].Clone();
                                SetXElement(ref color, "colorA", gAlpha[i].alpha);
                                SetXElement(ref color, "time", gAlpha[i].time);
                                gradient.Add(color);
                            }
                            child.Add(gradient);
                            if (key == p.mode)
                            {
                                break;
                            }
                        }
                        data.Add(child);
                    }

                    tag = "colorBySpeed";
                    child = data.Element(tag);
                    if (particleData.colorBySpeed.enabled)
                    {
                        child = new XElement(tag);
                        var p = particleData.colorBySpeed;                       
                        SetXElement(ref child, "mode", (int)p.mode);
                        SetXElement(ref child, "isRandom", p.isRandom ? MyConst.FILE_TRUE : 0);

                        foreach (var key in MyConst.PARTICLE_GRADIENT_TYPE.Keys)
                        {
                            var gradient = new XElement(Enum.GetName(typeof(ParticleSystemGradientMode), key));
                            foreach (int i in Enumerable.Range(0, MyConst.GRADIENT_KEY))
                            {
                                var color = new XElement("color");
                                color.Add(new XAttribute("index", i));
                                var gColor = (GradientColorKey[])p.gradientColor[key].Clone();
                                var c = gColor[i].color * MyConst.COLOR_MAX;
                                SetXElement(ref color, "colorR", (int)c.r);
                                SetXElement(ref color, "colorG", (int)c.g);
                                SetXElement(ref color, "colorB", (int)c.b);
                                SetXElement(ref color, "time", gColor[i].time);
                                gradient.Add(color);
                            }
                            var alpha = new XElement(Enum.GetName(typeof(ParticleSystemGradientMode), key));
                            foreach (int i in Enumerable.Range(0, MyConst.GRADIENT_KEY))
                            {
                                var color = new XElement("alpha");
                                color.Add(new XAttribute("index", i));
                                var gAlpha = (GradientAlphaKey[])p.gradientAlpha[key].Clone();
                                SetXElement(ref color, "colorA", (int)(gAlpha[i].alpha));
                                SetXElement(ref color, "time", gAlpha[i].time);
                                gradient.Add(color);
                            }
                            child.Add(gradient);
                            if (key == p.mode)
                            {
                                break;
                            }
                        }
                        SetXElement(ref child, "rangeMin", p.range.x);
                        SetXElement(ref child, "rangeMax", p.range.y);
                        data.Add(child);
                    }

                    tag = "inheritVelocity";
                    child = data.Element(tag);
                    if (particleData.inheritVelocity.enabled)
                    {
                        child = new XElement(tag);
                        var p = particleData.inheritVelocity;
                        SetXElement(ref child, "curveMin", p.curve.x);
                        SetXElement(ref child, "curveMax", p.curve.y);
                        data.Add(child);
                    }

                    tag = "velocityOverLifetime";
                    child = data.Element(tag);
                    if (particleData.velocityOverLifetime.enabled)
                    {
                        
                        child = new XElement(tag);
                        var p = particleData.velocityOverLifetime;
                        var m = p.speed;
                        SetXElement(ref child, "speedMinX", m.x.x);
                        SetXElement(ref child, "speedMaxX", m.x.y);
                        SetXElement(ref child, "speedMinY", m.y.x);
                        SetXElement(ref child, "speedMaxY", m.y.y);
                        SetXElement(ref child, "speedMinZ", m.z.x);
                        SetXElement(ref child, "speedMaxZ", m.z.y);
                        data.Add(child);
                    }

                    tag = "limitVelocityOverLifetime";
                    child = data.Element(tag);
                    if (particleData.limitVelocityOverLifetime.enabled)
                    {
                        child = new XElement(tag);
                        var p = particleData.limitVelocityOverLifetime;
                        var m = p.limit;
                        SetXElement(ref child, "dampen", p.dampen);
                        SetXElement(ref child, "limitMinX", m.x.x);
                        SetXElement(ref child, "limitMaxX", m.x.y);
                        SetXElement(ref child, "limitMinY", m.y.x);
                        SetXElement(ref child, "limitMaxY", m.y.y);
                        SetXElement(ref child, "limitMinZ", m.z.x);
                        SetXElement(ref child, "limitMaxZ", m.z.y);
                        data.Add(child);
                    }

                    tag = "forceOverLifetime";
                    child = data.Element(tag);
                    if (child != null)
                    {
                        child.Remove();
                    }
                    if (particleData.forceOverLifetime.enabled)
                    {   
                        child = new XElement(tag);
                        var p = particleData.forceOverLifetime;
                        var m = p.force;
                        SetXElement(ref child, "randomized", p.randomized ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref child, "forceMinX", m.x.x);
                        SetXElement(ref child, "forceMaxX", m.x.y);
                        SetXElement(ref child, "forceMinY", m.y.x);
                        SetXElement(ref child, "forceMaxY", m.y.y);
                        SetXElement(ref child, "forceMinZ", m.z.x);
                        SetXElement(ref child, "forceMaxZ", m.z.y);
                        data.Add(child);
                    }

                    tag = "externalForces";
                    child = data.Element(tag);
                    if (particleData.externalForces.enabled)
                    {
                        child = new XElement(tag);
                        var p = particleData.externalForces;
                        SetXElement(ref child, "multiplier", p.multiplier);
                        data.Add(child);
                    }

                    tag = "sizeOverLifetime";
                    child = data.Element(tag);
                    if (particleData.sizeOverLifetime.enabled)
                    {   
                        child = new XElement(tag);
                        var p = particleData.sizeOverLifetime;
                        var m = p.size;
                        SetXElement(ref child, "sizeMinX", m.x.x);
                        SetXElement(ref child, "sizeMaxX", m.x.y);
                        SetXElement(ref child, "sizeMinY", m.y.x);
                        SetXElement(ref child, "sizeMaxY", m.y.y);
                        SetXElement(ref child, "sizeMinZ", m.z.x);
                        SetXElement(ref child, "sizeMaxZ", m.z.y);
                        data.Add(child);
                    }

                    tag = "sizeBySpeed";
                    child = data.Element(tag);
                    if (particleData.sizeBySpeed.enabled)
                    {
                        child = new XElement(tag);
                        var p = particleData.sizeBySpeed;
                        var m = p.size;
                        SetXElement(ref child, "sizeMinX", m.x.x);
                        SetXElement(ref child, "sizeMaxX", m.x.y);
                        SetXElement(ref child, "sizeMinY", m.y.x);
                        SetXElement(ref child, "sizeMaxY", m.y.y);
                        SetXElement(ref child, "sizeMinZ", m.z.x);
                        SetXElement(ref child, "sizeMaxZ", m.z.y);
                        SetXElement(ref child, "rangeMin", p.range.x);
                        SetXElement(ref child, "rangeMax", p.range.y);
                        data.Add(child);
                    }

                    tag = "rotationOverLifetime";
                    child = data.Element(tag);
                    if (particleData.rotationOverLifetime.enabled)
                    {   
                        child = new XElement(tag);
                        var p = particleData.rotationOverLifetime;
                        var m = p.rotation;
                        SetXElement(ref child, "rotationMinX", m.x.x);
                        SetXElement(ref child, "rotationMaxX", m.x.y);
                        SetXElement(ref child, "rotationMinY", m.y.x);
                        SetXElement(ref child, "rotationMaxY", m.y.y);
                        SetXElement(ref child, "rotationMinZ", m.z.x);
                        SetXElement(ref child, "rotationMaxZ", m.z.y);
                        data.Add(child);
                    }

                    tag = "rotationBySpeed";
                    child = data.Element(tag);
                    if (particleData.rotationBySpeed.enabled)
                    {
                        child = new XElement(tag);
                        var p = particleData.rotationBySpeed;
                        var m = p.rotation;
                        SetXElement(ref child, "rotationMinX", m.x.x);
                        SetXElement(ref child, "rotationMaxX", m.x.y);
                        SetXElement(ref child, "rotationMinY", m.y.x);
                        SetXElement(ref child, "rotationMaxY", m.y.y);
                        SetXElement(ref child, "rotationMinZ", m.z.x);
                        SetXElement(ref child, "rotationMaxZ", m.z.y);
                        SetXElement(ref child, "rangeMin", p.range.x);
                        SetXElement(ref child, "rangeMax", p.range.y);
                        data.Add(child);
                    }

                    tag = "collision";
                    child = data.Element(tag);
                    if (particleData.collision.enabled)
                    {
                        child = new XElement(tag);
                        var p = particleData.collision;
                        SetXElement(ref child, "dampenMin", p.dampen.x);
                        SetXElement(ref child, "dampenMax", p.dampen.y);
                        SetXElement(ref child, "bounceMin", p.bounce.x);
                        SetXElement(ref child, "bounceMax", p.bounce.y);
                        SetXElement(ref child, "lifetimeLossMin", p.lifetimeLoss.x);
                        SetXElement(ref child, "lifetimeLossMax", p.lifetimeLoss.y);
                        SetXElement(ref child, "minKillSpeed", p.minKillSpeed);
                        data.Add(child);
                    }

                    tag = "noise";
                    child = data.Element(tag);
                    if (particleData.noise.enabled)
                    {
                        child = new XElement(tag);
                        var p = particleData.noise;
                        var m = p.strength;
                        SetXElement(ref child, "strengthMinX", m.x.x);
                        SetXElement(ref child, "strengthMaxX", m.x.y);
                        SetXElement(ref child, "strengthMinY", m.y.x);
                        SetXElement(ref child, "strengthMaxY", m.y.y);
                        SetXElement(ref child, "strengthMinZ", m.z.x);
                        SetXElement(ref child, "strengthMaxZ", m.z.y);
                        SetXElement(ref child, "frequency", p.frequency);
                        SetXElement(ref child, "damping", p.damping ? MyConst.FILE_TRUE : 0);
                        data.Add(child);
                    }

                    tag = "render";
                    child = data.Element(tag);
                    if (particleData.render.enabled)
                    {
                        child = new XElement(tag);
                        var p = particleData.render;
                        SetXElement(ref child, "mode", (int)p.mode);
                        data.Add(child);
                    }

                    if (isNew)
                    {
                        xml.Add(data);
                    }
                    xml.Save(@filePath);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// カスタム表情リスト追記
        /// </summary>
        public void WriteCustomFaceList(Dictionary<string, float> facialMorphDic, string label)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(MyConst.FILE_MAID_CUSTOM_FACE, "");
                if (!string.IsNullOrEmpty(filePath))
                {
                    var xml = XElement.Load(@filePath);
                    var data = xml.Elements("customFace").FirstOrDefault(e => e.Attribute("label").Value == label);
                    var isNew = false;
                    if (data == null)
                    {
                        data = new XElement("customFace");
                        data.Add(new XAttribute("label", label));
                        isNew = true;
                    }
                    foreach (var key in facialMorphDic.Keys)
                    {
                        SetXElement(ref data, key, facialMorphDic[key]);
                    }
                    if (isNew)
                    {
                        xml.Add(data);
                    }
                    xml.Save(@filePath);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// 衣装リスト追記
        /// </summary>
        public void WriteDressList(Dictionary<string, string> dressDic, string label)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(MyConst.FILE_MAID_DRESS, "");
                if (!string.IsNullOrEmpty(filePath))
                {
                    var xml = XElement.Load(@filePath);
                    var data = xml.Elements("dress").FirstOrDefault(e => e.Attribute("label").Value == label);
                    var isNew = false;
                    if (data == null)
                    {
                        data = new XElement("dress");
                        data.Add(new XAttribute("label", label));
                        isNew = true;
                    }
                    foreach (var key in dressDic.Keys)
                    {
                        if (!string.IsNullOrEmpty(dressDic[key]) 
                            && key != MyConst.DRESS_TAG_SKIN && key != MyConst.DRESS_TAG_BIND_U && key != MyConst.DRESS_TAG_BIND_L)
                        {
                            SetXElement(ref data, key, dressDic[key]);
                        }
                    }
                    if (isNew)
                    {
                        xml.Add(data);
                    }
                    xml.Save(@filePath);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// 髪リスト追記
        /// </summary>
        public void WriteHairMenuList(Dictionary<string, string> hairDic, string label)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(MyConst.FILE_MAID_HAIR_MENU, "");
                if (!string.IsNullOrEmpty(filePath))
                {
                    var xml = XElement.Load(@filePath);
                    var data = xml.Elements("hairMenu").FirstOrDefault(e => e.Attribute("label").Value == label);
                    var isNew = false;
                    if (data == null)
                    {
                        data = new XElement("hairMenu");
                        data.Add(new XAttribute("label", label));
                        isNew = true;
                    }
                    foreach (var pair in hairDic)
                    {
                        if (!string.IsNullOrEmpty(pair.Value))
                        {
                            SetXElement(ref data, pair.Key, pair.Value);
                        }
                    }
                    if (isNew)
                    {
                        xml.Add(data);
                    }
                    xml.Save(@filePath);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// オートカメラリスト追記
        /// </summary>
        public void WriteAutoCameraList(string label, AutoCameraSet autoData)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(MyConst.FILE_AUTO_CAMERA, "");
                if (!string.IsNullOrEmpty(filePath))
                {
                    var xml = XElement.Load(@filePath);
                    var data = xml.Elements("autos").FirstOrDefault(e => e.Attribute("label").Value == label);
                    var isNew = false;
                    if (data == null)
                    {
                        data = new XElement("autos");
                        data.Add(new XAttribute("label", label));
                        isNew = true;
                    }
                    else
                    {
                        data.RemoveNodes();
                    }
                    SetXElement(ref data, "isRandomMaid", autoData.isRandomMaid ? MyConst.FILE_TRUE : 0);

                    for (int i = 0; i < autoData.each.Count(); i++)
                    {
                        var auto = new XElement("auto");
                        var name = Enum.GetName(typeof(LookAtAutoAngleType), (LookAtAutoAngleType)i).ToString();
                        auto.Add(new XAttribute("name", name));
                        var each = autoData.each[i];
                        SetXElement(ref auto, "isAngleEnabled", each.isAngleEnabled ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref auto, "isBackEnabled", each.isBackEnabled ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref auto, "isInfrequent", each.isInfrequent ? MyConst.FILE_TRUE : 0);

                        var pos = new XElement("positionMin");
                        auto.Add(pos);
                        pos.Add(new XAttribute("x", each.positionMin.x));
                        pos.Add(new XAttribute("y", each.positionMin.y));
                        pos.Add(new XAttribute("z", each.positionMin.z));
                        pos = new XElement("positionMax");
                        auto.Add(pos);
                        pos.Add(new XAttribute("x", each.positionMax.x));
                        pos.Add(new XAttribute("y", each.positionMax.y));
                        pos.Add(new XAttribute("z", each.positionMax.z));
                        var time = new XElement("autoTime");
                        auto.Add(time);
                        time.Add(new XAttribute("min", each.autoTime.x));
                        time.Add(new XAttribute("max", each.autoTime.y));
                        data.Add(auto);
                    }
                    if (isNew)
                    {
                        xml.Add(data);
                    }
                    xml.Save(@filePath);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// カスタム表情リストサンプル出力
        /// </summary>
        public void WriteMaidBindSample(Dictionary<string, string> menu, Dictionary<string, Vector3> bind)
        {
            try
            {
                XmlDocument document = new XmlDocument();
                XmlDeclaration declaration = document.CreateXmlDeclaration("1.0", MyConst.CHARA_UTF8.ToUpper(), null);
                XmlElement bindList = document.CreateElement("MaidBind");
                document.AppendChild(declaration);
                document.AppendChild(bindList);

                XmlElement bnd = document.CreateElement("bind");
                bnd.SetAttribute("label", "拘束サンプル");
                bindList.AppendChild(bnd);

                XmlElement mns = document.CreateElement("menus");
                bnd.AppendChild(mns);
                foreach (var pair in menu)
                {
                    XmlElement e = document.CreateElement("menu");
                    e.SetAttribute("tag", pair.Key);
                    e.SetAttribute("name", pair.Value);
                    mns.AppendChild(e);
                }

                XmlElement r = document.CreateElement("rotation");
                bnd.AppendChild(r);
                foreach (var pair in bind)
                {
                    XmlElement e = document.CreateElement("bone");
                    e.SetAttribute("name", pair.Key);
                    e.SetAttribute("x", pair.Value.x.ToString(MyConst.DECIMAL_FORMAT));
                    e.SetAttribute("y", pair.Value.y.ToString(MyConst.DECIMAL_FORMAT));
                    e.SetAttribute("z", pair.Value.z.ToString(MyConst.DECIMAL_FORMAT));
                    r.AppendChild(e);
                }

                var fileName = string.Format(MyConst.FILE_MAID_BIND_SAMPLE, DateTime.Now.ToString("HHmmss"));
                document.Save(@Path.Combine(MyHelper.RootFolder, fileName));
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }


        /// <summary>
        /// メイドぶっかけサンプル出力
        /// </summary>
        public void WriteBukkakeSample(MaidBukkakeSet bukkake)
        {
            try
            {
                XmlDocument document = new XmlDocument();
                XmlDeclaration declaration = document.CreateXmlDeclaration("1.0", MyConst.CHARA_UTF8.ToUpper(), null);
                XmlElement bukkakeList = document.CreateElement("MaidBukkake");
                document.AppendChild(declaration);
                document.AppendChild(bukkakeList);

                var bkks = document.CreateElement("bukkakes");
                bkks.SetAttribute("label", "ぶっかけサンプル");
                bukkakeList.AppendChild(bkks);
                XmlElement bk = document.CreateElement("bukkake");
                bkks.AppendChild(bk);

                var delim = MyConst.DELIMITER_BUKKAKE.ToString();
                var value = "";
                var slot = MyConst.BUKKAKE_TAG.Keys.ToList();
                for (int i = 0; i < slot.Count(); i++)
                {
                    if (bukkake.slotNo[i])
                    {
                        value += (string.IsNullOrEmpty(value) ? "" : delim) + slot[i];
                    }
                }
                var e = document.CreateElement("slot");
                if (!string.IsNullOrEmpty(value))
                {
                    e.InnerText = value;
                    bk.AppendChild(e);
                }
                var f = new string[2];
                for (int i = 0; i < bukkake.fileNo.GetLength(0); i++)
                {
                    f[i] = "";
                    for (int j = 0; j < bukkake.fileNo.GetLength(1); j++)
                    {
                        if (bukkake.fileNo[i, j])
                        {
                            f[i] += (string.IsNullOrEmpty(f[i]) ? "" : delim) + (j + 1).ToString();
                        }
                    }
                    e = document.CreateElement(i == 0 ? "file" : "fileR");
                    if (!string.IsNullOrEmpty(f[i]))
                    {
                        e.InnerText = f[i];
                        bk.AppendChild(e);
                    }
                }

                e = document.CreateElement("positionX");
                e.SetAttribute("min", bukkake.min.x.ToString());
                e.SetAttribute("max", bukkake.max.x.ToString());
                bk.AppendChild(e);

                e = document.CreateElement("positionY");
                e.SetAttribute("min", bukkake.min.y.ToString());
                e.SetAttribute("max", bukkake.max.y.ToString());
                bk.AppendChild(e);

                e = document.CreateElement("rotation");
                e.SetAttribute("min", bukkake.min.z.ToString());
                e.SetAttribute("max", bukkake.max.z.ToString());
                bk.AppendChild(e);

                e = document.CreateElement("scale");
                e.SetAttribute("min", bukkake.min.w.ToString());
                e.SetAttribute("max", bukkake.max.w.ToString());
                bk.AppendChild(e);

                e = document.CreateElement("repeat");
                e.InnerText = bukkake.repeat.ToString();
                bk.AppendChild(e);

                document.Save(@Path.Combine(MyHelper.RootFolder, MyConst.FILE_MAID_BUKKAKE_SAMPLE));
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// 胸設定上書き（共通）
        /// </summary>
        public void WriteCommonMuneData(List<MaidMuneSet> muneData)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(MyConst.FILE_SETTING_MAID_SWING, "");
                if (!string.IsNullOrEmpty(filePath))
                {
                    var xml = XDocument.Load(@filePath);
                    var element = xml.Element("SettingMaidSwing").Element("commonMune");
                    element.RemoveNodes();
                    for (int i = 0; i < muneData.Count(); i++)
                    {
                        var data = new XElement("mune");
                        data.Add(new XAttribute("type", i.ToString()));
                        SetXElement(ref data, "gravity", muneData[i].gravity);
                        SetXElement(ref data, "damping", muneData[i].damping);
                        SetXElement(ref data, "yawaraka", muneData[i].yawaraka);
                        SetXElement(ref data, "maxStiffness", muneData[i].maxStiffness);
                        SetXElement(ref data, "minStiffness", muneData[i].minStiffness);
                        SetXElement(ref data, "maxStiffnessBra", muneData[i].maxStiffnessBra);
                        SetXElement(ref data, "minStiffnessBra", muneData[i].minStiffnessBra);
                        element.Add(data);
                    }
                    xml.Save(@filePath);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// 髪設定上書き（共通）
        /// </summary>
        public void WriteCommonHairData(List<Dictionary<TBody.SlotID, DynamicBone>> hairData)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(MyConst.FILE_SETTING_MAID_SWING, "");
                if (!string.IsNullOrEmpty(filePath))
                {
                    var xml = XDocument.Load(@filePath);
                    var element = xml.Element("SettingMaidSwing").Element("commonHair");
                    element.RemoveNodes();
                    for (int i = 0; i < hairData.Count(); i++)
                    {
                        var row = new XElement("hairs");
                        row.Add(new XAttribute("type", i.ToString()));
                        foreach (var pair in hairData[i])
                        {
                            var data = new XElement("hair");
                            data.Add(new XAttribute("type", Enum.GetName(typeof(TBody.SlotID), pair.Key)));
                            SetXElement(ref data, "damping", pair.Value.m_Damping);
                            SetXElement(ref data, "elasticity", pair.Value.m_Elasticity);
                            SetXElement(ref data, "stiffness", pair.Value.m_Stiffness);
                            SetXElement(ref data, "inert", pair.Value.m_Inert);
                            SetXElement(ref data, "radius", pair.Value.m_Radius);
                            row.Add(data);
                        }
                        element.Add(row);
                    }
                    xml.Save(@filePath);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// スカート設定上書き（共通）
        /// </summary>
        public void WriteCommonSkirtData(List<Dictionary<TBody.SlotID, DynamicSkirtBone>> skirtData)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(MyConst.FILE_SETTING_MAID_SWING, "");
                if (!string.IsNullOrEmpty(filePath))
                {
                    var xml = XDocument.Load(@filePath);
                    var element = xml.Element("SettingMaidSwing").Element("commonSkirt");
                    element.RemoveNodes();
                    for (int i = 0; i < skirtData.Count(); i++)
                    {
                        var row = new XElement("skirts");
                        row.Add(new XAttribute("type", i.ToString()));
                        foreach (var pair in skirtData[i])
                        {
                            var data = new XElement("skirt");
                            data.Add(new XAttribute("type", Enum.GetName(typeof(TBody.SlotID), pair.Key)));
                            SetXElement(ref data, "radius", pair.Value.m_fPanierRadius);
                            SetXElement(ref data, "velocity", pair.Value.m_fVelocityForceRate);
                            SetXElement(ref data, "force", pair.Value.m_fPanierForce);
                            SetXElement(ref data, "regRadius", pair.Value.m_fRegDefaultRadius);
                            SetXElement(ref data, "stiffness", pair.Value.m_fPanierStiffnessRate);
                            SetXElement(ref data, "stress", pair.Value.m_fPanierStressForce);
                            SetXElement(ref data, "threshold", pair.Value.m_fPanierForceDistanceThreshold);
                            row.Add(data);
                        }
                        element.Add(row);
                    }
                    xml.Save(@filePath);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// 胸設定上書き（個別）
        /// </summary>
        public void WriteEachMuneData(List<MaidMuneSet> muneData)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(MyConst.FILE_SETTING_MAID_SWING, "");
                if (!string.IsNullOrEmpty(filePath))
                {
                    var xml = XDocument.Load(@filePath);
                    var element = xml.Element("SettingMaidSwing").Element("eachMune");
                    element.RemoveNodes();
                    for (int i = 0; i < muneData.Count(); i++)
                    {
                        var data = new XElement("mune");
                        data.Add(new XAttribute("type", i.ToString()));
                        SetXElement(ref data, "minSize", muneData[i].minSize);
                        SetXElement(ref data, "maxSize", muneData[i].maxSize);
                        SetXElement(ref data, "gravity", muneData[i].gravity);
                        SetXElement(ref data, "damping", muneData[i].damping);
                        SetXElement(ref data, "yawaraka", muneData[i].yawaraka);
                        SetXElement(ref data, "maxStiffness", muneData[i].maxStiffness);
                        SetXElement(ref data, "minStiffness", muneData[i].minStiffness);
                        SetXElement(ref data, "maxStiffnessBra", muneData[i].maxStiffnessBra);
                        SetXElement(ref data, "minStiffnessBra", muneData[i].minStiffnessBra);
                        element.Add(data);
                    }
                    xml.Save(@filePath);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// 髪設定上書き（個別）
        /// </summary>
        public void WriteHairList(Dictionary<string, DynamicBone> hairDic, Dictionary<string, string> menu)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(MyConst.FILE_MAID_HAIR, "");
                if (!string.IsNullOrEmpty(filePath))
                {
                    var xml = XElement.Load(@filePath);
                    foreach (var key in hairDic.Keys)
                    {
                        var type = xml.Elements("hairType").FirstOrDefault(e => e.Attribute("type").Value == key);
                        var data = type.Elements("hair").FirstOrDefault(e => e.Attribute("menu").Value == menu[key]);
                        var isNew = false;
                        if (data == null)
                        {
                            data = new XElement("hair");
                            data.Add(new XAttribute("menu", menu[key]));
                            isNew = true;
                        }
                        SetXElement(ref data, "damping", hairDic[key].m_Damping);
                        SetXElement(ref data, "elasticity", hairDic[key].m_Elasticity);
                        SetXElement(ref data, "stiffness", hairDic[key].m_Stiffness);
                        SetXElement(ref data, "inert", hairDic[key].m_Inert);
                        SetXElement(ref data, "radius", hairDic[key].m_Radius);
                        if (isNew)
                        {
                            type.Add(data);
                        }
                    }
                    xml.Save(@filePath);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// スカート設定上書き（個別）
        /// </summary>
        public void WriteSkirtList(Dictionary<string, DynamicSkirtBone> skirtDic, Dictionary<string, string> menu)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(MyConst.FILE_MAID_SKIRT, "");
                if (!string.IsNullOrEmpty(filePath))
                {
                    var xml = XElement.Load(@filePath);
                    foreach (var key in skirtDic.Keys)
                    {
                        var type = xml.Elements("skirtType").FirstOrDefault(e => e.Attribute("type").Value == key);
                        var data = type.Elements("skirt").FirstOrDefault(e => e.Attribute("menu").Value == menu[key]);
                        var isNew = false;
                        if (data == null)
                        {
                            data = new XElement("skirt");
                            data.Add(new XAttribute("menu", menu[key]));
                            isNew = true;
                        }
                        SetXElement(ref data, "radius", skirtDic[key].m_fPanierRadius);
                        SetXElement(ref data, "velocity", skirtDic[key].m_fVelocityForceRate);
                        SetXElement(ref data, "force", skirtDic[key].m_fPanierForce);
                        SetXElement(ref data, "regRadius", skirtDic[key].m_fRegDefaultRadius);
                        SetXElement(ref data, "stiffness", skirtDic[key].m_fPanierStiffnessRate);
                        SetXElement(ref data, "stress", skirtDic[key].m_fPanierStressForce);
                        SetXElement(ref data, "threshold", skirtDic[key].m_fPanierForceDistanceThreshold);
                        if (isNew)
                        {
                            type.Add(data);
                        }
                    }
                    xml.Save(@filePath);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// スイッチャーリスト追記
        /// </summary>
        public void WriteSwitcherList(Vector3 position, Vector3 rotation, string label)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(MyConst.FILE_SWITCER, "");
                if (!string.IsNullOrEmpty(filePath))
                {
                    var xml = XElement.Load(@filePath);
                    var data = xml.Elements("transform").FirstOrDefault(e => e.Attribute("label").Value == label);
                    var isNew = false;
                    if (data == null)
                    {
                        data = new XElement("transform");
                        data.Add(new XAttribute("label", label));
                        isNew = true;
                    }
                    if (position.x != 0)
                    {
                        SetXElement(ref data, "positionX", position.x);
                    }
                    if (position.y != 0)
                    {
                        SetXElement(ref data, "positionY", position.y);
                    }
                    if (position.z != 0)
                    {
                        SetXElement(ref data, "positionZ", position.z);
                    }
                    if (rotation.x != 0)
                    {
                        SetXElement(ref data, "rotationX", rotation.x);
                    }
                    if (rotation.y != 0)
                    {
                        SetXElement(ref data, "rotationY", rotation.y);
                    }
                    if (rotation.z != 0)
                    {
                        SetXElement(ref data, "rotationZ", rotation.z);
                    }
                    if (isNew)
                    {
                        xml.Add(data);
                    }
                    xml.Save(@filePath);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// 注視・分割カメラ追記
        /// </summary>
        public void WriteLookAtCameraList(MaidLookAtSet lookAtData, string label)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(MyConst.FILE_LOOK_AT, "");
                if (!string.IsNullOrEmpty(filePath))
                {
                    var xml = XElement.Load(@filePath);
                    var row = xml.Elements("setting").FirstOrDefault(e => e.Attribute("label").Value == label);
                    SetXElement(ref row, "lookAtIndex", lookAtData.lookAtIndex);
                    SetXElement(ref row, "isMaidEye", lookAtData.isMaidEye ? MyConst.FILE_TRUE : 0);
                    SetXElement(ref row, "isMotionOn", lookAtData.isMotionOn ? MyConst.FILE_TRUE : 0);
                    SetXElement(ref row, "randomTime", lookAtData.randomTime);

                    var div = row.Element("dividedCamera");
                    SetXElement(ref div, "dividedIndex", lookAtData.dividedIndex);
                    var cam = div.Elements("camera");
                    for (int i = 0; i < cam.Count(); i++)
                    {
                        var d = lookAtData.divisionSet[i];
                        var c = cam.FirstOrDefault(e => e.Attribute("index").Value == i.ToString());
                        SetXElement(ref c, "isLookAt", d.isLookAt ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref c, "isOffsetX", d.isOffsetX ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref c, "isFixedPosY", d.isFixedPosY ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref c, "isFixedRotX", d.isFixedRotX ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref c, "isFixedRotY", d.isFixedRotY ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref c, "offsetX", d.offsetX);
                        SetXElement(ref c, "fixedPosY", d.fixedPosY);
                        SetXElement(ref c, "fixedRotX", d.fixedRotX);
                        SetXElement(ref c, "fixedRotY", d.fixedRotY);
                        SetXElement(ref c, "isRandomMaid", d.isRandomMaid ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref c, "isRandomPoint", d.isRandomPoint ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref c, "pointIndex", d.pointIndex);
                        SetXElement(ref c, "typeIndex", d.typeIndex);
                        SetXElement(ref c, "aroundTypeIndex", d.aroundTypeIndex);
                        SetXElement(ref c, "distanceSlider", d.distanceSlider);
                    }

                    cam = row.Element("subCamera").Elements("camera");
                    for (int i = 0; i < cam.Count(); i++)
                    {
                        var d = lookAtData.subSet[i];
                        var c = cam.FirstOrDefault(e => e.Attribute("index").Value == i.ToString());
                        SetXElement(ref c, "isLookAt", d.isLookAt ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref c, "subSizeIndex", d.subSizeIndex);
                        SetXElement(ref c, "isOffsetX", d.isOffsetX ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref c, "isFixedPosY", d.isFixedPosY ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref c, "isFixedRotX", d.isFixedRotX ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref c, "isFixedRotY", d.isFixedRotY ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref c, "offsetX", d.offsetX);
                        SetXElement(ref c, "fixedPosY", d.fixedPosY);
                        SetXElement(ref c, "fixedRotX", d.fixedRotX);
                        SetXElement(ref c, "fixedRotY", d.fixedRotY);
                        SetXElement(ref c, "isRandomMaid", d.isRandomMaid ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref c, "isRandomPoint", d.isRandomPoint ? MyConst.FILE_TRUE : 0);
                        SetXElement(ref c, "pointIndex", d.pointIndex);
                        SetXElement(ref c, "typeIndex", d.typeIndex);
                        SetXElement(ref c, "aroundTypeIndex", d.aroundTypeIndex);
                        SetXElement(ref c, "distanceSlider", d.distanceSlider);
                    }
                    xml.Save(@filePath);
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// メイドボーンモーション出力
        /// </summary>
        public void WriteMaidBone(List<MotionTimeLineSet> motion, string fileName)
        {
            try
            {
                var sb = new StringBuilder();
                sb.Append(MyConst.HEADER_MAID_MOTION + "\r\n");
                foreach (var data in motion)
                {
                    sb.Append(data.frame + ",");
                    sb.Append(data.name + ",");
                    sb.Append(data.rotation.x.ToString(MyConst.DECIMAL_FORMAT) + ",");
                    sb.Append(data.rotation.y.ToString(MyConst.DECIMAL_FORMAT) + ",");
                    sb.Append(data.rotation.z.ToString(MyConst.DECIMAL_FORMAT) + ",");
                    if (data.name == MyConst.BONE_ALL)
                    {
                        sb.Append(data.position.x.ToString(MyConst.DECIMAL_FORMAT) + ",");
                        sb.Append(data.position.y.ToString(MyConst.DECIMAL_FORMAT) + ",");
                        sb.Append(data.position.z.ToString(MyConst.DECIMAL_FORMAT) + ",");
                    }
                    else
                    {
                        sb.Append(new string(',', 3));
                    }
                    sb.Append(data.easing.ToString());
                    sb.Append("\r\n");
                }

                var filePath = Path.Combine(MyHelper.RootFolder, MyConst.FOLDER_TIMELINE);
                filePath = Path.Combine(filePath, fileName);
                using (var sw = new StreamWriter(filePath, false))
                {
                    sw.Write(sb.ToString());
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// メイド表情モーション出力
        /// </summy>
        public void WriteMaidMorph(List<MotionTimeLineSet> motion, string fileName)
        {
            try
            {
                var sb = new StringBuilder();
                sb.Append(MyConst.HEADER_MAID_MORPH + "\r\n");
                foreach (var data in motion)
                {
                    sb.Append(data.frame + ",");
                    sb.Append(data.name + ",");
                    sb.Append(data.morphValue.ToString(MyConst.DECIMAL_FORMAT));
                    sb.Append("\r\n");
                }

                var filePath = Path.Combine(MyHelper.RootFolder, MyConst.FOLDER_TIMELINE);
                filePath = Path.Combine(filePath, fileName);
                using (var sw = new StreamWriter(filePath, false))
                {
                    sw.Write(sb.ToString());
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// メイド表情モーション出力（公式ダンス）
        /// </summy>
        public void WriteMaidFace(List<DanceFaceSet> face, string fileName)
        {
            try
            {
                var sb = new StringBuilder();
                sb.Append(MyConst.HEADER_FACE_FULL + "\r\n");
                foreach (var data in face)
                {
                    sb.Append(data.time.ToString(MyConst.DECIMAL_FORMAT) + ",");
                    sb.Append(data.face + ",");
                    sb.Append(data.blend + ",");
                    sb.Append((int)data.eyeMoveType + ",");
                    sb.Append(data.frame);
                    sb.Append("\r\n");
                }

                var filePath = Path.Combine(MyHelper.RootFolder, MyConst.FOLDER_TIMELINE);
                filePath = Path.Combine(filePath, fileName);
                using (var sw = new StreamWriter(filePath, false))
                {
                    sw.Write(sb.ToString());
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// メイドカメラモーション出力
        /// </summary>
        public void WriteMaidCamera(List<MotionTimeLineSet> camera, string fileName)
        {
            try
            {
                var sb = new StringBuilder();
                sb.Append(MyConst.HEADER_MAID_CAMERA + "\r\n");
                foreach (var data in camera)
                {
                    sb.Append(data.frame + ",");
                    sb.Append(data.position.x.ToString(MyConst.DECIMAL_FORMAT) + ",");
                    sb.Append(data.position.y.ToString(MyConst.DECIMAL_FORMAT) + ",");
                    sb.Append(data.position.z.ToString(MyConst.DECIMAL_FORMAT) + ",");
                    sb.Append(data.rotation.x.ToString(MyConst.DECIMAL_FORMAT) + ",");
                    sb.Append(data.rotation.y.ToString(MyConst.DECIMAL_FORMAT) + ",");
                    sb.Append(data.rotation.z.ToString(MyConst.DECIMAL_FORMAT) + ",");
                    sb.Append(data.distance.ToString(MyConst.DECIMAL_FORMAT) + ",");
                    sb.Append(data.viewAngle.ToString(MyConst.DECIMAL_FORMAT) + ",");
                    sb.Append(data.easing.ToString());
                    sb.Append("\r\n");
                }

                var filePath = Path.Combine(MyHelper.RootFolder, MyConst.FOLDER_TIMELINE);
                filePath = Path.Combine(filePath, fileName);
                using (var sw = new StreamWriter(filePath, false))
                {
                    sw.Write(sb.ToString());
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// タイムラインモーションフレーム書き換え
        /// </summary>
        public void ReWriteTimelineMotionFile(string fileName, int adjustedFrame)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(fileName, MyConst.FOLDER_TIMELINE);
                if (string.IsNullOrEmpty(filePath))
                {
                    return;
                }
                var sb = new StringBuilder();
                var lines = File.ReadAllLines(@filePath);
                sb.Append(lines[0] + "\r\n");
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var frame = int.Parse(value[0]);
                    if (frame == 0 || 0 < frame + adjustedFrame)
                    {
                        value[0] = (frame == 0 ? frame : frame + adjustedFrame).ToString();
                        sb.Append(string.Join(MyConst.DELIMITER_CSV.ToString(), value));
                        sb.Append("\r\n");
                    }
                }

                filePath = filePath.Replace(fileName, MyConst.HEADER_FRAME_ADJUSTMENT +  fileName);
                using (var sw = new StreamWriter(filePath, false))
                {
                    sw.Write(sb.ToString());
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// タイムラインモーションボーン書き換え
        /// </summary>
        public void ReWriteTimelineBoneFile(string fileName)
        {
            try
            {
                var reader = new FileReader();
                var filePath = reader.GetFilePath(fileName, MyConst.FOLDER_TIMELINE);
                if (string.IsNullOrEmpty(filePath))
                {
                    return;
                }
                var bone = reader.ReadTimelineMotionFileData(filePath);
                var reduct = new List<MotionTimeLineSet>();
                foreach (var key in bone.Select(d => d.name).Distinct())
                {
                    var data = bone.FindAll(d => d.name == key).OrderBy(d => d.frame).ToList();
                    reduct.Add(data[0]);
                    var isSkip = false;
                    for (int i = 1; i < data.Count(); i++)
                    {
                        var j = i - 1;
                        if (data[i].frame - data[j].frame == 1 && !isSkip)
                        {
                            isSkip = true;
                        }
                        else
                        {
                            reduct.Add(data[i]);
                            isSkip = false;
                        }
                    }
                }

                filePath = filePath.Replace(fileName, MyConst.HEADER_FRAME_ADJUSTMENT + fileName);
                WriteMaidBone(reduct, filePath);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// タイムラインモーション指ボーンデータ削除
        /// </summary>
        public void ReWriteTimelineFingerFile(string fileName)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(fileName, MyConst.FOLDER_TIMELINE);
                if (string.IsNullOrEmpty(filePath))
                {
                    return;
                }
                var sb = new StringBuilder();
                sb.Append(MyConst.HEADER_MAID_MOTION + "\r\n");
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var name = value[1];

                    if (MyConst.BONE_NAME_FINGERS.ContainsKey(name))
                    {
                        continue;
                    }
                    sb.Append(lines[i]);
                    sb.Append("\r\n");
                }

                filePath = filePath.Replace(fileName, MyConst.HEADER_FRAME_ADJUSTMENT + fileName);
                using (var sw = new StreamWriter(filePath, false))
                {
                    sw.Write(sb.ToString());
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// タイムラインモーションつま先ボーンデータ削除
        /// </summary>
        public void ReWriteTimelineToeFile(string fileName)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(fileName, MyConst.FOLDER_TIMELINE);
                if (string.IsNullOrEmpty(filePath))
                {
                    return;
                }
                var sb = new StringBuilder();
                sb.Append(MyConst.HEADER_MAID_MOTION + "\r\n");
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var name = value[1];

                    if (MyConst.BONE_NAME_TOES.ContainsKey(name))
                    {
                        continue;
                    }
                    sb.Append(lines[i]);
                    sb.Append("\r\n");
                }

                foreach (var key in MyConst.BONE_NAME_TOES.Keys)
                {
                    var rotation = Vector3.zero;
                    if (MyConst.BONE_DEFAULT_ROTATION.ContainsKey(key))
                    {
                        rotation = MyConst.BONE_DEFAULT_ROTATION[key];
                    }
                    sb.Append(0 + ",");
                    sb.Append(key + ",");
                    sb.Append(rotation.x.ToString(MyConst.DECIMAL_FORMAT) + ",");
                    sb.Append(rotation.y.ToString(MyConst.DECIMAL_FORMAT) + ",");
                    sb.Append(rotation.z.ToString(MyConst.DECIMAL_FORMAT) + ",");
                    sb.Append(new string(',', 3));
                    sb.Append(0);
                    sb.Append("\r\n");
                }
                filePath = filePath.Replace(fileName, MyConst.HEADER_FRAME_ADJUSTMENT + fileName);
                using (var sw = new StreamWriter(filePath, false))
                {
                    sw.Write(sb.ToString());
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// メイドアニメーションファイル出力
        /// </summary>
        public void WriteAnimationFile(byte[] anmBinary, string fileName)
        {
            try
            {
                if (!fileName.EndsWith(MyConst.EXTENSION_ANM))
                {
                    fileName += MyConst.EXTENSION_ANM;
                }
                var filePath = Path.Combine(MyHelper.RootFolder, MyConst.FOLDER_MYPOSE);
                filePath = Path.Combine(filePath, fileName);
                File.WriteAllBytes(filePath, anmBinary);
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        /// <summary>
        /// タイムラインモーション選択ボーンデータ出力
        /// </summary>
        public void ReWriteTimelineSelectedBoneFile(string fileName, Dictionary<string, bool> dic)
        {
            try
            {
                var filePath = new FileReader().GetFilePath(fileName, MyConst.FOLDER_TIMELINE);
                if (string.IsNullOrEmpty(filePath))
                {
                    return;
                }
                var sb = new StringBuilder();
                sb.Append(MyConst.HEADER_MAID_MOTION + "\r\n");
                var lines = File.ReadAllLines(@filePath);
                for (int i = 1; i < lines.GetLength(0); i++)
                {
                    var value = lines[i].Split(MyConst.DELIMITER_CSV);
                    var name = value[1];

                    if (!dic.ContainsKey(name))
                    {
                        continue;
                    }
                    if (!dic[name])
                    {
                        continue;
                    }
                    sb.Append(lines[i]);
                    sb.Append("\r\n");
                }

                filePath = filePath.Replace(fileName, MyConst.HEADER_BONE_SELECT + fileName);
                using (var sw = new StreamWriter(filePath, false))
                {
                    sw.Write(sb.ToString());
                }
            }
            catch (Exception e)
            {
                Debug.LogError(e.ToString());
            }
        }

        private void SetXElement(ref XElement data, string name, int content)
        {
            SetXElement(ref data, name, content.ToString());
        }

        private void SetXElement(ref XElement data, string name, float content)
        {
            SetXElement(ref data, name, content.ToString(MyConst.DECIMAL_FORMAT));
        }

        private void SetXElement(ref XElement data, string name, string content)
        {
            if (data.Element(name) != null)
            {
                data.Element(name).Value = content;
            }
            else
            {
                data.Add(new XElement(name, content));
            }
        }

    }

    /// <summary>
    /// 入力デバイス移動処理管理
    /// </summary>
    public class MoveManager
    {
        private MoveSpeedSet moveSpeed;
        private KeySet myKey;

        public MoveManager(MoveSpeedSet moveSpeed, KeySet myKey)
        {
            this.moveSpeed = moveSpeed;
            this.myKey = myKey;
        }

        public void MoveMouse(ref Vector3 currentPosition, ref Vector3 currentRotation)
        {
            if (Input.GetMouseButton(1))
            {
                currentRotation.x -= Input.GetAxis("Mouse Y") * moveSpeed.mouseRotate;
                currentRotation.x = Mathf.Repeat(currentRotation.x, 360f);
                currentRotation.y += Input.GetAxis("Mouse X") * moveSpeed.mouseRotate;
                currentRotation.y = Mathf.Repeat(currentRotation.y, 360f);
            }
            else if (Input.GetMouseButton(2))
            {
                var pos = Vector3.zero;
                pos.x += Input.GetAxis("Mouse X") * moveSpeed.mouseMove;
                pos.y += Input.GetAxis("Mouse Y") * moveSpeed.mouseMove * -1;
                currentPosition = pos;
            }
            currentPosition.z += Input.mouseScrollDelta.y * -1 / 10;
        }

        public void MoveKey(ref Vector3 currentPosition)
        {
            var tm = MyHelper.GetCameraMainTransform();
            var pos = Vector3.zero;
            if (Input.GetKey(myKey.cameraForward))
            {
                pos += tm.TransformDirection(Vector3.forward);
            }
            if (Input.GetKey(myKey.cameraBack))
            {
                pos += tm.TransformDirection(Vector3.forward) * -1;
            }
            if (Input.GetKey(myKey.cameraLeft))
            {
                pos += tm.TransformDirection(Vector3.right) * -1;
            }
            if (Input.GetKey(myKey.cameraRight))
            {
                pos += tm.TransformDirection(Vector3.right);
            }
            if (Input.GetKey(myKey.cameraUp))
            {
                pos += tm.TransformDirection(Vector3.up);
            }
            if (Input.GetKey(myKey.cameraDown))
            {
                pos += tm.TransformDirection(Vector3.up) * -1;
            }
            pos.Normalize();
            currentPosition += pos * moveSpeed.keyMove;
        }
    }

    /// <summary>
    /// GUIスタイル設定
    /// </summary>
    public class MyGuiStyle
    {
        public GUIStyle gsWindow;
        public GUIStyle gsLabel;
        public GUIStyle gsButton;
        public GUIStyle gsText;
        public GUIStyle gsNumberText;
        public GUIStyle gsTextArea;
        public GUIStyle gsCombo;
        public GUIStyle gsToggle;

        public void SetWindowGuiStyle(Texture2D tex, bool isEnabled)
        {
            gsWindow = new GUIStyle(GUI.skin.box);
            gsWindow.fontSize = MyConst.GUI_FONT_SIZE;
            gsWindow.alignment = TextAnchor.UpperLeft;
            if (tex != null && isEnabled)
            {
                gsWindow.onHover.background = tex;
                gsWindow.hover.background = tex;
                gsWindow.onFocused.background = tex;
                gsWindow.focused.background = tex;
                gsWindow.onHover.textColor = Color.white;
                gsWindow.hover.textColor = Color.white;
                gsWindow.onFocused.textColor = Color.white;
                gsWindow.focused.textColor = Color.white;
            }
        }

        public void SetPartsGuiStyle()
        {
            gsLabel = new GUIStyle(GUI.skin.label);
            gsLabel.fontSize = MyConst.GUI_FONT_SIZE;
            gsButton = new GUIStyle(GUI.skin.button);
            gsButton.fontSize = MyConst.GUI_FONT_SIZE;
            gsButton.alignment = TextAnchor.MiddleCenter;
            gsText = new GUIStyle(GUI.skin.textField);
            gsText.fontSize = MyConst.GUI_FONT_SIZE;
            gsNumberText = new GUIStyle(GUI.skin.textField);
            gsNumberText.fontSize = MyConst.GUI_FONT_SIZE;
            gsNumberText.alignment = TextAnchor.MiddleRight;
            gsTextArea = new GUIStyle(GUI.skin.textArea);
            gsTextArea.fontSize = MyConst.GUI_FONT_SIZE;
            gsCombo = new GUIStyle(GUI.skin.button);
            gsCombo.fontSize = MyConst.GUI_FONT_SIZE;
            gsCombo.alignment = TextAnchor.MiddleLeft;
            gsCombo.margin = new RectOffset(0, 0, 0, 0);
            gsToggle = new GUIStyle(GUI.skin.toggle);
            gsToggle.fontSize = MyConst.GUI_FONT_SIZE;
            gsToggle.onNormal.textColor = Color.yellow;
            gsToggle.onHover.textColor = gsToggle.onNormal.textColor;
        }

    }

    /// <summary>
    /// ダンス情報出力処理
    /// </summary>
    public class DanceListExporter
    {
        private CameraMotionDeltaSet cameraDelta;
        private FreeDanceSet[] maidProperty;
        private List<CameraTransformSet> motionData;

        public DanceListExporter(CameraMotionDeltaSet cameraDelta)
        {
            this.cameraDelta = cameraDelta;
        }

        /// <summary>
        /// ダンスメイド情報取得
        /// </summary>
        public void GetDanceMaidInformation(float danceTime, List<Maid> maids, MaidManager maidMgr)
        {
            if (!MyHelper.CheckNull(maids))
            {
                foreach (var maid in maids)
                {
                    if (maidProperty == null)
                    {
                        maidProperty = new FreeDanceSet[maids.Count()];
                    }
                    var index = maidMgr.GetActiveSlotNo(maid);
                    maidProperty[index].activeSlotNo = index;

                    if (string.IsNullOrEmpty(maidProperty[index].bgmName))
                    {
                        maidProperty[index].bgmName = new SoundManager().GetClipName();
                    }
                    if (maid.m_baKuchipakuPattern != null)
                    {
                        maidProperty[index].mouth = Convert.ToBase64String(maid.m_baKuchipakuPattern);
                    }
                    Animation anime = maid.GetAnimation();
                    if (anime != null)
                    {
                        foreach (AnimationState state in anime)
                        {
                            var name = state.name.ToLower();
                            if (name.Contains(MyConst.STATE_DANCE) ||
                                name.Contains(MyConst.STATE_KARAOKE))
                            {
                                maidProperty[index].animation = state.name;
                            }
                        }
                    }
                    var face = new DanceFaceSet();
                    face.time = danceTime;
                    face.face = maid.ActiveFace;
                    face.blend = maid.FaceName3;
                    if (MyHelper.CheckNull(maidProperty[index].face))
                    {
                        maidProperty[index].face = new List<DanceFaceSet>();
                        maidProperty[index].face.Add(face);
                    }
                    else
                    {
                        var lastFace = maidProperty[index].face[maidProperty[index].face.Count() - 1];
                        if (lastFace.face != maid.ActiveFace || lastFace.blend != maid.FaceName3)
                        {
                            maidProperty[index].face.Add(face);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// ダンスカメラ情報取得
        /// </summary>
        public void GetDanceCameraInformation(float danceTime, Vector3 position, Vector3 rotation, float viewAngle)
        {
            if (MyHelper.CheckNull(motionData))
            {
                motionData = new List<CameraTransformSet>();
                motionData.Add(SetMotionStart(danceTime, position, rotation, viewAngle));
            }
            else
            {
                var index = motionData.Count() - 1;
                var motion = motionData[index];
                if (motion.edTime == 0)
                {
                    motionData[index] = SetMotionEnd(danceTime, position, rotation, viewAngle, motion);
                }
                else if (cameraDelta.time <= MyHelper.CalculateDelta(motion.stTime, danceTime) &&
                        (cameraDelta.position <= MyHelper.CalculateDelta(motion.transform.stPos.x, position.x) ||
                         cameraDelta.position <= MyHelper.CalculateDelta(motion.transform.stPos.y, position.y) ||
                         cameraDelta.position <= MyHelper.CalculateDelta(motion.transform.stPos.z, position.z) ||
                         cameraDelta.rotation <= MyHelper.CalculateRotationDelta(motion.transform.stRot.x, rotation.x) ||
                         cameraDelta.rotation <= MyHelper.CalculateRotationDelta(motion.transform.stRot.y, rotation.y) ||
                         cameraDelta.rotation <= MyHelper.CalculateRotationDelta(motion.transform.stRot.z, rotation.z) ||
                         cameraDelta.viewAngle <= MyHelper.CalculateRotationDelta(motion.transform.stSca.y, viewAngle)))
                {
                    motionData.Add(SetMotionStart(motion.edTime, position, rotation, viewAngle));
                }
                else
                {
                    motionData[index] = SetMotionEnd(danceTime, position, rotation, viewAngle, motion);
                }
            }
        }

        /// <summary>
        /// ダンス情報出力
        /// </summary>
        public void ExportDanceInformation(string folderPath, bool isKaraokeOn)
        {
            if (maidProperty == null)
            {
                Console.WriteLine("ダンス情報が取得できませんでした");
                return;
            }
            var bgmName = maidProperty[0].bgmName;
            var title = Path.GetFileNameWithoutExtension(bgmName);
            XmlDocument document = new XmlDocument();
            XmlDeclaration declaration = document.CreateXmlDeclaration("1.0", MyConst.CHARA_UTF8.ToUpper(), null);
            XmlElement danceList = document.CreateElement("DanceList");
            document.AppendChild(declaration);
            document.AppendChild(danceList);

            XmlElement dance = document.CreateElement("dance");
            dance.SetAttribute("label", title);
            danceList.AppendChild(dance);
            XmlElement element = document.CreateElement("bgm");
            element.InnerText = bgmName;
            dance.AppendChild(element);
            if (isKaraokeOn)
            {
                element = document.CreateElement("changeItem");
                element.InnerText = MyConst.FILE_MAID_ITEM_MIKE;
                dance.AppendChild(element);
            }
            else
            {
                element = document.CreateElement("motion");
                var motionFile = string.Format(MyConst.FILE_MOTION, title);
                element.InnerText = motionFile;
                dance.AppendChild(element);

                using (StreamWriter writer = new StreamWriter(@Path.Combine(folderPath, motionFile), false))
                {
                    var index = motionData.Count() - 1;
                    var mdLast = motionData[index];
                    var trns = mdLast.transform;
                    mdLast.edTime = mdLast.stTime * 2;
                    trns.edPos.x = trns.stPos.x;
                    trns.edPos.y = trns.stPos.y;
                    trns.edPos.z = trns.stPos.z;
                    trns.edRot.x = trns.stRot.x;
                    trns.edRot.y = trns.stRot.y;
                    trns.edRot.z = trns.stRot.z;
                    trns.edSca.y = trns.stSca.y;
                    motionData[index] = mdLast;

                    writer.WriteLine(MyConst.HEADER_MOTION);
                    var lines = new List<string>();
                    var format = "{0}," +
                                 "{1:0.00},{2:0.00},{3:0.00},{4:0.00},{5:0.00},{6:0.00},{7:0.00}," +
                                 "{8:0.00},{9:0.00},{10:0.00},{11:0.00},{12:0.00},{13:0.00},{14:0.00}," +
                                 "{15:0.00},{16:0.00},{17},{18}";
                    var isAdjust = true;
                    foreach (var md in motionData)
                    {
                        var t = md.transform;
                        var line = string.Format(format, md.easingType,
                                                 AjustExportTime(ref isAdjust, md.stTime), t.stPos.x, t.stPos.y, t.stPos.z, t.stRot.x, t.stRot.y, t.stRot.z,
                                                 AjustExportTime(ref isAdjust, md.edTime), t.edPos.x, t.edPos.y, t.edPos.z, t.edRot.x, t.edRot.y, t.edRot.z,
                                                 t.stSca.x, t.edSca.x,t.stSca.y,t.edSca.y);
                        lines.Add(line);
                    }
                    lines.ForEach(line => writer.WriteLine(line));
                }
            }

            foreach (var property in maidProperty)
            {
                var num = property.activeSlotNo;
                XmlElement maid = document.CreateElement("maid");
                maid.SetAttribute("slotNo", num.ToString());
                dance.AppendChild(maid);

                var faceFile = string.Format(MyConst.FILE_FACE, title, num);
                using (StreamWriter writer = new StreamWriter(@Path.Combine(folderPath, faceFile), false))
                {
                    writer.WriteLine(MyConst.HEADER_FACE);
                    var data = new List<string>();
                    var isAdjust = true;
                    foreach (var tmp in property.face)
                    {
                        var face = string.Format("{0},{1},{2}", AjustExportTime(ref isAdjust, tmp.time), tmp.face, tmp.blend);
                        data.Add(face);
                    }
                    data.ForEach(face => writer.WriteLine(face));
                }
                var mouthFile = string.Format(MyConst.FILE_MOUTH, title, num);
                using (StreamWriter writer = new StreamWriter(@Path.Combine(folderPath, mouthFile), false))
                {
                    writer.WriteLine(MyConst.HEADER_MOUTH);
                    writer.WriteLine(property.mouth);
                }
                element = document.CreateElement("animation");
                element.InnerText = property.animation;
                maid.AppendChild(element);
                element = document.CreateElement("face");
                element.InnerText = faceFile;
                maid.AppendChild(element);
                element = document.CreateElement("mouth");
                element.InnerText = mouthFile;
                maid.AppendChild(element);
            }
            var sample = string.Format(MyConst.FILE_DANCE_LIST_SAMPLE, title);

            document.Save(@Path.Combine(folderPath, sample));
        }

        private float AjustExportTime(ref bool isAdjust, float time)
        {
            if (isAdjust)
            {
                if (time > MyConst.EXPORT_AJUST_TIME)
                {
                    time = 0f;
                }
                else
                {
                    isAdjust = false;
                }
            }
            return time;
        }

        /// <summary>
        /// ダンスカメラ情報設定(Start)
        /// </summary>
        private CameraTransformSet SetMotionStart(float danceTime, Vector3 position, Vector3 rotation, float viewAngle)
        {
            var motion = new CameraTransformSet();
            motion.easingType = (int)EasingType.Linear;
            motion.stTime = danceTime;
            motion.transform.stPos = position;
            motion.transform.stRot = rotation;
            motion.transform.stSca = new Vector3(0f, viewAngle, 0f);
            return motion;
        }

        /// <summary>
        /// ダンスカメラ情報設定(End)
        /// </summary>
        private CameraTransformSet SetMotionEnd(float danceTime, Vector3 position, Vector3 rotation, float viewAngle, CameraTransformSet motion)
        {
            motion.edTime = danceTime;
            motion.transform.edPos = position;
            motion.transform.edRot = rotation;
            motion.transform.edSca = new Vector3(0f, viewAngle, 0f);
            return motion;
        }
    }

    /// <summary>
    /// 共通クラス
    /// </summary>
    public static class MyHelper
    {
        public static string RootFolder { get; set; }

        public static Transform GetCameraMainTransform()
        {
            Transform tm; 
            if(IsVR())
            {
                tm = GameMain.Instance.OvrMgr.OvrCamera.transform;
            }
            else
            {
                tm = Camera.main.transform;
            }
            return tm;
        }

        public static Camera GetCameraMain()
        {
            Camera cm;
            if (IsVR())
            {
                cm = GameMain.Instance.OvrMgr.OvrCamera.camera;
            }
            else
            {
                cm = Camera.main;
            }
            return cm;
        }

        public static bool IsVR()
        {
            return GameMain.Instance.OvrMgr != null && GameMain.Instance.OvrMgr.OvrCamera != null;
        }

        public static Color32 SetColorWhite()
        {
            return new Color32(MyConst.COLOR_MAX, MyConst.COLOR_MAX, MyConst.COLOR_MAX, MyConst.COLOR_MAX);
        }

        public static Color32 SetColorBlack()
        {
            return new Color32(MyConst.COLOR_MIN, MyConst.COLOR_MIN, MyConst.COLOR_MIN, MyConst.COLOR_MAX);
        }

        public static int GetRandomIndex(int maxValue)
        {
            return (int)Math.Truncate(UnityEngine.Random.Range(0f, maxValue - 0.0001f));
        }

        public static float GetRandomFloat(float minValue, float maxValue)
        {
            return UnityEngine.Random.Range(minValue, maxValue);
        }

        public static Color GetRandomColor(float alpha)
        {
            var palet = new Color[]
                {
                Color.cyan,
                Color.green,
                Color.red,
                Color.yellow,
                Color.magenta,
                Color.white,
                };
            var index = GetRandomIndex(palet.Count());
            var c = palet[index];
            c.a = alpha;
            return c;
        }

        public static Vector3 GetVector3(float val)
        {
            return new Vector3(val, val, val);
        }

        public static float CalculateDelta(float val1, float val2)
        {
            return Math.Abs(Math.Abs(val1) - Math.Abs(val2));
        }

        public static float CalculateRotationDelta(float val1, float val2)
        {
            val1 -= (Math.Abs(val1) >= 180f ? 360f : 0f);
            val2 -= (Math.Abs(val2) >= 180f ? 360f : 0f);
            return CalculateDelta(val1, val2);
        }

        public static void AdjustRotation(ref float angle)
        {
            angle -= 180f < angle ? 360f : 0f;
        }

        public static bool IsExistingOfficialFile(string fileName)
        {
            return GameUty.FileSystem.IsExistentFile(fileName);
        }

        public static bool IsExistingOfficialFileOld(string fileName)
        {
            return GameUty.FileSystemOld.IsExistentFile(fileName);
        }

        public static bool IsExistingModFile(string fileName)
        {
            return GameUty.FileSystemMod.IsExistentFile(fileName);
        }

        public static bool IsExistingArrayKey(string[] array, string key)
        {
            foreach(var a in array)
            {
                if(a == key)
                {
                    return true;
                }
            }
            return false;
        }

        public static string EndsWith(string value, string extension)
        {
            if (!string.IsNullOrEmpty(value) &&
                !value.EndsWith(extension, StringComparison.CurrentCultureIgnoreCase))
            {
                value += extension;
            }
            return value;
        }

        public static void ClearList<T>(List<T> list)
        {
            if (list != null)
            {
                list.Clear();
            }
        }

        public static void ClearDictionary<T1, T2>(Dictionary<T1, T2> dic)
        {
            if (dic != null)
            {
                dic.Clear();
            }
        }

        public static T1 GetDictionaryKey<T1>(Dictionary<T1, string> dic, string value)
        {
            var pair = dic.FirstOrDefault(c => c.Value == value);
            return pair.Key;
        }

        public static int ConvertFrame(float time)
        {
            return (int)Mathf.Floor(time / MyConst.FRAME_CONVERSION_RATIO);
        }

        public static TBody.SlotID ConvertTBodySlotNameToID(string name)
        {
            var names = Enum.GetNames(typeof(TBody.SlotID));
            for (int i = 0; i < names.Count(); i++)
            {
                if(name == names[i])
                {
                    return (TBody.SlotID)i;
                }
            }
            return 0;
        }

        public static bool CheckNull<T>(List<T> list)
        {
            return list == null || !list.Any();
        }

        public static bool CheckNull<T1, T2>(Dictionary<T1, T2> dic)
        {
            return dic == null || !dic.Any();
        }
    }

    #region SetStruct

    /// <summary>
    /// 移動・回転・拡縮（スタート・エンド）
    /// </summary>
    public struct MyTransform
    {
        public Vector3 stPos;
        public Vector3 edPos;
        public Vector3 stRot;
        public Vector3 edRot;
        public Vector3 stSca;
        public Vector3 edSca;
        public Quaternion stQua;
        public Quaternion edQua;
    }

    /// <summary>
    /// カメラ位置・回転ファイル値
    /// </summary>
    public struct CameraTransformSet
    {
        public int easingType;
        public float stTime;
        public float edTime;
        public float deltaTime;
        public MyTransform transform;
    }

    /// <summary>
    /// 座標スライダー値
    /// </summary>
    public struct TransformSliderSet
    {
        public Vector3 positionMin;
        public Vector3 positionMax;
        public Vector3 rotationMin;
        public Vector3 rotationMax;
        public Vector3 scaleMin;
        public Vector3 scaleMax;
        public Vector3 boneRotationMin;
        public Vector3 boneRotationMax;
    }

    /// <summary>
    /// スイッチャーファイル値
    /// </summary>
    public struct SwitcherTransformSet
    {
        public string label;
        public MyTransform transform;
    }

    /// <summary>
    /// フリーダンスグループ値
    /// </summary>
    public struct FreeDanceGroupSet
    {
        public int playType;
        public List<string> danceLabel;
    }

    /// <summary>
    /// フリーダンス値
    /// </summary>
    public struct FreeDanceSet
    {
        public string type;
        public string bgmName;
        public float startTime;
        public float endTime;
        public int activeSlotNo;
        public string animation;
        public string maidTransform;
        public List<DanceAnimationSet> animationList;
        public List<DanceFaceSet> face;
        public string mouth;
        public List<DanceVisibleMaidSet> changeMaid;
        public List<DanceBgSet> changeBg;
        public Color changeBgColor;
        public List<DancePngSet> changePng;
        public MyTransform transform;
        public string changeItem;
        public string changeDress;
        public string changeUndress;
        public string changePrefab;
        public string changeMaidPrefab;
        public string changePrimitive;
        public string changeParticle;
        public string changeLight;
        public FreeSongSet songSet;
        public bool isMorphOn;
        public string movieLabel;
        public bool isMabatakiOn;
    }

    /// <summary>
    /// フリーソング値
    /// </summary>
    public struct FreeSongSet
    {
        public int metronome;
        public int baseNote;
        public float animationSpeed;
        public bool isCommonPose;
        public bool isCustomAnm;
        public bool isTlBone;
        public string folder;
        public string lyrics;
        public string pose;
        public string poseLoop;
        public string morph;
        public string customMotion;
        public string movieName;
        public bool isMute;
        public float volume;
        public Vector3 position;
        public Vector3 rotation;
        public Vector3 scale;
    }

    /// <summary>
    /// フリーダンス男値SongPoseSet
    /// </summary>
    public struct FreeSongManSet
    {
        public int slotNo;
        public string pose;
        public Vector3 position;
        public Vector3 rotation;
    }

    /// <summary>
    /// フリーダンスメイドアニメーション値
    /// </summary>
    public struct DanceAnimationSet
    {
        public float time;
        public string animation;
    }

    /// <summary>
    /// フリーダンスメイド表情値
    /// </summary>
    public struct DanceFaceSet
    {
        public float time;
        public string face;
        public Dictionary<string, float> faceOpMorph;
        public string blend;
        public Maid.EyeMoveType eyeMoveType;
        public int frame;
    }

    /// <summary>
    /// フリーダンスメイド衣装変更値
    /// </summary>
    public struct DanceDressSet
    {
        public string label;
        public int slotNo;
        public float time;
        public bool isChanged;
        public Dictionary<string, string> dressDic;
    }

    /// <summary>
    /// フリーダンスメイド脱衣値
    /// </summary>
    public struct DanceUndressSet
    {
        public string label;
        public int slotNo;
        public float time;
        public bool isMasked;
        public float startTime;
        public float interval;
    }

    /// <summary>
    /// フリーダンスメイド表示値
    /// </summary>
    public struct DanceVisibleMaidSet
    {
        public float time;
        public List<int> visible;
        public List<int> inVisible;
    }

    /// <summary>
    /// フリーダンスムービー値
    /// </summary>
    public struct DanceMovieSet
    {
        public string label;
        public int type;
        public string fileName;
    }

    /// <summary>
    /// フリーダンス背景変更値
    /// </summary>
    public struct DanceBgSet
    {
        public string bgName;
        public int groupNo;
        public float changeTime;
        public MyTransform transform;
        public float scale;
    }

    /// <summary>
    /// フリーダンスPNG値
    /// </summary>
    public struct DancePngSet
    {
        public String pngName;
        public float stTime;
        public float edTime;
        public MyTransform transform;
    }

    /// <summary>
    /// フリーダンスメイドアイテム値
    /// </summary>
    public struct DanceItemSet
    {
        public string tag;
        public string menu;
        public int activeSlotNo;
        public float stTime;
        public float edTime;
        public string option;
        public bool isSet;
    }

    /// <summary>
    /// フリーダンスPrefabオブジェクト値
    /// </summary>
    public struct DancePrefabSet
    {
        public string name;
        public int group;
        public float stTime;
        public float edTime;
        public MyTransform transform;
        public string option;
        public bool isBubble;
        public float lerpTime;
        public float deltaTime;
        public int maidSlotNo;
    }

    /// <summary>
    /// フリーダンスParticleオブジェクト値
    /// </summary>
    public struct DanceParticle
    {
        public GameObject particle;
        public string label;
        public string textureName;
        public string shaderName;
        public string officialName;
        public Vector3 position;
        public Vector3 rotation;
        public Vector3 scale;
        public float allScale;
        public Color32 color;
        public bool isColor;

        public ParticleMain main;
        public ParticleEmission emission;
        public ParticleShape shape;

        public ParticleColorOverLifetime colorOverLifetime;
        public ParticleColorBySpeed colorBySpeed;

        public ParticleInheritVelocity inheritVelocity;
        public ParticleVelocityOverLifetime velocityOverLifetime;
        public ParticleLimitVelocityOverLifetime limitVelocityOverLifetime;
        public ParticleForceOverLifetime forceOverLifetime;
        public ParticleExternalForces externalForces;
        public ParticleSizeOverLifetime sizeOverLifetime;
        public ParticleSizeBySpeed sizeBySpeed;
        public ParticleRotationOverLifetime rotationOverLifetime;
        public ParticleRotationBySpeed rotationBySpeed;

        public ParticleCollision collision;
        public ParticleNoise noise;
        public ParticleRender render;
        public ParticleTextureSheetAnimation textureSheetAnimation;
    }

    public struct DanceCameraAdjustSet
    {
        public int baseMinHeight;
        public int baseMaxHeight;
        public float singleAngleMax;
        public float multiAngleMax;
        public float cameraHeightMin;
        public float cameraMoveMax;
        public float deltaMax;
        public float correctRate;
    }

    public struct ParticleMain
    {
        public bool enabled;
        public float duration;
        public int maxParticles;
        public bool isLoop;
        public Vector2 startDelay;
        public Vector2 startLifetime;
        public Vector2 startSpeed;
        public Vector2 startSize;
        public Vector2 startRotation;
        public Vector2 gravityModifier;
    }
    public struct ParticleEmission
    {
        public bool enabled;
        public Vector2 rateOverTime;
        public Vector2 rateOverDistance;
        public Vector3 burst;
    }
    public struct ParticleShape
    {
        public bool enabled;
        public ParticleSystemShapeType shapeType;
        public float angle;
        public float sphericalDirectionAmount;
        public float randomDirectionAmount;
        public Vector3 boxSize;
        public ParticleSystemShapeMultiModeValue radiusMode;
        public float radius;
        public float radiusSpread;
        public Vector2 radiusSpeed;
        public ParticleSystemShapeMultiModeValue arcMode;
        public float arc;
        public float arcSpread;
        public Vector2 arcSpeed;
    }
    public struct ParticleColorOverLifetime
    {
        public bool enabled;
        public ParticleSystemGradientMode mode;
        public bool isRandom;
        public Dictionary<ParticleSystemGradientMode, GradientColorKey[]> gradientColor;
        public Dictionary<ParticleSystemGradientMode, GradientAlphaKey[]> gradientAlpha;
    }
    public struct ParticleColorBySpeed
    {
        public bool enabled;
        public ParticleSystemGradientMode mode;
        public bool isRandom;
        public Dictionary<ParticleSystemGradientMode, GradientColorKey[]> gradientColor;
        public Dictionary<ParticleSystemGradientMode, GradientAlphaKey[]> gradientAlpha;
        public Vector2 range;
    }
    public struct ParticleInheritVelocity
    {
        public bool enabled;
        public Vector2 curve;
    }
    public struct ParticleVelocityOverLifetime
    {
        public bool enabled;
        public ParticleMinMaxXYZ speed;
    }
    public struct ParticleLimitVelocityOverLifetime
    {
        public bool enabled;
        public float dampen;
        public ParticleMinMaxXYZ limit;
    }
    public struct ParticleForceOverLifetime
    {
        public bool enabled;
        public bool randomized;
        public ParticleMinMaxXYZ force;
    }
    public struct ParticleExternalForces
    {
        public bool enabled;
        public float multiplier;
    }
    public struct ParticleSizeOverLifetime
    {
        public bool enabled;
        public ParticleMinMaxXYZ size;
    }
    public struct ParticleSizeBySpeed
    {
        public bool enabled;
        public ParticleMinMaxXYZ size;
        public Vector2 range;
    }
    public struct ParticleRotationOverLifetime
    {
        public bool enabled;
        public ParticleMinMaxXYZ rotation;
    }
    public struct ParticleRotationBySpeed
    {
        public bool enabled;
        public ParticleMinMaxXYZ rotation;
        public Vector2 range;
    }
    public struct ParticleCollision
    {
        public bool enabled;
        public Vector2 dampen;
        public Vector2 bounce;
        public Vector2 lifetimeLoss;
        public float minKillSpeed;
    }
    public struct ParticleNoise
    {
        public bool enabled;
        public ParticleMinMaxXYZ strength;
        public float frequency;
        public bool damping;
    }
    public struct ParticleRender
    {
        public bool enabled;
        public ParticleSystemRenderMode mode;
    }
    public struct ParticleTextureSheetAnimation
    {
        public bool enabled;


    }
    public struct ParticleMinMaxXYZ
    {
        public Vector2 x;
        public Vector2 y;
        public Vector2 z;
    }

    /// <summary>
    /// フリーダンスMaidPrefabオブジェクト値
    /// </summary>
    public struct DanceMaidPrefabSet
    {
        public string name;
        public int group;
        public int maidSlotNo;
        public string maidBone;
        public float stTime;
        public float edTime;
        public MyTransform transform;
        public string option;
        public bool isAdded;
    }

    /// <summary>
    /// フリーダンスPrimitiveオブジェクト値
    /// </summary>
    public struct DancePrimitiveSet
    {
        public string type;
        public int group;
        public float stTime;
        public float edTime;
        public MyTransform transform;
        public string option;
        public float lerpTime;
        public float deltaTime;
        public string texture;
        public Vector2 textureSize;
        public string shader;
        public Vector4 stColor;
        public Vector4 edColor;
        public int maidSlotNo;
        public bool isFlashing;
        public float colorTimer;
    }

    /// <summary>
    /// フリーダンスPartticleオブジェクト値
    /// </summary>
    public struct DancePartticleSet
    {
        public string label;
        public int group;
        public float stTime;
        public float edTime;
        public MyTransform transform;
        public string option;
        public float lerpTime;
        public float deltaTime;
        public int maidSlotNo;
    }

    /// <summary>
    /// フリーダンスLightオブジェクト値
    /// </summary>
    public struct DanceLightSet
    {
        public string type;
        public int group;
        public float stTime;
        public float edTime;
        public MyTransform transform;
        public string option;
        public float lerpTime;
        public float deltaTime;
        public Vector3 stColor;
        public Vector3 edColor;
        public float range;
        public float intensity;
        public float spotAngle;
        public int maidSlotNo;
    }

    /// <summary>
    /// フリーダンスモーション値（＋スクリーン）
    /// </summary>
    public struct DanceCameraMotionSet
    {
        public List<CameraTransformSet> motionData;
        public string motionName;
        public string subFolder;
        public CameraManager cameraMgr;
        public Camera camera;
        public GameObject plane;
        public RenderTexture rTexture;
        public Vector3 position;
        public Vector3 rotation;
        public Vector3 scale;
        public float addtionalPositionZ;
        public DanceCameraAdjustPlugin adjustPlugin;
        public bool isMotionOn;
        public bool isCustomMotion;
        public bool isScreen;
        public bool isVROn;
    }

    /// <summary>
    /// ダンスアニメーション同期値
    /// </summary>
    public struct DanceAnimationSyncSet
    {
        public bool isSyncDanceGap;
        public bool isFirstSync;
        public float firstSyncTime;
    }

    /// <summary>
    /// オートカメラ値
    /// </summary>
    public struct AutoCameraSet
    {
        public int maidIndex;
        public bool isRandomMaid;
        public int autoAngleIndex;
        public int guiAngleIndex;
        public float deltaTime;
        public Vector3 basePosition;
        public AutoCameraEachSet[] each;
        public CameraTransformSet autoCamera;
    }

    /// <summary>
    /// オートカメラ値（個別設定）
    /// </summary>
    public struct AutoCameraEachSet
    {
        public Vector3 positionMin;
        public Vector3 positionMax;
        public Vector2 autoTime;
        public bool isBackEnabled;
        public bool isInfrequent;
        public bool isAngleEnabled;
    }

    /// <summary>
    /// LookAtメイド値
    /// </summary>
    public struct MaidLookAtSet
    {
        public bool isAll;
        public bool isMaidEye;
        public bool isMotionOn;
        public int lookAtIndex;
        public int dividedIndex;
        public int cameraIndex;
        public int autoIndex;
        public int settingIndex;
        public float randomTime;
        public float chasingSpeed;
        public MaidLookAtEachSet[] divisionSet;
        public MaidLookAtEachSet[] subSet;
        public MaidLookAtEachSet[] lockSet;
    }

    /// <summary>
    /// LookAtメイド値（個別設定）
    /// </summary>
    public struct MaidLookAtEachSet
    {
        public int maidIndex;
        public int typeIndex;
        public int pointIndex;
        public int aroundTypeIndex;
        public int subSizeIndex;
        public bool isLookAt;
        public bool isRandomPoint;
        public bool isRandomMaid;
        public float distanceSlider;
        public CameraTransformSet autoCamera;
        public int autoAngleIndex;
        public bool isOffsetX;
        public bool isFixedPosY;
        public bool isFixedRotX;
        public bool isFixedRotY;
        public float offsetX;
        public float fixedPosY;
        public float fixedRotX;
        public float fixedRotY;
    }

    /// <summary>
    /// LookAtAuto値
    /// </summary>
    public struct MaidLookAtAutoSet
    {
        public Vector3 position;
        public Vector2 autoTime;
        public bool isEnabled;
    }

    /// <summary>
    /// メイドポジション値
    /// </summary>
    public struct MaidTransformSet
    {
        public string label;
        public int auto;
        public List<MyTransform> transform;
    }

    /// <summary>
    /// メイドランダム表情値
    /// </summary>
    public struct MaidRandomFaceSet
    {
        public List<Dictionary<string, float>>morphData;
        public Dictionary<int, MaidRandomFaceEachSet> eachDic; 
        public float fadeTime;
        public float minTime;
        public float maxTime;
    }

    /// <summary>
    /// メイドランダム表情値
    /// </summary>
    public struct MaidRandomFaceEachSet
    {
        public int morphIndex;
        public int preMorphIndex;
        public float deltaTime;
        public float fadeTime;
    }

    /// <summary>
    /// メイド拘束メニュー値
    /// </summary>
    public struct MaidBindSet
    {
        public string label;
        public Dictionary<string, string> menuDic;
        public Dictionary<string, Vector3> bindDic;
    }

    /// <summary>
    /// メイド衣装メニュー値
    /// </summary>
    public struct MaidDressMenuSet
    {
        public string label;
        public string type;
        public List<string> fileNameList;
    }

    /// <summary>
    /// メイドポーズボーン値
    /// </summary>
    public struct MaidPoseeBoneSet
    {
        public string boneName;
        public Vector3 localPosition;
        public Quaternion localRotation;
    }

    /// <summary>
    /// メイド表情値
    /// </summary>
    public struct MaidFacialSet
    {
        public Dictionary<string, float> bodyMorphDic;
        public Dictionary<string, float> facialMorphDic;
    }

    /// <summary>
    /// メイド胸値
    /// </summary>
    public struct MaidMuneSet
    {
        public int minSize;
        public int maxSize;
        public float gravity;
        public float damping;
        public float yawaraka;
        public float maxStiffness;
        public float minStiffness;
        public float maxStiffnessBra;
        public float minStiffnessBra;
    }

    /// <summary>
    /// メイドオートくぱ値
    /// </summary>
    public struct MaidAutoKupaSet
    {
        public bool isKupa;
        public bool isAnalKupa;
        public bool isReverse;
        public float lerpTime;
        public float minSize;
        public float maxSize;
        public float interval;
    }

    /// <summary>
    /// メイド歌モードくぱ値
    /// </summary>
    public struct MaidSongKupaSet
    {
        public float kupaSize;
        public float analkupaSize;
    }

    /// <summary>
    /// メイドスロット値
    /// </summary>
    public struct MaidSlotSet
    {
        public int activeSlotNo;
        public int coustomeSlotNo;
        public int danceSlotNo;
    }

    /// <summary>
    /// 動くメイド値
    /// </summary>
    /// </summary>
    public struct MaidMovingSet
    {
        public string folder;
        public int status;
        public float forwardSpeed;
        public int animationType;
        public List<MaidMovingAnimationSet> animationData;
    }

    /// <summary>
    /// 動くメイドポーズ値
    /// </summary>
    public struct MaidMovingAnimationSet
    {
        public string animation;
        public float fadeTime;
        public float waitTime;
    }

    /// <summary>
    /// メイドぶっかけ値
    /// </summary>
    public struct MaidBukkakeSet
    {
        public bool[] slotNo;
        public bool[,] fileNo;
        public Vector4 min;
        public Vector4 max;
        public int repeat;
        public bool isAutoFit;

        public MaidBukkakeSet(bool dummy)
        {
            slotNo = new bool[MyConst.BUKKAKE_TAG.Count()];
            fileNo = new bool[2, MyConst.BUKKAKE_FILE_MAX];
            min = new Vector4(0f, 0f, 0f, MyConst.SCALE_DEFAULT * 0.5f);
            max = new Vector4(MyConst.BUKKAKE_TEXTURE_SIZE, MyConst.BUKKAKE_TEXTURE_SIZE, MyConst.BUKKAKE_TEXTURE_SIZE, MyConst.SCALE_DEFAULT * 0.75f);
            repeat = MyConst.BUKKAKE_REPEAT_MIN;
            isAutoFit = false;
        }
    }

    /// <summary>
    /// メイド浣腸値
    /// </summary>
    public struct MaidEnemaSet
    {
        public float duration;
        public float startLifetime;
        public float startSize;
        public float startRotation;
        public float gravityModifier;
        public bool isShader;
        public Color32 color;
        public string textureName;
    }

    /// <summary>
    /// 歌口パク値
    /// </summary>
    public struct SongMouthSet
    {
        public string character;
        public Vector3 stMouth;
        public Vector3 edMouth;
        public Dictionary<string, float> mouthMorph;
        public float stTime;
        public float deltaTime;
    }

    /// <summary>
    /// 歌カスタム表情値
    /// </summary>
    public struct SongCustomFacialSet
    {
        public float time;
        public float fadeTime;
        public float lerpTime;
        public string faceLabel;
        public string blend;
        public Dictionary<string, float> stFaceMorph;
        public Dictionary<string, float> edFaceMorph;
    }

    /// <summary>
    /// 歌ポーズ値
    /// </summary>
    public struct SongPoseSet
    {
        public float time;
        public int poseType;
        public string animation;
        public float fadeTime;
        public float startTime;
        public float speed;
        public int loopIndex;
        public float loopTime;
        public Vector3 position;
        public Vector3 rotation;
        public Maid.EyeMoveType eyeMoveType;
        public string option;
        public List<SongLoopPoseSet> loopData;
        public bool isFadeTime;
    }

    /// <summary>
    /// 歌ループポーズ値
    /// </summary>
    public struct SongLoopPoseSet
    {
        public string loopName;
        public int loopNo;
        public string animation;
        public float fadeTime;
        public Vector3 position;
        public Vector3 rotation;
    }

    /// <summary>
    /// モーションタイムライン値
    /// </summary>
    public struct MotionTimeLineSet
    {
        public int frame;
        public string name;
        public Vector3 position;
        public Vector3 rotation;
        public int easing;
        public float morphValue;
        public float distance;
        public float viewAngle;
        public string blend;
        public Maid.EyeMoveType eyeMoveType;
    }

    /// <summary>
    /// モーション再生値
    /// </summary>
    public struct MotionPlaySet
    {
        public float lerpFrame;
        public int listIndex;
        public List<MotionPlayLoopSet> motion;
    }

    /// <summary>
    /// モーションループ再生値
    /// </summary>
    public struct MotionPlayLoopSet
    {
        public int stFrame;
        public int edFrame;
        public int deltaFrame;
        public MyTransform transform;
        public int easing;
        public float startValue;
        public float endValue;
    }

    /// <summary>
    /// 任意ライト値
    /// </summary>
    /// 
    public struct FreeLightSet
    {
        public Light light;
        public Color32 color;
        public Vector3 position;
        public Vector3 rotation;
        public float spotAngle;
        public float range;
        public float intensity;
        public float shadowStrength;
        public int maidIndex;
        public bool isFollowing;
    }

    /// <summary>
    /// 舞台道具値
    /// </summary>
    public struct FreeStageObjectSet
    {
        public GameObject stageObject;
        public Texture2D texture;
        public Color32 color;
        public Vector3 position;
        public Vector3 rotation;
        public Vector3 scale;
        public float allScale;
        public string textureName;
        public string key;
        public RenderTexture rTexture;
        public LookAtCameraManager lookAtCam;
        public MaidLookAtSet maidLookAt;
        public bool isUnlight;
        public bool isLight;
        public bool isTrans;
        public int maidIndex;
        public bool isRepeat;
        public bool isCurved;
        public float textureScaleX;
        public float textureScaleY;
        public FreeLineSet lineSet;
        public FreeCurevedSet curevedSet;
        public VideoManager videoMgr;
    }

    /// <summary>
    /// 背景値
    /// </summary>
    public struct FreeBgSet
    {
        public string bgName;
        public Vector3 position;
        public Vector3 rotation;
        public float scale;
        public bool isRandom;
    }

    /// <summary>
    /// 背景パーツ値
    /// </summary>
    public struct FreeBgPartsSet
    {
        public string bgName;
        public List<string> partsName;
        public GameObject bgData;
        public Vector3 position;
        public Vector3 rotation;
        public Vector3 scale;
    }

    /// <summary>
    /// 前景値
    /// </summary>
    public struct FreeForegroundSet
    {
        public string pngName;
        public Image image;
        public bool isFixedSize;
        public int width;
        public int height;
        public float alpha;
    }

    /// <summary>
    /// メイドマスク値
    /// </summary>
    public struct FreeMaidMaskSet
    {
        public string pngName;
        public int width;
        public int height;
        public Color32 color;
        public bool isEnabled;
    }

    /// <summary>
    /// メイドマスクパネル値
    /// </summary>
    public struct FreeMaidMaskPanelSet
    {
        public Image image;
        public string apname;
        public FreeMaidMaskSet mask;
    }

    /// <summary>
    /// Modモデル値
    /// </summary>
    public struct FreeModelSet
    {
        public GameObject modelObject;
        public string viewName;
        public string modelName;
        public Vector3 position;
        public Vector3 rotation;
        public Vector3 scale;
        public float allScale;
        public bool isFollowing;
        public int maidIndex;
        public int pointIndex;
    }

    /// <summary>
    /// バブル・ラメ値
    /// </summary>
    public struct FreeBubbleLameSet
    {
        public GameObject bubbleLame;
        public string label;
        public string type;
        public float minSize;
        public float maxSize;
        public float minEnergy;
        public float maxEnergy;
        public float minEmission;
        public float maxEmission;
        public Vector3 worldVelocity;
        public Vector3 rndVelocity;
        public float angularVelocity;
        public float rndAngularVelocity;
        public bool rndRotation;
        public Vector3 position;
        public Vector3 rotation;
        public Color32 color;
        public string textureName;
        public Texture2D texture;
    }

    /// <summary>
    /// ライン値
    /// </summary>
    public struct FreeLineSet
    {
        public string type;
        public float length;
        public float frameWidth;
        public int numCornerVertices;
        public int flashingRndomTime;
        public float flashingInterval;
    }

    /// <summary>
    /// サイリウム値
    /// </summary>
    public struct FreeCyalumeSet
    {
        public Vector2 floor1st;
        public Vector2 floor2nd;
        public bool isPair1st;
        public bool isPair2nd;
        public float pairSpace;
        public Vector3 position1st;
        public Vector3 position2nd;
        public Vector3 positionAdjustment;
        public Vector3 rotation;
        public Vector3 scale;
        public Vector3 moveDistance;
        public float moveTime;
        public float rotationAddY;
        public float fadeTime;
        public float changeTime;
        public Color32[] color;
        public bool isRandomColors;
        public bool isRandomColor;
        public bool isRandomChanged;
        public string textureName;
    }

    /// <summary>
    /// 個別舞台道具値
    /// </summary>
    public struct FreeCrowdSet
    {
        public int layer;
        public int mobNumber;
        public float centerDistance;
        public float mobDistanceX;
        public float mobDistanceZ;
        public List<GameObject> crowd;
    }

    /// <summary>
    /// 湾曲値
    /// </summary>
    public struct FreeCurevedSet
    {
        public float width;
        public float height;
        public float depth;
        public int points;
        public float angle;
    }

    /// <summary>
    /// マイポーズ値
    /// </summary>
    public struct FreeMyPoseSet
    {
        public string animation;
        public bool isOldAnimation;
        public string poseName;
        public string poseFolder;
        public string poseFullPath;
        public List<byte[]> poseData;
        public float startTime;
        public float endTime;
        public float fadeTime;
        public float stateTime;
        public int poseIndex;
    }

    /// <summary>
    /// キー設定値
    /// </summary>
    public struct KeySet
    {
        public string gui;
        public string cameraForward;
        public string cameraBack;
        public string cameraLeft;
        public string cameraRight;
        public string cameraUp;
        public string cameraDown;
        public string movingForward;
        public string movingUp;
        public string movingDown;
        public string movingLeftRotation;
        public string movingRightRotation;
    }

    /// <summary>
    /// キー設定値
    /// </summary>
    public struct GuiSet
    {
        public GameObject gear;
        public bool isGuiOn;
        public bool isMaidsDanceOn;
        public bool isMaidsSwingMuneOn;
        public bool isMaidsSwingHairOn;
        public bool isMaidsSwingDressOn;
        public bool isMaidsEyesOn;
        public bool isDanceCameraAdjustOn;
        public bool isGuiAutoOff;
        public bool isUiAutoOff;
        public bool isGearOn;
        public bool isFadeOn;
        public bool isBackgroundEnabled;
        public float fadeInTime;
        public float fadeOutTime;
        public Vector4 backgroundColor;
    }

    /// <summary>
    /// キー＆マウス移動値（Setting.xml）
    /// </summary>
    public struct MoveSpeedSet
    {
        public float keyMove;
        public float mouseMove;
        public float mouseRotate;
        public float maidForward;
        public float maidRotation;
        public float maidUpDown;
    }

    /// <summary>
    /// レンダーテクスチャー値（Setting.xml）
    /// </summary>
    public struct RenderTextureSet
    {
        public int width;
        public int height;
        public bool isMask;
    }

    /// <summary>
    /// スプライト値（Setting.xml）
    /// </summary>
    public struct SpriteSet
    {
        public float rectX;
        public float rectY;
        public float pivotX;
        public float pivotY;
    }

    /// <summary>
    /// LookAt値（Setting.xml）
    /// </summary>
    public struct LookAtSet
    {
        public float randomTime;
        public float distance;
        public float distanceScreen;
        public float rotateAroundTime;
        public MaidLookAtAutoSet[] autoData;
    }

    /// <summary>
    /// カメラモーション変化判定値（Setting.xml）
    /// </summary>
    public struct CameraMotionDeltaSet
    {
        public float time;
        public float position;
        public float rotation;
        public float viewAngle;
    }

    /// <summary>
    /// メイドモーション値（Setting.xml）
    /// </summary>
    public struct MaidMotionSet
    {
        public float time;
        public float position;
        public float rotation;
        public float morphValue;
    }

    // <summary>
    /// スカイボックス値（Setting.xml）
    /// </summary>
    public struct SkyboxSet
    {
        public Texture2D texture;
        public string textureName;
        public bool isPngFoloder;
    }

    // <summary>
    /// タイムライン再生値
    /// </summary>
    public struct TimeLinePlaySet
    {
        public string boneFile;
        public string morphFile;
        public string cameraFile;
        public string audioFile;
        public string animeFile;
        public string adjustedFile;
        public string vmdFile;
        public string boneExportFile;
        public bool isAllMaids;
        public bool isWrite;
        public bool isPlay;
        public bool isPause;
        public bool isLoop;
        public bool isMorphPlay;
        public bool isPlayTime;
        public bool isUpdateCamera;
        public bool isMaidBone;
        public bool isEnabledCamera;
        public bool isViewAngle;
        public bool isOfficialDance;
        public int fromFrame;
        public int toFrame;
        public int adjustedFrame;
        public int optionIndex;
        public int vmdTypeIndex;
        public int frameAdjustmentIndex;
        public int faceTypeIndex;
        public float allPlayTime;
        public List<FreeDanceSet> danceData;
        public List<DanceCameraMotionSet> danceCameraData;
    }

    #endregion

    /// <summary>
    /// プラグイン設定値
    /// </summary>
    public struct MyConst
    {
        public const string TITLE_COM3D2 = "COM3D2x64";
        public const string PLUGIN_NAME = "DanceCameraMotion.PluginTest";
        public const string PLUGIN_VERSION = "4.7.0";

        public const string FOLDER_ROOT = "DanceCameraMotion";
        public const string FOLDER_MOTION = "motion";
        public const string FOLDER_FACE = "face";
        public const string FOLDER_MOUTH = "mouth";
        public const string FOLDER_GHANGE = "change";
        public const string FOLDER_CAMERA = "camera";
        public const string FOLDER_ANIMATION = "animation";
        public const string FOLDER_PNG = "png";
        public const string FOLDER_SONG = "song";
        public const string FOLDER_VIDEO = "video";
        public const string FOLDER_MYPOSE = "mypose";
        public const string FOLDER_TIMELINE = "timeline";
        public const string FOLDER_PREFAB = "Prefab/";
        public const string FOLDER_PARTICLE = "Particle";
        public const string FOLDER_PHOTOVER = "photo_ver";
        public const string FOLDER_SHADER = "shaders";
        public const string FOLDER_BG = "BG/";
        public const string FOLDER_BG2 = "BG/2_0/";
        public const string FOLDER_SYBARIS = @"Sybaris\UnityInjector\Config\" + FOLDER_ROOT;
        public const string FOLDER_GAMEDATA = @"GameData";
        public const string FOLDER_SEIEKI = "res:Seieki/spe";
        public const string FOLDER_TIMELINE_COMMON = "【汎用】";

        public const string FILE_PATH_SHADER = @"ShaderChange\shaderchange";

        public const string FILE_SWITCER = "Switcher.xml";
        public const string FILE_MAID_TRANSFORM = "MaidTransform.xml";
        public const string FILE_MAID_RANDOM_FACE = "MaidRandomFace.xml";
        public const string FILE_MAID_CUSTOM_FACE = "MaidCustomFace.xml";
        public const string FILE_MAID_BIND = "MaidBind.xml";
        public const string FILE_MAID_BIND_SAMPLE = "sampleMaidBind_{0}.xml";
        public const string FILE_MAID_DRESS = "MaidDress.xml";
        public const string FILE_MAID_DRESS_GROUP = "MaidDressGroup.xml";
        public const string FILE_MAID_DRESS_MENU = "MaidDressMenu.xml";
        public const string FILE_MAID_HAIR = "MaidHair.xml";
        public const string FILE_MAID_HAIR_MENU = "MaidHairMenu.xml";
        public const string FILE_MAID_SKIRT = "MaidSkirt.xml";
        public const string FILE_MAID_MOUTH = "MaidMouth.csv";
        public const string FILE_MAID_MOVING = "MaidMoving.xml";
        public const string FILE_MAID_BUKKAKE = "MaidBukkake.xml";
        public const string FILE_MAID_BUKKAKE_SAMPLE = "sample" + FILE_MAID_BUKKAKE;
        public const string FILE_MAID_ITEM_MIKE = "change_item_HandMike.csv";
        public const string FILE_DANCE_LIST = "DanceList.xml";
        public const string FILE_DANCE_LIST_GROUP = "DanceListGroup.xml";
        public const string FILE_DANCE_MOVIE = "DanceMovie.xml";
        public const string FILE_SONG_LIST = "SongList.xml";
        public const string FILE_SONG_LIST_GROUP = "SongListGroup.xml";
        public const string FILE_STAGE_LIGHT = "StageLight.xml";
        public const string FILE_STAGE_OBJECT = "StageObject.xml";
        public const string FILE_STAGE_MODEL = "StageModel.xml";
        public const string FILE_STAGE_BUBBLE_LAME = "StageBubleLame.xml";
        public const string FILE_STAGE_PARTICLE = "StageParticle.xml";
        public const string FILE_SETTING = "Setting.xml";
        public const string FILE_SETTING_MAID_SWING = "SettingMaidSwing.xml";
        public const string FILE_SETTING_DANCE_EFFECT = "SettingDanceEffect.xml";
        public const string FILE_SETTING_SCREEN_UNDRESS = "SettingScreenUndress.xml";
        public const string FILE_BACKGROUND = "Background.xml";
        public const string FILE_BACKGROUND_PARTS = "BackgroundParts.xml";
        public const string FILE_LOOK_AT = "LookAt.xml";
        public const string FILE_AUTO_CAMERA = "AutoCamera.xml";
        public const string FILE_DANCE_LIST_SAMPLE = "sample_{0}.xml";
        public const string FILE_MOTION = "motion_{0}.csv";
        public const string FILE_FACE = "face_{0}{1}.csv";
        public const string FILE_MOUTH = "mouth_{0}{1}.csv";
        public const string FILE_BGM = "BGM{0:000}.ogg";
        public const string FILE_GEAR = "gearicon.png";
        public const string FILE_EXPORT_ANM = "ExportFileListAnm.txt";
        public const string FILE_EXPORT_OGG = "ExportFileListOgg.txt";
        public const string FILE_EXPORT_ALL = "ExportFileListAll.txt";

        public const char DELIMITER_CSV = ',';
        public const char DELIMITER_STRING = '|';
        public const char DELIMITER_PATH = '/';
        public const char DELIMITER_BUKKAKE = ':';
        public static char NULL_CHAR = '\0';

        public const string EXTENSION_TXT = ".txt";
        public const string EXTENSION_CSV = ".csv";
        public const string EXTENSION_MODEL = ".model";
        public const string EXTENSION_MENU = ".menu";
        public const string EXTENSION_ANM = ".anm";
        public const string EXTENSION_OGG = ".ogg";
        public const string EXTENSION_WAV = ".wav";
        public const string EXTENSION_PNG = ".png";
        public const string EXTENSION_VMD = ".vmd";

        public const string HEADER_MOTION = "easingType,stTime,stPosX,stPosY,stPosZ,stRotX,stRotY,stRotZ,edTime,edPosX,edPosY,edPosZ,edRotX,edRotY,edRotZ,stDistance,edDistance,stViewAngle,edViewAngle";
        public const string HEADER_FACE = "time,face,blend";
        public const string HEADER_FACE_FULL = HEADER_FACE + ",eyeMoveType,frame";
        public const string HEADER_MOUTH = "mouth";
        public const string HEADER_MAID_MOTION = "frame,boneName,rotX,rotY,rotZ,posX,posY,posZ,easing";
        public const string HEADER_MAID_MORPH = "frame,morphName,morphValue";
        public const string HEADER_MAID_CAMERA = "frame,posX,posY,posZ,rotX,RotY,rotZ,distance,viewAngle,easing";
        public const string HEADER_ANIMATION_NAME = "CM3D2_ANIM";
        public const string HEADER_CAPTURE_BONE = "bone_";
        public const string HEADER_CAPTURE_MORPH = "morph_";
        public const string HEADER_FRAME_ADJUSTMENT = "adjustmentFrame_";
        public const string HEADER_ANM_ADJUSTMENT = "adjustmentAnm_";
        public const string HEADER_BONE_SELECT = "selectBone_";
        public const string PATH_WWW = @"file:///";
        public const string DANCE_TYPE_COM3D2 = "COM3D2";
        public const string DANCE_TYPE_CM3D2 = "CM3D2";
        public const string SHCENE_DANCE = "SceneDance_";
        public const string SHCENE_VR = "SceneVR";
        public const string STATE_DANCE = "dance";
        public const string STATE_KARAOKE = "_kara";

        public const string DEFAULT_ANIME = "maid_stand01.anm";
        public const string DEFAULT_MAN_ANIME = "man_porse01.anm";
        public const string DEFAULT_FACE = "通常";
        public const string DEFAULT_BLEND = "オリジナル";
        public const string DANCE_FACE_EYE_CLOSE = "ダンス目つむり";
        public const string DANCE_FACE_EYE_OPEN = "ダンス目あけ";
        public const string ITEM_HAND = "handitem";
        public const string ITEM_DEL_MENU = "_I_{0}_del.menu";
        public const string ITEM_DEL_MENU_END = "_del.menu";
        public const string ITEM_DEL_MENU_BIND_U = "_i_kousokuu_del.menu";
        public const string ITEM_DEL_MENU_BIND_L = "_i_kousokul_del.menu";
        public const string OBJECT_PREFAB = "prefab";
        public const string OBJECT_PRIMITIVE = "primitive";
        public const string OBJECT_PRIMITIVE_LINE = "line";
        public const string OBJECT_LIGHT = "light";
        public const string OBJECT_MENU = "menu";
        public const string OBJECT_OPTION_LIFTUP = "liftup";
        public const string OBJECT_OPTION_RANDOM_COLOR = "randomcolor";
        public const string OBJECT_OPTION_HEIGHT_ADJUSTMENT = "heightadjustment";
        public const string OBJECT_OPTION_UNLIGHT = "unlight";
        public const string OBJECT_OPTION_TRANSPARENT = "transparent";
        public const string OBJECT_OPTION_NOTDEACTIVE = "notdeactive";
        public const string OBJECT_OPTION_MAINLIGHT_ON = "mainlighton";
        public const string OBJECT_OPTION_MAINLIGHT_OFF = "mainlightoff";
        public const string OBJECT_OPTION_ALL_MAIDS = "allmaids";
        public const string OBJECT_OPTION_STAND_MIKE = "standmike";
        public const string OBJECT_OPTION_BUBBLE = "bubble";
        public const string OBJECT_OPTION_FLASHING = "flashing";
        public const string OBJECT_MOB = "Mob_Man_Stand00{0}";
        public const string SONG_OPTION_BREATH_ON = "breathon";
        public const string SONG_OPTION_BREATH_OFF = "breathoff";
        public const string SONG_OPTION_KUPA_ON = BODY_TAG_KUPA + "on";
        public const string SONG_OPTION_KUPA_OFF = BODY_TAG_KUPA + "off";
        public const string SONG_OPTION_ANALKUPA_ON = BODY_TAG_ANALKUPA + "on";
        public const string SONG_OPTION_ANALKUPA_OFF = BODY_TAG_ANALKUPA + "off";
        public const string SCREEN_CAMERA = "ScreenCamera";
        public const string DECIMAL_FORMAT = "0.000";
        public const string SONG_TYPE_DANCE = "dance";
        public const string PERTICLE_PEE_CM = "pNyou_cm3D2";
        public const string PERTICLE_PEE_COM = "pNyouE_com3D2";
        public const string PERTICLE_PEE_STEAM = "NyouSteam";
        public const string PERTICLE_PEE_HIMATU = "NyouHimatsu";
        public const string PERTICLE_BREATH = "pToiki";
        public const String PROPNAME_MAINTEX = "_MainTex";
        public const String PROPNAME_SHADOWTEX = "_ShadowTex";
        public const string BONE_ALL = "Bip01";
        public const string BONE_HEAD = "Bip01 Head";
        public const string BONE_RIGHT = "Bip01 R";
        public const string HAIR_F = "hairf";
        public const string HAIR_R = "hairr";
        public const string IK_VAGINA = "_IK_vagina";
        public const string DRESS_TAG_ACCKAMISUB = "acckamisub";
        public const string DRESS_TAG_SKIN = "skin";
        public const string DRESS_TAG_BIND_U = "kousoku_upper";
        public const string DRESS_TAG_BIND_L = "kousoku_lower";
        public const string BODY_TAG_KUPA = "kupa";
        public const string BODY_TAG_ANALKUPA = "analkupa";
        public const string FACE_EYE_CLOSE = "eyeclose";
        public const string FACE_EYE_CLOSE_FB = "eyeclose1";
        public const string FACE_EYE_SMILE = "eyeclose2";
        public const string FACE_EYE_CLOSE_3 = "eyeclose3";
        public const string FACE_EYE_CLOSE_5 = "eyeclose5";
        public const string FACE_EYE_CLOSE_6 = "eyeclose6";
        public const string FACE_EYE_CLOSE_7 = "eyeclose7";
        public const string FACE_EYE_CLOSE_8 = "eyeclose8";
        public const string FACE_EYE_BIG = "eyebig";
        public const string FACE_MOUTH_A = "moutha";
        public const string FACE_MOUTH_I = "mouthi";
        public const string FACE_MOUTH_C = "mouthc";
        public const string FACE_MOUTH_UP = "mouthup";
        public const string FACE_OPTION_HOHO1 = "hohos";
        public const string FACE_OPTION_BLUSH = "hoho2";
        public const string FACE_OPTION_TEARS = "namida";
        public const string PORORI_NAME = "porori{0}";
        public const string BUKKAKE_BODY = "body";
        public const string BUKKAKE_HEAD = "head";
        public const string SE_PEE = "SE011.ogg";
        public const string OFFICIAL_BODY = "body001_I_.menu";
        public const string ATTACH_POINT_ANAL = "アナル";
        public const string BG_DELETE = "delete";
        public const string WINDOW_TITLE_MOTION = "DCMタイムライン({0})";
        public static string CHARA_UTF8 = "utf-8";

        public const string SHADER_DIFFUSE = "Diffuse";
        public const string SHADER_DIFFUSE_TRANS = "Transparent/Diffuse";
        public const string SHADER_LIGHTED = "CM3D2/Lighted";
        public const string SHADER_LIGHTED_TRANS = "CM3D2/Lighted_Trans";
        public const string SHADER_UNLIGHT = "Unlit/Texture";
        public const string SHADER_UNLIGHT_TRANS = "CM3D2/Unlit_Texture_Photo_MyObject";
        public const string SHADER_PARTICLE = "Particles/Additive (Soft)";
        public const string SHADER_MOSAIC = "CM3D2/Mosaic";
        public const string MATERIAL_MIRROR = "Mirror";
        public const string MATERIAL_ASSET_MIRROR = "MirrorChange";
        public const string MATERIAL_COLOR = "_TintColor";       

        public const string STAGE_OBJECT_NAME_PARTICLE = "particle";
        public const string DEFAULT_KEY_GUI = "k";
        public const string DEFAULT_KEY_FORWARD = "w";
        public const string DEFAULT_KEY_BACK = "s";
        public const string DEFAULT_KEY_LEFT = "a";
        public const string DEFAULT_KEY_RIGHT = "d";
        public const string DEFAULT_KEY_UP = "q";
        public const string DEFAULT_KEY_DOWN = "e";
        public const string DEFAULT_KEY_MOVE_FORWARD = "space";
        public const string DEFAULT_KEY_MOVE_UP = "up";
        public const string DEFAULT_KEY_MOVE_DOWN = "down";
        public const string DEFAULT_KEY_MOVE_LEFT = "left";
        public const string DEFAULT_KEY_MOVE_RIGHT = "right";

        public const byte COLOR_MIN = 0;
        public const byte COLOR_MAX = 255;
        public const byte COLOR_HELF = 127;
        
        public const float MOUSE_ROTATE_DISTANCE = 2f;
        public const float ADJUST_DANCE_TIME = 1f;
        public const float ADJUST_POSITION = 0.05f;
        public const float NORMAL_KEY_MOVE = 0.05f;
        public const float NORMAL_MOUSE_MOVE = 5f;        
        public const float ZOOM_DEFAULT = 35f;
        public const float ZOOM_DEFAULT_VR = 60f;
        public const float ZOOM_MIN = 0.1f;
        public const float ZOOM_MAX = 150f;
        public const float MIN_RANDOM_TIME = 1f;
        public const float DANCE_END_MARGIN = 0.5f;
        public const float DANCE_GAP_TIME = 0.5f;
        public const float DANCE_FADE_TIME = 1.5f;
        public const float LOOK_AT_RANDOM_TIME = 5f;
        public const float LOOK_AT_DISTANCE = 1.5f;
        public const float LOOK_AT_DISTANCE_SCREEN = 0.8f;
        public const float LOOK_AT_ROTATEAROUND_TIME = 10f;
        public const float LOOK_AT_FIXED_POS_Y = 1.5f;
        public const float LOOK_AT_FIXED_ROT_X = -75f;
        public const float LOOK_AT_FIXED_ROT_Y = 180f;
        public const float LOOK_AT_FIXED_SPEED = 0.1f;
        public const float LOOK_AT_CHASING_SPEED = 1f;
        public const float LOOK_AT_AUTO_TIME = 2f;
        public const float LOOK_AT_AUTO_MIN_Z = 0.5f;
        public const float MIAD_MOVE_FORWARD = 0.01f;
        public const float MIAD_MOVE_RAUND = 1f;
        public const float NORMAL_ANIMATION_SPEED = 1f;
        public const float CAMERA_DEFAULT = 0f;
        public const float CAMERA_DEFAULT_POS_Y = 1.5f;
        public const float CAMERA_DEFAULT_POS_Z = 2f;
        public const float CAMERA_DEFAULT_ROT_X = 10f;
        public const float CAMERA_DEFAULT_ROT_Y = 180f;
        public const float SCALE_DEFAULT = 1f;
        public const float SCALE_INVISIBLE_MAID = 0.00001f;
        public const float CURVED_TEXTURE_SCALE = 0.5f;
        public const float ITWEEN_ROTATING_TIME = 10f;
        public const float FRAME_CONVERSION_RATIO = 0.0333333351f;
        public const float POSITION_CONVERSION_RATIO = 12.5f;
        public const float STAND_HEIGHT_TALL = 0.375f;
        public const float STAND_HEIGHT_LOW = 0.35f;
        public const float STAND_HEIGHT_BASE = 0.9f;
        public const float LIGHT_SPOTANGLE = 30f;
        public const float LIGHT_RANGE = 25f;
        public const float LIGHT_INTENSITY = 0.95f;
        public const float LIGHT_SHADOW_STRENGTH = 0.098f;
        public const float LINE_FRAME_WIDTH = 0.04f;
        public const float EXPORT_AJUST_TIME = 2f;
        public const float POLE_SIZE = 0.05f;
        public const float UNDRESS_START_TIME = 30f;
        public const float UNDRESS_INTERVAL = 5f;
        public const float FACE_START_TIME = 2f;
        public const float FACE_MIN_TIME = 0.5f;
        public const float FACE_MAX_TIME = 2f;
        public const float FACE_FRAME = 30f;
        public const float MOUTH_RATIO_MIDDLE = 0.75f;
        public const float MOUTH_RATIO_SMALL = 0.5f;
        public const float PRESET_WAIT_TIME = 2f;
        public const float MOUTH_UP = 0.5f;
        public const float FACIAL_MIN = 0f;
        public const float FACIAL_MAX = 1f;
        public const float BODY_MIN = 0f;
        public const float BODY_MAX = 150f;
        public const float BODY_INTERVAL = 1f;
        public const float FACE_BLEND_VALUE = 1f;
        public const float FACE_FADE_TIME = 1f;
        public const float FACE_RANDOM_TIME_MIN = 0.5f;
        public const float FACE_RANDOM_TIME_MAX = 2f;
        public const float ANIMATION_SPEED = 1f;
        public const float ANIMATION_DELTA_TIME = 0.5f;
        public const float ANIMATION_FADE_TIME = 0.5f;
        public const float ANIMATION_NO_FADE_TIME = 0f;
        public const float VOLUME_MAX = 1f;
        public const float SWING_COMMON_MIN = 0f;
        public const float SWING_COMMON_MAX = 1f;
        public const float MUNE_GRAVITY_MAX = 0.7f;
        public const float MUNE_GRAVITY_DEFAULT = 0.1f;
        public const float MUNE_DAMPING_DEFAULT = 0.3f;
        public const float MUNE_YAWARAKA_DEFAULT = 0.5f;
        public const float MUNE_MAX_STIFFNESS_DEFAULT = 0.22f;
        public const float MUNE_MIN_STIFFNESS_DEFAULT = 0.055f;
        public const float MUNE_MAX_STIFFNESS_BRA_DEFAULT = 0.27f;
        public const float MUNE_MIN_STIFFNESS_BRA_DEFAULT = 0.07f;
        public const float HAIR_DAMPING_DEFAULT = 0.6f;
        public const float HAIR_ELASTICITY_DEFAULT = 1f;
        public const float HAIR_ELASTICITY_AHO_DEFAULT = 0.124f;
        public const float HAIR_STIFFNESS_DEFAULT = 0.1f;
        public const float HAIR_RADIUS_DEFAULT = 0.02f;
        public const float HAIR_RADIUS_MAX = 0.075f;
        public const float SKIRT_RADIUS_DEFAULT = 0.025f;
        public const float SKIRT_VELOCITY_DEFAULT = 0.8f;
        public const float SKIRT_FORCE_DEFAULT = 0.05f;
        public const float SKIRT_REG_RADIUS_DEFAULT = 0.1f;
        public const float SKIRT_STIFFNESS_DEFAULT = 0f;
        public const float SKIRT_STRESS_DEFAULT = 0.4f;
        public const float SKIRT_THRESHOLD_DEFAULT = 0.1f;
        public const float GUI_ONE_SLIDER_MIN = 0f;
        public const float GUI_ONE_SLIDER_SMALL = 0.01f;
        public const float GUI_ONE_SLIDER_NORMAL = 1f;
        public const float GUI_WINDOW_ALPHA = 100f;
        public const float GUI_TEXT_WIDTH_RATIO = 0.9f;

        public const int MAX_LENGTH_NUMBER = 8;
        public const int MAX_LENGTH_STRING = 255;
        public const int MAX_COLUMN = 4;
        public const int MAX_DANCE_MAID = 4;
        public const int MAX_MOTION_FRAME = 9999;
        public const int MAX_KEY_FRAME = 100;
        public const int DANCE_PLAY_NORMAL = 0;
        public const int DANCE_PLAY_RANDOM = 1;
        public const int DANCE_FIRST_INDEX = 0;
        public const int DANCE_SCREEN_OFF = 999;
        public const int ENUM_EX_VALUE = -1;
        public const int UNDRESS_FRONT = -1;
        public const int UNDRESS_BACK = -2;
        public const int UNDRESS_SHIFT = -3;
        public const int BASE_WINDOW_WIDTH = 1920;
        public const int BASE_WINDOW_HEIGHT = 1080;
        public const int RENDER_TEXTURE_DEPTH = 24;
        public const int RENDER_TEXTURE_ANTIALIASING = 8;
        public const int CAMERA_MAIN = 0;
        public const int CAMERA_LAYER_CHARA = 10;
        public const int CAMERA_LAYER_SCREEN_MASK = 29;
        public const int LOOK_AT_DIVISION = 9;
        public const int LOOK_AT_SUB = 4;
        public const int LOOK_AT_LOCK_ON = 1;
        public const int AUTO_CAMERA_FREC = 10;
        public const int SCREEN_CAMERA_INDEX = 1;
        public const int SCREEN_RATIO_WIDTH = 16;
        public const int SCREEN_RATIO_HEIGH = 9;
        public const int SCREEN_UNDRESS_PATTERN = 3;
        public const int POLE_COLER_R = 244;
        public const int POLE_COLER_G = 213;
        public const int POLE_COLER_B = 49;
        public const int MIRROR_TEXTURE_SIZE = 2048;
        public const int BUKKAKE_TEXTURE_SIZE = 1024;
        public const int FOREGROUND_MAX = 6;
        public const int STAGE_OBJECT_MIRROR = -1;
        public const int STAGE_OBJECT_SCREEN = -2;
        public const int STAGE_OBJECT_POLE = -3;
        public const int STAGE_OBJECT_LINE = -4;
        public const int STAGE_OBJECT_CURVED_PANEL = -5;
        public const int STAGE_OBJECT_CURVED_SCREEN = -6;
        public const int STAGE_OBJECT_CYALUME_MAX = 2;
        public const int STAGE_OBJECT_CYALUME_FLOORS = 2;
        public const int LINE_FRAME_NUM_CORNER = 20;
        public const int REMOVE_ANM_CLIP_COUNT = 100;
        public const int SLEEP_TIME = 100;
        public const int SLEEP_TIME_OOUT = 30000;
        public const int PIXELLIGHT_COUNT = 4;
        public const int BASE_NOTE = 4;
        public const int BASE_FRAME = 30;
        public const int GRADIENT_KEY = 8;
        public const int METRONOME = 120;
        public const int SWING_SETTING_COUNT = 5;
        public const int MULTEX_MATNO_COMMON = 0;
        public const int MULTEX_MATNO_HEAD = 5;
        public const int MULTEX_LAYERNO = 18;
        public const int BUKKAKE_FILE_MAX = 14;
        public const int BUKKAKE_REPEAT_MIN = 1;
        public const int FILE_TRUE = 1;
        public const int NO_DATA = -999;
        public const int PRE_INDEX = -1;
        public const int DUPLICATE_GROUP = 100;
        public const int FB_FACE_VERSION = 120;
        public const int HEADER_ANIMATION_VERSION = 2001;
        public const int GUI_WINDOW_ROW = 20;
        public const int GUI_WINDOW_ID_MAIN = 20010;
        public const int GUI_WINDOW_ID_MOTION = 20020;
        public const int GUI_FONT_SIZE = 14;
        public const int GUI_MARGIN = 10;
        public const int GUI_HEIGHT = 25;
        public const int GUI_WIDTH = 100;
        public const int GUI_WIDTH_TIME_LINE = 35;
        public const int GUI_WIDTH_MENU = 100;
        public const int GUI_SLIDER = 95;
        public const int GUI_SLIDER_INPUT = 40;
        public const int GUI_SLIDER_LABEL = 10;
        public const int GUI_GRID_COLUMN = 2;
        public const int GUI_FRAME_BONE = 5;
        public const int GUI_MAID_TRANSFORM_ROW = 9;
        public const int GUI_MAID_DRESS_ROW = 7;
        public const int GUI_CHANGE_WINDOW_BUTTON = 3;

        public const int DCA_BASE_MIN_HEIGHT = 145;
        public const int DCA_BASE_MAX_HEIGHT = 175;
        public const float DCA_SINGLE_ANGLE_MAX = 60.0f;
        public const float DCA_MULTI_ANGLE_MAX = 60.0f;
        public const float DCA_CAMERA_HEIGHT_MIN = 0.1f;
        public const float DCA_CAMERA_MOVE_MAX = 0.1f;
        public const float DCA_DELTA_MAX = 0.005f;
        public const float DCA_CORRECT_RATE = 0.8f;

        public const string MENU_LABEL_CHAR = "▼";
        public const int MENU_START_INDEX = 2;
        public readonly static string[] MAIN_MENU_LABEL =
        {   "▼フリーダンス",
            "▼ショトカ",
            "▼メイド", "配置・座標", "目線・脱衣", "スロット", "揺れ", "衣装替/拘束", "髪/体/表情", "モーション", "動く",
            "▼背景・前景", "背景選択","パーツ表示", "前景追加",
            "▼舞台演出", "舞台道具", "個別道具", "パーティクル", "モデル(MOD)", "照明",
            "▼カメラ", "注視・分割", "オートカメラ", "モーション", "座標切替",
            "▼おまけ", "ぶっかけ", "放出",
        };

        public readonly static Dictionary<TBody.SlotID, string> UNDRESS_SLOT = new Dictionary<TBody.SlotID, string>()
        {
            { TBody.SlotID.wear, "トップス" },
            { TBody.SlotID.skirt, "ボトムス" },
            { TBody.SlotID.onepiece, "ワンピース" },
            { TBody.SlotID.mizugi, "水着" },
            { TBody.SlotID.bra, "ブラジャー" },
            { TBody.SlotID.panz, "パンツ" },
            { TBody.SlotID.stkg, "靴下" },
            { TBody.SlotID.shoes, "靴" },
            { TBody.SlotID.glove, "手袋" },
            { (TBody.SlotID)UNDRESS_FRONT, "前めくれ" },
            { (TBody.SlotID)UNDRESS_BACK, "後めくれ" },
            { (TBody.SlotID)UNDRESS_SHIFT, "ずらし" },
        };

        public readonly static Dictionary<TBody.SlotID, string> SCREEN_UNDRESS_EXTRA_SLOT = new Dictionary<TBody.SlotID, string>()
        {
            { TBody.SlotID.chikubi, "乳首" },
            { TBody.SlotID.underhair, "陰毛" },
        };

        public readonly static Dictionary<TBody.SlotID, string> HAIR_SLOT = new Dictionary<TBody.SlotID, string>()
        {
            { TBody.SlotID.hairF, "▼前髪" },
            { TBody.SlotID.hairR, "▼後髪" },
            { TBody.SlotID.hairS, "▼横髪" },
            { TBody.SlotID.hairT, "▼エクステ髪" },
            { TBody.SlotID.hairAho, "▼アホ毛" },
        };

        public readonly static Dictionary<TBody.SlotID, string> SKIRT_SLOT = new Dictionary<TBody.SlotID, string>()
        {
            { TBody.SlotID.skirt, "▼スカート" },
            { TBody.SlotID.onepiece, "▼ワンピース" },
            { TBody.SlotID.wear, "▼トップス" },
            { TBody.SlotID.accSenaka, "▼背中" },
        };

        public readonly static Dictionary<string, string> SKIRT_TAG = new Dictionary<string, string>()
        {
            { "skirt", "スカート" },
            { "onepiece", "ワンピース" },
            { "wear", "トップス" },
            { "accsenaka", "背中" },
        };

        public readonly static Dictionary<string, string> HAIR_TAG = new Dictionary<string, string>()
        {
            { HAIR_F, "前髪" },
            { HAIR_R, "後髪" },
            { "hairs", "横髪" },
            { "hairt", "エクステ髪" },
            { "hairaho", "アホ毛" },
        };
        
        public readonly static Dictionary<string, string> DRESS_TAG_COMMON = new Dictionary<string, string>()
        {
            { "acchat", "帽子" },
            { "headset", "ヘッドドレス" },
            { "wear", "トップス" },
            { "skirt", "ボトムス" },
            { "onepiece", "ワンピース" },
            { "mizugi", "水着" },
            { "bra", "ブラジャー" },
            { "panz", "パンツ" },
            { "stkg", "靴下" },
            { "shoes", "靴" },
            { "acckami", "前髪アクセ" },
            { "megane", "メガネ" },
            { "acchead", "アイマスク" },
            { "acchana", "鼻" },
            { "accmimi", "耳" },
            { "glove", "手袋" },
            { "acckubi", "ネックレス" },
            { "acckubiwa", "チョーカー" },
            { DRESS_TAG_ACCKAMISUB, "リボン" },
            { "accnip", "乳首" },
            { "accude", "腕" },
            { "accheso", "へそ" },
            { "accashi", "足首" },
            { "accsenaka", "背中" },
            { "accshippo", "しっぽ" },
            { "accxxx", "前穴アクセ" },
            { "handitem", "手持ち" },
            { "accvag", "前穴" },
            { "accanl", "後穴" },
            { DRESS_TAG_BIND_U, "拘束腕" },
            { DRESS_TAG_BIND_L, "拘束足" },
        };

        public readonly static Dictionary<string, List<string>> DRESS_TAG_SLOT = new Dictionary<string, List<string>>()
        {
            { "acchat", new List<string>{"accHat", } },
            { "headset", new List<string>{"headset", } },
            { "wear", new List<string>{"wear", } },
            { "skirt", new List<string>{"skirt", } },
            { "onepiece", new List<string>{"onepiece", } },
            { "mizugi", new List<string>{"mizugi", } },
            { "bra", new List<string>{"bra", } },
            { "panz", new List<string>{"panz", } },
            { "stkg", new List<string>{"stkg", } },
            { "shoes", new List<string>{"shoes", } },
            { "acckami", new List<string>{"accKami_1_", "accKami_2_", "accKami_3_", } },
            { "megane", new List<string>{"megane", } },
            { "acchead", new List<string>{"accHead", } },
            { "acchana", new List<string>{"accHana", } },
            { "accmimi", new List<string>{"accMiMiL", "accMiMiR", } },
            { "glove", new List<string>{"glove", } },
            { "acckubi", new List<string>{"accKubi", } },
            { "acckubiwa", new List<string>{"accKubiwa", } },
            { DRESS_TAG_ACCKAMISUB, new List<string>{"accKamiSubL", "accKamiSubR", } },
            { "accnip", new List<string>{"accNipL", "accNipR", } },
            { "accude", new List<string>{"accUde", } },
            { "accheso", new List<string>{"accHeso", } },
            { "accashi", new List<string>{"accAshi", } },
            { "accsenaka", new List<string>{"accSenaka", } },
            { "accshippo", new List<string>{"accShippo", } },
            { "accxxx", new List<string>{"accXXX", } },
            { "handitem", new List<string>{"HandItemL", "HandItemR", } },
            { "accvag", new List<string>{"accVag", } },
            { "accanl", new List<string>{"accAnl", } },
            { DRESS_TAG_BIND_U, new List<string>{ "kousoku_upper", } },
            { DRESS_TAG_BIND_L, new List<string>{ "kousoku_lower", } },
        };

        public readonly static Dictionary<string, string> DRESS_TAG_EX = new Dictionary<string, string>()
        {
            { DRESS_TAG_SKIN, "肌" },
        };

        public readonly static Dictionary<string, string> BUKKAKE_TAG_BODY = new Dictionary<string, string>()
        {
            { BUKKAKE_HEAD, "顔" },
            { BUKKAKE_BODY, "体" },
        };

        public readonly static Dictionary<string, string> DRESS_TAG =
            DRESS_TAG_COMMON
            .Concat(DRESS_TAG_EX).ToDictionary(c => c.Key, c => c.Value);

        public readonly static Dictionary<string, string> BUKKAKE_TAG =
            BUKKAKE_TAG_BODY
            .Concat(HAIR_TAG).ToDictionary(c => c.Key, c => c.Value)
            .Concat(DRESS_TAG_COMMON).ToDictionary(c => c.Key, c => c.Value);

        public readonly static Dictionary<string, string> PORORI_TAG = new Dictionary<string, string>()
        {
            { "wear", "トップス" },
            { "skirt", "ボトムス" },
            { "onepiece", "ワンピース" },
            { "mizugi", "水着" },
            { "bra", "ブラジャー" },
            { "panz", "パンツ" },
        };

        public readonly static Dictionary<string, string> BONE_NAME_BODY = new Dictionary<string, string>()
        {
            { BONE_ALL, "0:全体" },
            { BONE_HEAD, "0:頭" },
            { "Bip01 Neck", "0:首" },
            { "Bip01 Spine1a", "0:背中上" },
            { "Bip01 Spine1", "0:背中下" },
            { "Bip01 Spine0a", "0:腰上" },
            { "Bip01 Spine", "0:腰下" },
            { "Bip01 Pelvis", "0:骨盤" },

            //{ "_IK_handL", "9:左手IK" },
            //{ "_IK_footL", "9:左足IK" },
            //{ "_IK_handR", "9:右手IK" },
            //{ "_IK_footR", "9:右足IK" },
            //{ "_IK_handL", "1:左手IK" },
            //{ "_IK_footL", "3:左足IK" },
            //{ "_IK_handR", "5:右手IK" },
            //{ "_IK_footR", "7:右足IK" },
        };

        public readonly static Dictionary<string, string> BONE_NAME_ARM = new Dictionary<string, string>()
        {
            { "Bip01 L Clavicle", "1:左鎖骨" },
            { "Bip01 L UpperArm", "1:左上腕" },
            { "Bip01 L Forearm", "1:左前腕" },
            { "Bip01 L Hand", "1:左手" },

            { "Bip01 R Clavicle", "2:右鎖骨" },
            { "Bip01 R UpperArm", "2:右上腕" },
            { "Bip01 R Forearm", "2:右前腕" },
            { "Bip01 R Hand", "2:右手" },
        };

        public readonly static Dictionary<string, string> BONE_NAME_FOOT = new Dictionary<string, string>()
        {
            { "Bip01 L Thigh", "3:左太腿" },
            { "Bip01 L Calf", "3:左すね" },
            { "Bip01 L Foot", "3:左足" },

            { "Bip01 R Thigh", "4:右太腿" },
            { "Bip01 R Calf", "4:右すね" },
            { "Bip01 R Foot", "4:右足" },
        };

        public readonly static Dictionary<string, string> BONE_NAME_FINGERS = new Dictionary<string, string>()
        {
            { "Bip01 L Finger0", "5:左親指付け根" },
            { "Bip01 L Finger01", "5:左親指第ニ関節" },
            { "Bip01 L Finger02", "5:左親指第一関節" },
            { "Bip01 L Finger1", "5:左人差指第三関節" },
            { "Bip01 L Finger11", "5:左人差指第ニ関節" },
            { "Bip01 L Finger12", "5:左人差指第一関節" },
            { "Bip01 L Finger2", "5:左中指第三関節" },
            { "Bip01 L Finger21", "5:左中指第ニ関節" },
            { "Bip01 L Finger22", "5:左中指第一関節" },
            { "Bip01 L Finger3", "5:左薬指第三関節" },
            { "Bip01 L Finger31", "5:左薬指第ニ関節" },
            { "Bip01 L Finger32", "5:左薬指第一関節" },
            { "Bip01 L Finger4", "5:左小指第三関節" },
            { "Bip01 L Finger41", "5:左小指第ニ関節" },
            { "Bip01 L Finger42", "5:左小指第一関節" },

            { "Bip01 R Finger0", "6:右親指付け根" },
            { "Bip01 R Finger01", "6:右親指第ニ関節" },
            { "Bip01 R Finger02", "6:右親指第一関節" },
            { "Bip01 R Finger1", "6:右人差指第三関節" },
            { "Bip01 R Finger11", "6:右人差指第ニ関節" },
            { "Bip01 R Finger12", "6:右人差指第一関節" },
            { "Bip01 R Finger2", "6:右中指第三関節" },
            { "Bip01 R Finger21", "6:右中指第ニ関節" },
            { "Bip01 R Finger22", "6:右中指第一関節" },
            { "Bip01 R Finger3", "6:右薬指第三関節" },
            { "Bip01 R Finger31", "6:右薬指第ニ関節" },
            { "Bip01 R Finger32", "6:右薬指第一関節" },
            { "Bip01 R Finger4", "6:右小指第三関節" },
            { "Bip01 R Finger41", "6:右小指第ニ関節" },
            { "Bip01 R Finger42", "6:右小指第一関節" },
        };

        public readonly static Dictionary<string, string> BONE_NAME_TOES = new Dictionary<string, string>()
        {
            { "Bip01 L Toe0", "7:左足小指" },
            { "Bip01 L Toe01", "7:左足小指先" },
            { "Bip01 L Toe1", "7:左足中指" },
            { "Bip01 L Toe11", "7:左足中指先" },
            { "Bip01 L Toe2", "7:左足親指" },
            { "Bip01 L Toe21", "7:左足親指先" },

            { "Bip01 R Toe0", "8:右足小指" },
            { "Bip01 R Toe01", "8:右足小指先" },
            { "Bip01 R Toe1", "8:右足中指" },
            { "Bip01 R Toe11", "8:右足中指先" },
            { "Bip01 R Toe2", "8:右足親指" },
            { "Bip01 R Toe21", "8:右足親指先" },
        };

        public readonly static Dictionary<string, string> BONE_NAME_MAIN =
            BONE_NAME_BODY
            .Concat(BONE_NAME_ARM).ToDictionary(c => c.Key, c => c.Value)
            .Concat(BONE_NAME_FOOT).ToDictionary(c => c.Key, c => c.Value);

        public readonly static Dictionary<string, string> BONE_NAME_ALL =
            BONE_NAME_MAIN
            .Concat(BONE_NAME_FINGERS).ToDictionary(c => c.Key, c => c.Value)
            .Concat(BONE_NAME_TOES).ToDictionary(c => c.Key, c => c.Value);

        public readonly static Dictionary<string, string> BONE_NAME_FT =
            BONE_NAME_FINGERS
            .Concat(BONE_NAME_TOES).ToDictionary(c => c.Key, c => c.Value);

        public readonly static Dictionary<string, Vector3> BONE_DEFAULT_POSITON = new Dictionary<string, Vector3>()
        {
            { "Bip01", new Vector3(0f, 0.885f, 0f)},
        };

        public readonly static Dictionary<string, Vector3> BONE_DEFAULT_ROTATION = new Dictionary<string, Vector3>()
        {
            { MyConst.BONE_ALL, new Vector3(-80f, 179.99f, -90f) },
            { "Bip01 Head", new Vector3(0f, 0f, 10f) },
            { "Bip01 Neck", new Vector3(0f, 0f, -20f) },
            { "Bip01 Spine0a", new Vector3(0f, 0f, 15f) },
            { "Bip01 Spine", new Vector3(-89.5f, -15f, 90f) },
            { "Bip01 Pelvis", new Vector3(-89.5f, -15f, 90f) },

            { "Bip01 L Clavicle", new Vector3(0f, -90f, -179.99f) },
            { "Bip01 L Hand", new Vector3(-70f, 0f, 0f) },
            { "Bip01 R Clavicle", new Vector3(0f, 90f, 179.99f) },
            { "Bip01 R Hand", new Vector3(70f, 0f, 0f) },
            { "Bip01 L Thigh", new Vector3(0f, 179.99f, 0f) },
            { "Bip01 R Thigh", new Vector3(0f, -179.99f, 0f) },

            { "Bip01 L Finger0", new Vector3(40f, -20f, 0f) },
            { "Bip01 R Finger0", new Vector3(-40f, 20f, 0f) },
            { "Bip01 L Toe0", new Vector3(10f, 0f, -85f) },
            { "Bip01 L Toe1", new Vector3(-5f, 0f, -85f) },
            { "Bip01 L Toe2", new Vector3(0f, 0f, -85f) },
            { "Bip01 R Toe0", new Vector3(-10f, 0f, -85f) },
            { "Bip01 R Toe1", new Vector3(5f, 0f, -85f) },
            { "Bip01 R Toe2", new Vector3(0f, 0f, -85f) },
        };

        public readonly static Dictionary<string, string> EYE_MORPH = new Dictionary<string, string>()
        {
            { FACE_EYE_CLOSE, "1:目閉じ" },
            { FACE_EYE_SMILE, "1:にっこり" },
            { FACE_EYE_CLOSE_3, "1:ジト目" },
            { FACE_EYE_BIG, "1:見開く" },
            { FACE_EYE_CLOSE_5, "1:ウィンク左1" },
            { FACE_EYE_CLOSE_6, "1:ウィンク左2" },
            { FACE_EYE_CLOSE_7, "1:ウィンク右1" },
            { FACE_EYE_CLOSE_8, "1:ウィンク右2" },
        };

        public readonly static Dictionary<string, string> MAYU_MORPH = new Dictionary<string, string>()
        {
            { "mayuv", "2:眉キリッ" },
            { "mayuw", "2:眉困り" },
            { "mayuha", "2:眉ハの字" },
            { "mayuup", "2:眉上げ" },
            { "mayuvhalf", "2:眉傾き" },

            { "hitomis", "3:瞳サイズ" },
            { "hitomih", "3:ハイライト" },
        };

        public readonly static Dictionary<string, string> MOUTH_MORPH = new Dictionary<string, string>()
        {
            { FACE_MOUTH_A, "4:口あ" },
            { FACE_MOUTH_I, "4:口い" },
            { FACE_MOUTH_C, "4:口う" },
            { "mouths", "4:口笑顔" },
            { FACE_MOUTH_UP, "4:口角上げ" },
            { "mouthdw", "4:口角下げ" },
            { "mouthuphalf", "4:口角左上げ" },
            { "mouthhe", "4:への字口" },
            { "tangout", "4:舌出し1" },
            { "tangup", "4:舌出し2" },
            { "tangopen", "4:舌根上げ" },
            { "toothoff", "4:歯オフ" },
        };

        public readonly static Dictionary<string, string> FACE_OPTION_MORPH = new Dictionary<string, string>()
        {
            { FACE_OPTION_HOHO1, "5:頬１" },
            { "hoho", "5:頬２" },
            { "hohol", "5:頬３" },
            { FACE_OPTION_BLUSH, "5:赤面" },
            { "tear1", "5:涙１" },
            { "tear2", "5:涙２" },
            { "tear3", "5:涙３" },
            { FACE_OPTION_TEARS, "5:涙（玉）" },
            { "shock", "5:ショック" },
            { "yodare", "5:よだれ" },
        };

        public readonly static Dictionary<string, string> FACE_MORPH =
            EYE_MORPH
            .Concat(MAYU_MORPH).ToDictionary(c => c.Key, c => c.Value);

        public readonly static Dictionary<string, string> ALL_FACIAL_MORPH =
            FACE_MORPH
            .Concat(MOUTH_MORPH).ToDictionary(c => c.Key, c => c.Value)
            .Concat(FACE_OPTION_MORPH).ToDictionary(c => c.Key, c => c.Value);
        
        public readonly static Dictionary<string, string> BODY_MORPH = new Dictionary<string, string>()
        {
            { "Hara", "お腹" },
            { BODY_TAG_KUPA, "前穴" },
            { BODY_TAG_ANALKUPA, "後穴" },
            { "labiakupa", "陰唇" },
            { "vaginakupa", "膣" },
            { "nyodokupa", "尿道" },
            { "suji", "すじ" },
            { "clitoris", "クリ" },
            { "mons_veneris", "もりまん" },
            { "hip_crack_t1", "尻割れ目" },
        };

        public readonly static Dictionary<PrimitiveType, string> STAGE_OBJECT_TYPE = new Dictionary<PrimitiveType, string>()
        {
            { (PrimitiveType)STAGE_OBJECT_MIRROR, "mirror" },
            { (PrimitiveType) STAGE_OBJECT_SCREEN, "screen" },
            { (PrimitiveType) STAGE_OBJECT_POLE, "pole" },
            { (PrimitiveType) STAGE_OBJECT_LINE, "line" },
            { (PrimitiveType) STAGE_OBJECT_CURVED_PANEL, "curved_panel" },
            { (PrimitiveType) STAGE_OBJECT_CURVED_SCREEN, "curved_screen" },
            { PrimitiveType.Cylinder, "cylinder" },
            { PrimitiveType.Plane, "plane" },
            { PrimitiveType.Cube, "cube" },
            { PrimitiveType.Sphere, "sphere" },
            { PrimitiveType.Capsule, "capsule" },
        };

        public readonly static Dictionary<string, string> STAGE_BUBBLE_LAME_TYPE = new Dictionary<string, string>()
        {
            { "bubble", "Particle/Soap bubble01" },
            { "rame", "Particle/Prame" },
        };

        public readonly static Dictionary<ParticleSystemGradientMode, string> PARTICLE_GRADIENT_TYPE = new Dictionary<ParticleSystemGradientMode, string>()
        {
            { ParticleSystemGradientMode.Gradient, "１系統" },
            { ParticleSystemGradientMode.TwoGradients, "２系統" },
        };

        public readonly static string[] FACE_DANCE_RANDOM =
        {
            DANCE_FACE_EYE_CLOSE,
            "ダンス微笑み",
            DANCE_FACE_EYE_OPEN,
            "ダンス目とじ",
            "ダンス誘惑",
            "ダンス憂い",
        };

        public readonly static string[] FACE_DANCE_LABEL =
        {
            DANCE_FACE_EYE_CLOSE,
            "ダンスあくび",
            "ダンスびっくり",
            "ダンス微笑み",
            DANCE_FACE_EYE_OPEN,
            "ダンス目とじ",
            "ダンス誘惑",
            "ダンス困り顔",
            "ダンスウインク",
            "ダンス真剣",
            "ダンス憂い",
            "ダンスジト目",
            "ダンスキス",
        };

        public readonly static string[] FACE_GENERAL_LABEL =
        {
            "通常",
            "微笑み",
            "笑顔",
            "にっこり",
            "優しさ",
            "発情",
            "ジト目",
            "閉じ目",
            "思案伏せ目",
            "ドヤ顔",
            "引きつり笑顔",
            "苦笑い",
            "困った",
            "疑問",
            "ぷんすか",
            "むー",
            "泣き",
            "拗ね",
            "照れ",
            "きょとん",
            "びっくり",
            "少し怒り",
            "怒り",
            "照れ叫び",
            "誘惑",
            "接吻",
            "居眠り安眠",
            "まぶたギュ",
            "目を見開いて",
            "痛みで目を見開いて",
            "恥ずかしい",
            "ためいき",
            "目口閉じ",
            "ウインク照れ",
        };

        public readonly static string[] FACE_ERO_LABEL =
        {
            "エロ通常１",
            "エロ通常２",
            "エロ通常３",
            "エロ興奮０",
            "エロ興奮１",
            "エロ興奮２",
            "エロ興奮３",
            "エロ好感１",
            "エロ好感２",
            "エロ好感３",
            "エロ期待",
            "エロ羞恥１",
            "エロ羞恥２",
            "エロ羞恥３",
            "エロ緊張",
            "エロ我慢１",
            "エロ我慢２",
            "エロ我慢３",
            "エロ嫌悪１",
            "エロ痛み１",
            "エロ痛み２",
            "エロ痛み３",
            "エロ痛み我慢",
            "エロ痛み我慢２",
            "エロ痛み我慢３",
            "エロ怯え",
            "エロメソ泣き",
            "あーん",
            "エロ舌責",
            "エロ舌責快楽",
            "エロ舌責嫌悪",
            "エロ舐め通常",
            "エロ舐め通常２",
            "エロ舐め愛情",
            "エロ舐め愛情２",
            "エロ舐め快楽",
            "エロ舐め快楽２",
            "エロ舐め嫌悪",
            "エロ舐め嫌悪２",
            "エロフェラ通常",
            "エロフェラ愛情",
            "エロフェラ快楽",
            "エロフェラ嫌悪",
            "閉じ舐め通常",
            "閉じ舐め通常２",
            "閉じ舐め愛情",
            "閉じ舐め愛情２",
            "閉じ舐め快楽",
            "閉じ舐め快楽２",
            "閉じ舐め嫌悪",
            "閉じ舐め嫌悪２",
            "閉じフェラ通常",
            "閉じフェラ愛情",
            "閉じフェラ快楽",
            "閉じフェラ嫌悪",
            "通常射精後１",
            "通常射精後２",
            "絶頂射精後１",
            "絶頂射精後２",
            "興奮射精後１",
            "興奮射精後２",
            "余韻弱",
            "エロ絶頂",
            "エロ放心",
        };

        public readonly static string[] BONE_PATH =
        {
			"Bip01",
			"Bip01/Bip01 Footsteps",
			"Bip01/Bip01 Pelvis",
			"Bip01/Bip01 Pelvis/Bip01 L Thigh",
			"Bip01/Bip01 Pelvis/Bip01 L Thigh/Bip01 L Calf",
			"Bip01/Bip01 Pelvis/Bip01 L Thigh/Bip01 L Calf/Bip01 L Foot",
			"Bip01/Bip01 Pelvis/Bip01 L Thigh/Bip01 L Calf/Bip01 L Foot/Bip01 L Toe0",
			"Bip01/Bip01 Pelvis/Bip01 L Thigh/Bip01 L Calf/Bip01 L Foot/Bip01 L Toe0/Bip01 L Toe01",
			"Bip01/Bip01 Pelvis/Bip01 L Thigh/Bip01 L Calf/Bip01 L Foot/Bip01 L Toe1",
			"Bip01/Bip01 Pelvis/Bip01 L Thigh/Bip01 L Calf/Bip01 L Foot/Bip01 L Toe1/Bip01 L Toe11",
			"Bip01/Bip01 Pelvis/Bip01 L Thigh/Bip01 L Calf/Bip01 L Foot/Bip01 L Toe2",
			"Bip01/Bip01 Pelvis/Bip01 L Thigh/Bip01 L Calf/Bip01 L Foot/Bip01 L Toe2/Bip01 L Toe21",
			"Bip01/Bip01 Pelvis/Bip01 R Thigh",
			"Bip01/Bip01 Pelvis/Bip01 R Thigh/Bip01 R Calf",
			"Bip01/Bip01 Pelvis/Bip01 R Thigh/Bip01 R Calf/Bip01 R Foot",
			"Bip01/Bip01 Pelvis/Bip01 R Thigh/Bip01 R Calf/Bip01 R Foot/Bip01 R Toe0",
			"Bip01/Bip01 Pelvis/Bip01 R Thigh/Bip01 R Calf/Bip01 R Foot/Bip01 R Toe0/Bip01 R Toe01",
			"Bip01/Bip01 Pelvis/Bip01 R Thigh/Bip01 R Calf/Bip01 R Foot/Bip01 R Toe1",
			"Bip01/Bip01 Pelvis/Bip01 R Thigh/Bip01 R Calf/Bip01 R Foot/Bip01 R Toe1/Bip01 R Toe11",
			"Bip01/Bip01 Pelvis/Bip01 R Thigh/Bip01 R Calf/Bip01 R Foot/Bip01 R Toe2",
			"Bip01/Bip01 Pelvis/Bip01 R Thigh/Bip01 R Calf/Bip01 R Foot/Bip01 R Toe2/Bip01 R Toe21",
			"Bip01/Bip01 Spine",
			"Bip01/Bip01 Spine/Bip01 Spine0a",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 Neck",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 Neck/Bip01 Head",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand/Bip01 L Finger0",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand/Bip01 L Finger0/Bip01 L Finger01",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand/Bip01 L Finger0/Bip01 L Finger01/Bip01 L Finger02",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand/Bip01 L Finger1",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand/Bip01 L Finger1/Bip01 L Finger11",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand/Bip01 L Finger1/Bip01 L Finger11/Bip01 L Finger12",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand/Bip01 L Finger2",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand/Bip01 L Finger2/Bip01 L Finger21",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand/Bip01 L Finger2/Bip01 L Finger21/Bip01 L Finger22",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand/Bip01 L Finger3",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand/Bip01 L Finger3/Bip01 L Finger31",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand/Bip01 L Finger3/Bip01 L Finger31/Bip01 L Finger32",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand/Bip01 L Finger4",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand/Bip01 L Finger4/Bip01 L Finger41",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 L Clavicle/Bip01 L UpperArm/Bip01 L Forearm/Bip01 L Hand/Bip01 L Finger4/Bip01 L Finger41/Bip01 L Finger42",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand/Bip01 R Finger0",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand/Bip01 R Finger0/Bip01 R Finger01",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand/Bip01 R Finger0/Bip01 R Finger01/Bip01 R Finger02",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand/Bip01 R Finger1",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand/Bip01 R Finger1/Bip01 R Finger11",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand/Bip01 R Finger1/Bip01 R Finger11/Bip01 R Finger12",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand/Bip01 R Finger2",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand/Bip01 R Finger2/Bip01 R Finger21",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand/Bip01 R Finger2/Bip01 R Finger21/Bip01 R Finger22",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand/Bip01 R Finger3",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand/Bip01 R Finger3/Bip01 R Finger31",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand/Bip01 R Finger3/Bip01 R Finger31/Bip01 R Finger32",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand/Bip01 R Finger4",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand/Bip01 R Finger4/Bip01 R Finger41",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Bip01 R Clavicle/Bip01 R UpperArm/Bip01 R Forearm/Bip01 R Hand/Bip01 R Finger4/Bip01 R Finger41/Bip01 R Finger42",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Mune_L",
			"Bip01/Bip01 Spine/Bip01 Spine0a/Bip01 Spine1/Bip01 Spine1a/Mune_R",
		};

        public readonly static Dictionary<string, string> VMD_BONE_FINGER = new Dictionary<string, string>()
        {
            { "8D-B6-90-65-8E-77-82-50", "Bip01 L Finger01" }, //左親指１
            { "8D-B6-90-65-8E-77-82-51", "Bip01 L Finger02" }, //左親指２
            { "8D-B6-90-6C-8E-77-82-50", "Bip01 L Finger1" }, //左人指１
            { "8D-B6-90-6C-8E-77-82-51", "Bip01 L Finger11" }, //左人指２
            { "8D-B6-90-6C-8E-77-82-52", "Bip01 L Finger12" }, //左人指３
            { "8D-B6-92-86-8E-77-82-50", "Bip01 L Finger2" }, //左中指１
            { "8D-B6-92-86-8E-77-82-51", "Bip01 L Finger21" }, //左中指２
            { "8D-B6-92-86-8E-77-82-52", "Bip01 L Finger22" }, //左中指３
            { "8D-B6-96-F2-8E-77-82-50", "Bip01 L Finger3" }, //左薬指１
            { "8D-B6-96-F2-8E-77-82-51", "Bip01 L Finger31" }, //左薬指２
            { "8D-B6-96-F2-8E-77-82-52", "Bip01 L Finger32" }, //左薬指３
            { "8D-B6-8F-AC-8E-77-82-50", "Bip01 L Finger4" }, //左小指１
            { "8D-B6-8F-AC-8E-77-82-51", "Bip01 L Finger41" }, //左小指２
            { "8D-B6-8F-AC-8E-77-82-52", "Bip01 L Finger42" }, //左小指３
            { "89-45-90-65-8E-77-82-50", "Bip01 R Finger01" }, //右親指１
            { "89-45-90-65-8E-77-82-51", "Bip01 R Finger02" }, //右親指２
            { "89-45-90-6C-8E-77-82-50", "Bip01 R Finger1" }, //右人指１
            { "89-45-90-6C-8E-77-82-51", "Bip01 R Finger11" }, //右人指２
            { "89-45-90-6C-8E-77-82-52", "Bip01 R Finger12" }, //右人指３
            { "89-45-92-86-8E-77-82-50", "Bip01 R Finger2" }, //右中指１
            { "89-45-92-86-8E-77-82-51", "Bip01 R Finger21" }, //右中指２
            { "89-45-92-86-8E-77-82-52", "Bip01 R Finger22" }, //右中指３
            { "89-45-96-F2-8E-77-82-50", "Bip01 R Finger3" }, //右薬指１
            { "89-45-96-F2-8E-77-82-51", "Bip01 R Finger31" }, //右薬指２
            { "89-45-96-F2-8E-77-82-52", "Bip01 R Finger32" }, //右薬指３
            { "89-45-8F-AC-8E-77-82-50", "Bip01 R Finger4" }, //右小指１
            { "89-45-8F-AC-8E-77-82-51", "Bip01 R Finger41" }, //右小指２
            { "89-45-8F-AC-8E-77-82-52", "Bip01 R Finger42" }, //右小指３
        };

        /*
        public readonly static Dictionary<string, string> VMD_BONE_CONVERT = new Dictionary<string, string>()
        {
            //{ "83-5A-83-93-83-5E-81-5B", BONE_ALL }, //センター
            { "8F-E3-94-BC-90-67", "Bip01 Spine" }, //上半身
            { "8F-E3-94-BC-90-67-32", "Bip01 Spine1" }, //上半身2
            { "8F-E3-94-BC-90-67-32-90-E6", "Bip01 Spine1a" }, //上半身2先
            { "8E-F1", "Bip01 Neck" }, //首
            { "93-AA", BONE_HEAD }, //頭
            { "8D-B6-8C-A8", "Bip01 L Clavicle" }, //左肩
            { "8D-B6-98-72", "Bip01 L UpperArm" }, //左腕
            { "8D-B6-82-D0-82-B6", "Bip01 L Forearm" }, //左ひじ
            { "8D-B6-8E-E8-8E-F1", "Bip01 L Hand" }, //左手首
            { "89-45-8C-A8", "Bip01 R Clavicle" }, //右肩
            { "89-45-98-72", "Bip01 R UpperArm" }, //右腕
            { "89-45-82-D0-82-B6", "Bip01 R Forearm" }, //右ひじ
            { "89-45-8E-E8-8E-F1", "Bip01 R Hand" }, //右手首
            //{ "89-BA-94-BC-90-67", "Bip01 Pelvis" }, //下半身
            //{ "8D-B6-91-AB", "Bip01 L Thigh" }, //左足
            //{ "8D-B6-82-D0-82-B4", "Bip01 L Calf" }, //左ひざ
            //{ "8D-B6-91-AB-8E-F1", "Bip01 L Foot" }, //左足首
            //{ "89-45-91-AB", "Bip01 R Thigh" }, //右足
            //{ "89-45-82-D0-82-B4", "Bip01 R Calf" }, //右ひざ
            //{ "89-45-91-AB-8E-F1", "Bip01 R Foot" }, //右足首
            { "8D-B6-90-65-8E-77-82-50", "Bip01 L Finger0" }, //左親指１
            { "8D-B6-90-65-8E-77-82-51", "Bip01 L Finger01" }, //左親指２
            { "8D-B6-90-6C-8E-77-82-50", "Bip01 L Finger1" }, //左人指１
            { "8D-B6-90-6C-8E-77-82-51", "Bip01 L Finger11" }, //左人指２
            { "8D-B6-90-6C-8E-77-82-52", "Bip01 L Finger12" }, //左人指３
            { "8D-B6-92-86-8E-77-82-50", "Bip01 L Finger2" }, //左中指１
            { "8D-B6-92-86-8E-77-82-51", "Bip01 L Finger21" }, //左中指２
            { "8D-B6-92-86-8E-77-82-52", "Bip01 L Finger22" }, //左中指３
            { "8D-B6-96-F2-8E-77-82-50", "Bip01 L Finger3" }, //左薬指１
            { "8D-B6-96-F2-8E-77-82-51", "Bip01 L Finger31" }, //左薬指２
            { "8D-B6-96-F2-8E-77-82-52", "Bip01 L Finger32" }, //左薬指３
            { "8D-B6-8F-AC-8E-77-82-50", "Bip01 L Finger4" }, //左小指１
            { "8D-B6-8F-AC-8E-77-82-51", "Bip01 L Finger41" }, //左小指２
            { "8D-B6-8F-AC-8E-77-82-52", "Bip01 L Finger42" }, //左小指３
            { "89-45-90-65-8E-77-82-50", "Bip01 R Finger0" }, //右親指１
            { "89-45-90-65-8E-77-82-51", "Bip01 R Finger01" }, //右親指２
            { "89-45-90-6C-8E-77-82-50", "Bip01 R Finger1" }, //右人指１
            { "89-45-90-6C-8E-77-82-51", "Bip01 R Finger11" }, //右人指２
            { "89-45-90-6C-8E-77-82-52", "Bip01 R Finger12" }, //右人指３
            { "89-45-92-86-8E-77-82-50", "Bip01 R Finger2" }, //右中指１
            { "89-45-92-86-8E-77-82-51", "Bip01 R Finger21" }, //右中指２
            { "89-45-92-86-8E-77-82-52", "Bip01 R Finger22" }, //右中指３
            { "89-45-96-F2-8E-77-82-50", "Bip01 R Finger3" }, //右薬指１
            { "89-45-96-F2-8E-77-82-51", "Bip01 R Finger31" }, //右薬指２
            { "89-45-96-F2-8E-77-82-52", "Bip01 R Finger32" }, //右薬指３
            { "89-45-8F-AC-8E-77-82-50", "Bip01 R Finger4" }, //右小指１
            { "89-45-8F-AC-8E-77-82-51", "Bip01 R Finger41" }, //右小指２
            { "89-45-8F-AC-8E-77-82-52", "Bip01 R Finger42" }, //右小指３
            //{ "8D-B6-91-AB-82-68-82-6A", "_FOOT_IK_L" }, //左足ＩＫ
            //{ "89-45-91-AB-82-68-82-6A", "_FOOT_IK_R" }, //右足ＩＫ
            //{ "8D-B6-82-C2-82-DC-90-E6-82-68-82-6A", "_TOE_IK_L" }, //左つま先ＩＫ
            //{ "89-45-82-C2-82-DC-90-E6-82-68-82-6A", "_TOE_IK_R" }, //右つま先ＩＫ
        };
        */

        public readonly static Dictionary<string, string> VMD_MORPH_CONVERT = new Dictionary<string, string>()
        {
            { "8F-C6-82-EA-82-50", "hoho" }, //照れ１
            { "8F-C6-82-EA-82-51", "hoho" }, //照れ２
            { "90-D4-96-CA", "hohol" }, //赤面
            { "90-D4-96-CA-82-51", "hohol" }, //赤面２
            { "97-DC-82-50", FACE_OPTION_TEARS }, //涙１
            { "97-DC-82-51", FACE_OPTION_TEARS }, //涙２
            { "90-C2-82-B4-82-DF-82-E9", "shock" }, //青ざめる
            { "88-C3-82-A2-8A-E7", "shock" }, //暗い顔
            { "82-DC-82-CE-82-BD-82-AB", FACE_EYE_CLOSE }, //まばたき
            { "8F-CE-82-A2", FACE_EYE_SMILE }, //笑い
            { "8F-CE-82-A2-82-51", FACE_EYE_SMILE }, //笑い２
            { "82-B6-82-C6-96-DA", FACE_EYE_CLOSE_3 }, //じと目
            { "82-D1-82-C1-82-AD-82-E8", FACE_EYE_BIG }, //びっくり
            { "83-45-83-42-83-93-83-4E", FACE_EYE_CLOSE_5 }, //ウィンク
            { "83-45-83-42-83-93-83-4E-82-51", FACE_EYE_CLOSE_6 }, //ウィンク２
            { "90-5E-96-CA-96-DA", "mayuv" }, //真面目
            { "8D-A2-82-E9", "mayuw" }, //困る
            { "83-6E", "mayuha" }, //ハ
            { "82-C9-82-C1-82-B1-82-E8", "mayuup" }, //にっこり
            { "93-7B-82-E8", "mayuvhalf" }, //怒り
            { "93-B5-8F-AC", "hitomis" }, //瞳小
            { "83-6E-83-43-83-89-83-43-83-67-82-C8-82-B5", "hitomih" }, //ハイライトなし
            { "83-45-83-42-83-93-83-4E-89-45", FACE_EYE_CLOSE_7 }, //ウィンク右
            { "B3-A8-DD-B8-82-51-89-45", FACE_EYE_CLOSE_8 }, //ｳｨﾝｸ２右

            { "82-A0", FACE_MOUTH_A }, //あ
            { "82-A2", FACE_MOUTH_I }, //い
            { "82-A4", FACE_MOUTH_C }, //う
            { "82-A6", FACE_MOUTH_A }, //え
            { "82-A8", FACE_MOUTH_C }, //お
        };

        public readonly static Dictionary<string, Vector3> RESTRAINT_BACK = new Dictionary<string, Vector3>()
        {
            { "Bip01 L Clavicle", new Vector3(358.358f, 265.082f, 161.101f) },
            { "Bip01 L UpperArm", new Vector3(54.036f, 149.064f, 237.154f) },
            { "Bip01 L Forearm", new Vector3(0.000f, 0.000f, 90.995f) },
            { "Bip01 L Hand", new Vector3(281.637f, 214.666f, 167.775f) },

            { "Bip01 R Clavicle", new Vector3(0.650f, 96.864f, 174.239f) },
            { "Bip01 R UpperArm", new Vector3(316.301f, 192.747f, 260.026f) },
            { "Bip01 R Forearm", new Vector3(0.000f, 0.000f, 85.378f) },
            { "Bip01 R Hand", new Vector3(57.673f, 17.300f, 14.180f) },
        };

        public readonly static Dictionary<string, Vector3> RESTRAINT_NECK_ARM = new Dictionary<string, Vector3>()
        {
            { "Bip01 L Clavicle", new Vector3(358.589f, 264.179f, 165.999f) },
            { "Bip01 L UpperArm", new Vector3(291.458f, 251.434f, 75.793f) },
            { "Bip01 L Forearm", new Vector3(0.000f, 0.000f, 97.385f) },
            { "Bip01 L Hand", new Vector3(286.223f, 285.661f, 25.784f) },

            { "Bip01 R Clavicle", new Vector3(1.411f, 95.821f, 166.000f) },
            { "Bip01 R UpperArm", new Vector3(68.538f, 108.584f, 75.810f) },
            { "Bip01 R Forearm", new Vector3(0.000f, 0.000f, 97.384f) },
            { "Bip01 R Hand", new Vector3(73.776f, 74.328f, 25.767f) },
        };

        public readonly static string[] FREE_DANCE_OPTION_LABEL = { ">ダンス", ">メイド", ">サブ", };
        public readonly static string[] LOOK_AT_CAMERA_LABEL = { ">OFF", ">縦分割", ">横分割", ">小画面", ">追掛", };
        public readonly static string[] LOOK_AT_DIVIDED_LABEL = { "1a", "2a", "3a", "4a", "4b", "4c", "5a", "5b", "5c", "6a", "7a", "7b", "7c", "8b", "8c", "9a", "9b", "9c", };
        public readonly static string[] LOOK_AT_SUB_LABEL = { "左上", "右上", "左下", "右下", };
        public readonly static string[] LOOK_AT_SUB_SIZE_LABEL = { "S", "M", "L", };
        public readonly static string[] LOOK_AT_POINT_LABEL = { "顔", "胸", "股", "尻", };
        public readonly static string[] LOOK_AT_TYPE_LABEL = { "固定1", "固定2", "周囲", "回転", "オート", };
        public readonly static string[] LOOK_AT_SETTING_LABEL = { "設定1", "設定2", "設定3", "設定4", };
        public readonly static string[] LOOK_AT_ROUOND_LABEL = { "前", "後", "左", "右", "上", "下", };
        public readonly static string[] LOOK_AT_AUTO_LABEL = { "固定", "回転1", "回転2", "ズーム", "ロー(前)", "ロー(後)", };
        public readonly static string[] BONE_GROUP_LABEL = { "全部", "左腕", "右腕", "左足", "右足", "左手指", "右手指", "左足指", "右足指", };
        public readonly static string[] MORPH_GROUP_LABEL = { "全部", "目", "眉", "瞳", "目GP", "口", "頬涙", };
        public readonly static string[] MAID_APPEARANCE_LABEL = { ">仮髪", ">体(くぱ)", ">表情", };
        public readonly static string[] MAID_FACIAL_LABEL = { ">読込", ">目眉", ">口", ">頬涙", };
        public readonly static string[] MAID_SWING_LABEL = { ">胸", ">髪", ">スカート", };
        public readonly static string[] MAID_DRESS_LABEL = { ">仮衣装選択", ">仮衣装設定", ">プリセット", ">半脱ぎ切替", ">拘束", };
        public readonly static string[] MAID_MUNE_PARAM_LABEL = { "　重力", "　減衰力", "　柔らか", "　剛性最大:脱", "　剛性最小:脱", "　剛性最大:着", "　剛性最小:着", };
        public readonly static string[] MAID_HAIR_PARAM_LABEL = { "　減衰力", "　弾力", "　剛性", "　慣性", "　衝突判定", };
        public readonly static string[] MAID_SKIRT_PARAM_LABEL = { "　衝突判定", "　惰性割合", "　広がる力基準", "　足側衝突判定", "　戻る力", "　広がる力衝突", "　距離補正閾値", };
        public readonly static string[] MAID_MASK_LABEL = { ">乳首", ">陰部", };
        public readonly static string[] MAID_MOTION_PROC_LABEL = { ">モーション", ">ポーズ保持", ">キャプチャー", };
        public readonly static string[] MAID_MOTION_UPDATE_LABEL = { ">{0}個別設定", ">{0}追加・削除", ">フレーム追加", };
        public readonly static string[] STAGE_LIGHT_LABEL = { ">主・副", ">スポット", ">ポイント", };
        public readonly static string[] STAGE_PARTICLE_LABEL = { ">読込", ">放出設定", ">座標・色", };
        public readonly static string[] STAGE_OBJECT_LABEL = { ">モブ群衆", ">サイリウム", };
        public readonly static string[] TIME_LINE_LABEL = { ">読込／再生", ">体ボーン", ">指ボーン", ">表情", ">カメラ", };
        public readonly static string[] MOTION_FACIAL_LABEL = { ">[公式]一般", ">[公式]ダンス", ">[公式]エロ", ">カスタム"};
        //public readonly static string[] MOTION_OPTION_LABEL = { ">データ変換", ">ボーン選択" };
        public readonly static string[] MOTION_OPTION_LABEL = { ">데이터 변환", ">본 선택" };
        public readonly static string[] MOTION_VMD_LABEL = { "カメラ", "表情", "表情(口なし)", "指" };
        public readonly static string[] MOTION_FRAME_LABEL = { "番号増減", "連続削減", "指調整", "つま先調整" };
        public readonly static string[] MAID_MASK_VALUE = { "乳首左", "乳首右", "ヴァギナ", };
        public readonly static string[] MODEL_FOLLOWING_POINT_LABEL = { "顔", "胸", "股", "尻", "XZ位置", };
        public readonly static string[] TIMELINE_TYPE_LABEL = { "公式ダンス", "カスタムボーン", };
        public readonly static string[] TIMELINE_FACE_LABEL = { ">公式表情", ">オプション", };
        public readonly static string[] DANCE_MOVIE_LABEL = { "背景映像OFF", "ライブ", "劇場", };

        public readonly static string[] STAGE_LIVE = { "LiveStage", "LiveStage_Side", "LiveStage_use_dance" };
        public readonly static string[] STAGE_THEATER = { "Theater", "Theater_LightOff", "Theater_use_dance", "Theater_LightOff_use_dance" };
        public readonly static string[] STAGE_POLE = { "poledancestage" };
        public readonly static string[] PARTS_LIVE_OFFICIAL = { "Screen", "Screen_RollDiamondR", "Screen_RollDiamondL" };
        public readonly static string[] PARTS_LIVE_CUSTOM = { "Screen", "ScreenGrid_alpha01", "ScreenGrid_alpha02", "ScreenGrid_alpha07", "ScreenGrid_alpha08" };
        public readonly static string[] PARTS_POLE = { "PDS_monitor" };

        public readonly static string[] BODY_CHANGE_NOTICE
            = { "※NPC含む、リストのメイドが全て対象になります。",
                "　事前にSAVEデータをバックアップしてください。",
                "　変更内容はSAVEデータに反映されます。",
                "　他の設定に影響する可能性があります。",
                "　ボディメニュー以外は設定しないでください。",
                "　メイド呼び出し時に、大量エラーで落ちます。"
        };

        public readonly static int[] COM3D2_RANDOM_BGM_INDEX =
            { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22 };
        public readonly static LightType[] LIGHT_TYPE = { LightType.Spot, LightType.Point };

        public readonly static int[] GAME_WINDOW_WIDTH = { 1024, 1280, 1920 };
        public readonly static int[] GAME_WINDOW_HEIGHT = { 576, 720, 1080 };

        public readonly static Rect MAIN_WINDOW_RECT
            = new Rect(120, 0, GUI_WIDTH_MENU + (GUI_MARGIN + GUI_WIDTH) * 4, GUI_HEIGHT * GUI_WINDOW_ROW + GUI_MARGIN);
        public readonly static Rect MOTION_WINDOW_RECT
            = new Rect(MAIN_WINDOW_RECT.x + MAIN_WINDOW_RECT.width, 0, MAIN_WINDOW_RECT.width, MAIN_WINDOW_RECT.height);

        public readonly static Rect MAIN_WINDOW_DRAG_RECT
            = new Rect(0, 0, MAIN_WINDOW_RECT.width - (GUI_MARGIN + GUI_HEIGHT * 6), GUI_HEIGHT);
        public readonly static Rect MOTION_WINDOW_DRAG_RECT
            = new Rect(0, 0, MOTION_WINDOW_RECT.width - (GUI_MARGIN + GUI_HEIGHT), GUI_HEIGHT);

        public readonly static Rect DEFAULT_RECT
            = new Rect(GUI_WIDTH_MENU + GUI_MARGIN * 3, GUI_HEIGHT, GUI_WIDTH, GUI_HEIGHT);
        public readonly static Rect MENU_RECT
            = new Rect(GUI_MARGIN, GUI_HEIGHT, GUI_WIDTH_MENU, GUI_HEIGHT);
    }

    #region enum

    public enum GuiMenu
    {
        DanceFree,
        ShortCut,
        Maid,
        MaidLayout,
        MaidCollective,
        MaidSlot,
        MaidSwing,
        MaidDress,
        MaidAppearance,
        MaidMotion,
        MaidMove,
        BgMenu,
        BgSelect,
        BgParts,
        ForegroundSelect,
        StageDirectingMenu,
        StageObjectSelect,
        StageObjectEach,
        ParticleSelect,
        ModelSelect,
        LightSelect,
        CameraMenu,
        CameraLookAt,
        CameraAuto,
        CameraPlay,
        CameraTransform,
        ExtraMenu,
        Bukkake,
        Emission,
    }

    public enum DanceListType
    {
        Title,
        Motion,
        Data,
    }

    public enum DanceMovieType
    {
        Non,
        LiveStage,
        Theater,
        PoleStage,
    }

    public enum FreeDanceOptionType
    {
        Dance,
        Maid,
        Sub,
    }

    public enum MaidPointType
    {
        Head,
        Chest,
        Crotch,
        Hip,
        Bip,
    }

    public enum LookAtCameraType
    {
        Off,
        Vertical,
        Horizon,
        SubCamera,
        LockOn,
    }

    public enum LookAtType
    {
        FixRotate,
        Fix,        
        Around,
        Rotate,
        Auto,
    }

    public enum SongPoseType
    {
        MyPose,
        Animation,
        OldAnimation,
        AnimationNoLoop,
        OldAnimationNoLoop,
        TimeLineMotionLoop,
        MyPoseLoop,
        TimeLineMotion,
        DanceAnimationTime,
        OldDanceAnimationTime,
        Combination,
    }

    public enum LookAtAroundAngleType
    {
        Front,
        Back,
        Left,
        Right,
        Up,
        Down,
    }

    public enum LookAtAutoAngleType
    {
        Fix,
        Rotation1,
        Rotation2,
        Zoom,
        FrontLow,
        BackLow,
    }
    
    public enum SongType
    {
        Song,
        Com3d2,
        Cm3d2
    }

    public enum MaidAppearanceType
    {
        Hair,
        Body,
        Facial,
    }

    public enum MaidFacialType
    {
        Read,
        Eye,
        Mouth,
        Option,
    }

    public enum MaidMovingType
    {
        Wait,
        Move,
    }

    public enum StageParticleType
    {
        Load,
        Module,
        Position
    }

    public enum StageLineType
    {
        Square,
        Rhombus,
        Star
    }

    public enum StageLightType
    {
        MainSub,
        Spot,
        Point
    }

    public enum StageObjectEachType
    {
        Crowd,
        Cyalume,
    }

    public enum MaidDressType
    {
        TempDressSelect,
        TempDress,
        Preset,
        Porori,
        Bind,
    }

    public enum MaidMuneParam
    {
        Gravity,
        Damping,
        Yawaraka,
        MaxStiffness,
        MinStiffness,
        MaxStiffnessBra,
        MinStiffnessBra,
    }

    public enum MaidHairParam
    {
        Damping,
        Elasticity,
        Stiffness,
        Inert,
        Radius,
    }

    public enum MaidSkirtParam
    {
        Radius,
        Velocity,
        Force,
        RegRadius,
        Stiffness,
        Stress,
        Threshold,
    }

    public enum MaidMaskParam
    {
        Nip,
        Vag,
    }

    public enum MaidSwingType
    {
        Mune,
        Hair,
        Skirt,
    }

    public enum ParticleModuleType
    {
        Read,
        ModGroup1,
        ModGroup2,
        ModGroup3,
        ModGroup4,
        Position,
    }

    public enum EasingType
    {
        Linear,
        SineIn,
        SineOut,
        SineInOut,
        QuadIn,
        QuadOut,
        QuadInOut,
        CubicIn,
        CubicOut,
        CubicInOut,
        QuartIn,
        QuartOut,
        QuartInOut,
        QuintIn,
        QuintOut,
        QuintInOut,
        ExpIn,
        ExpOut,
        ExpInOut,
        CircIn,
        CircOut,
        CircInOut,
    }

    public enum MotionProcType
    {
        Motion,
        KeepPose,
        Capture,
    }

    public enum MotionUpdateType
    {
        ValueUpdating,
        BoneAddition,
        NewFrame,
    }

    public enum MotionTimeLineType
    {
        ReadAndPlay,
        BoneBody,
        BoneFinger,
        Morph,
        Camera,
    }

    public enum TimeLineMorphType
    {
        General,
        Dance,
        Ero,
        Custom,
    }

    public enum TimeLineFrameProcType
    {
        Non,
        Move,
        Copy,
        Delete,
    }

    public enum TimeLineFrameSelectType
    {
        Non,
        Min,
        Before,
        Next,
        Max,
    }

    public enum TimeLineOptionType
    {
        ConvertData,
        SelectBone,
    }

    public enum TimeLineVMDFileType
    {
        Camera,
        Morph,
        MorphNoMouth,
        Finger,
    }

    public enum TimeLineFaceType
    {
        Official,
        Option,
    }

    public enum FrameAjustmentType
    {
        FrameAjustment,
        BoneReduction,
        DeleteFinger,
        DefaultToe,
    }

    #endregion

}
